Regex:
if ($0 ~ /regex/) {} -> can match part of a string

# find pattern, print it and the previous line
/cancellation/{print x; print}
{x=$0}

#find pattern, print it, the previous line, and the following line
$ awk '/cheok/{print x; print; getline; print};{x=$0}' test.txt
line before
cheok is great
line after

$ echo -e "hi\nho" | awk '{print array["blah"]++}'
0
1

$ echo -e "hi\nho" | awk '{print ++array["blah"]}'
1
2

#count words
awk '{array[$0]++}END {for(i in array) print i, array[i]}'

awk print array: for (key in array)  print key, array[key]

#remove duplicate lines:
awk '!array[$0]++' < file

#print last field
awk '{print $NF}'

#print second last field
awk '{print $(NF-1)}'

#Regular expressions based input field separator
echo 'Sample123string54with908numbers' | awk -F'[0-9]+' '{print $2}'
--> string

#use -v to set variable
awk -v FS=":"

# changing a field will re-build contents of $0
# $1=$1 is an idiomatic way to re-build when there is nothing else to change
$ echo 'foo:123:bar:789' | awk -F: -v OFS='-' '{$1=$1; print $0}'
foo-123-bar-789

Idiomatic print usage
print statement with no arguments will print contents of $0
if condition is specified without corresponding statements, contents of $0 is printed if condition evaluates to true
1 is typically used to represent always true condition and thus print contents of $0
