Regex:
if ($0 ~ /regex/) {} -> can match part of a string

# find pattern, print it and the previous line
/cancellation/{print x; print}
{x=$0}

#find pattern, print it, the previous line, and the following line
$ awk '/cheok/{print x; print; getline; print};{x=$0}' test.txt
line before
cheok is great
line after

$ echo -e "hi\nho" | awk '{print array["blah"]++}'
0
1

$ echo -e "hi\nho" | awk '{print ++array["blah"]}'
1
2

#count words
awk '{array[$0]++}END {for(i in array) print i, array[i]}'

awk print array: for (key in array)  print key, array[key]

#remove duplicate lines:
awk '!array[$0]++' < file

#print last field
awk '{print $NF}'

#print second last field
awk '{print $(NF-1)}'

#Regular expressions based input field separator
echo 'Sample123string54with908numbers' | awk -F'[0-9]+' '{print $2}'
--> string

#use -v to set variable
awk -v FS=":"

# changing a field will re-build contents of $0
# $1=$1 is an idiomatic way to re-build when there is nothing else to change
$ echo 'foo:123:bar:789' | awk -F: -v OFS='-' '{$1=$1; print $0}'
foo-123-bar-789

Idiomatic print usage
print statement with no arguments will print contents of $0
if condition is specified without corresponding statements, contents of $0 is printed if condition evaluates to true
1 is typically used to represent always true condition and thus print contents of $0

#equivalent to grep -F
awk 'index($0,"a+b")' eqns.txt

#ignore case
awk -v IGNORECASE=1

#in-place edit
awk -i inplace '{gsub("e", "E")} 1' greeting.txt

#shell var
$ f='apple'
$ awk -v word="$f" '$1==word' fruits.txt
apple   42

#match lines that have either Antwerp or Chicago
awk '/Antwerp|Chicago/' r1.txt
#match lines that have neither Antwerp or Chicago
awk '!/Antwerp|Chicago/' r1.txt
#match lines that have both Antwerp and Chicago
awk '/Antwerp/ && /Chicago/' r1.txt
