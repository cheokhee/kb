Regex:
aString.matches("regex") -> has to match entire string

remove an element while iterating:
Iterator.remove()
java 8: coll.removeIf(i -> i.intValue() == 5);

HashMap is not thread-safe but Hashtable is thread-safe
HashMap allows one null key and null values but Hashtable doesn't allow null key or values.

jstack: show stack trace of each thread
e.g. jstack <process id of java process>

--format string
System.out.format("my name is %s, age is %03d", "cheok", 42);

double brace initialization:
original:
ArrayList<String> list = new ArrayList<String>();
list.add("A");
list.add("B");
list.add("C");
alternative:
ArrayList<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
    add("C");
}};

Arrays.asList("one", "two", "three")


    public static <T> List<T> asList(T... a) {
    return new ArrayList<T>(a);
    }

deal with keys and values of map:
for (Map.Entry<K, V> entries: hashmap.entrySet()) { }

anonymous java array: inline array
void method(String[] a)
how you call: method(new String[] {"123", "456"})
alternative:
void method(String... strs) // strs is seen as an array inside the method
how you call: method(new String[] {"123", "456"}) or method("123", "456")

#print various flags about JVM
java -XX:+PrintFlagsFinal -version
OR
java -XX:+PrintFlagsFinal -version | grep -iE 'HeapSize|PermSize|ThreadStackSize'

#measure elapsed time in code
long nanos = System.nanoTime();
nanos = System.nanoTime() - nanos;
logger.logDebug("elpased time: " + nanos / 1000000 + " ms");

check jdk version used to compile a class:
jar: look at manifest
class file:
javap -verbose <class file>
 java 1.2 uses major version 46
 Java 1.3 uses major version 47
 Java 1.4 uses major version 48
 Java 5 uses major version 49
 Java 6 uses major version 50
 Java 7 uses major version 51
 Java 8 uses major version 52
OR use the file command:
file <class file>

reflection
Class<?> clz = object.getClass();
try {
  Field field = clz.getDeclaredField("numberOfWantedPaths");
  field.setAccessible(true); // for private field
  field.getInt(object)); // for integer field

=======================
class.getName() vs class.getCanonicalName()
java.lang.String vs java.lang.String
java.util.AbstractMap$SimpleEntry vs java.util.AbstractMap.SimpleEntry // inner class
ClassnameTest$1 vs null // anonymous inner class
[Ljava.lang.Integer; vs java.lang.Integer[] // object array

name is the name that you'd use to dynamically load the class with, for example, a call to
Class.forName with the default classloader.

canonical name is the name that would be used in an import statement and uniquely identifies the
class. Might be useful during toString or logging operations

====================
JMX

To manage any resource through JMX, we need to create Managed Beans (MBeans) and then register it to
the MBean Server. MBean server works as a management agent for all the MBeans registered.

We use JMX Connectors to connect to MBean server and to manage the registered resources. For
example, JDK comes with JConsole through which you can connect to any local or remote MBean server.

the platform MBean server is also called the JMX agent

=============
Runnable vs Callable
Runnable does not return a result and cannot throw a checked exception.
Cannot returns a result and can throw a checked exception.

Implementing Runnable vs Extending Thread
by extending Thread, each of your threads has a unique object associated with it, whereas
implementing Runnable, many threads can share the same object instance.
====
A class that implements Runnable is not a thread and just a class. For a Runnable to become a
Thread, You need to create an instance of Thread and passing itself in as the target

========
Synchronized blocks in Java are reentrant. This means, that if a Java thread enters a
synchronized block of code, and thereby take the lock on the monitor object the block is
synchronized on, the thread can enter other Java code blocks synchronized on the same monitor
object. Here is an example:
example:
public class Reentrant{

  public synchronized outer(){
    inner();
  }

  public synchronized inner(){
    //do something
  }
}

Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a
synchronized(this) block. If a thread calls outer() there is no problem calling inner() from inside
outer(), since both methods (or blocks) are synchronized on the same monitor object ("this"). If a
thread already holds the lock on a monitor object, it has access to all blocks synchronized on the
same monitor object. This is called reentrance. The thread can reenter any block of code for which
it already holds the lock.

The set of active objects retained by the application at any point in time is known as the Live Set.

jcmd: send command requests to a JVM.
jcmd <pid> help
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
GC.rotate_log
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.run_finalization
GC.run
VM.uptime
VM.flags
VM.system_properties
VM.command_line
VM.version
====
jcmd <pid> help VM.version
====
jcmd <pid> VM.version
=== can use name ===
jcmd CommunityBootstrapper JFR.check
===
to start a jfr recording
jcmd 7060 JFR.start name=MyRecording settings=profile delay=20s duration=2m filename=/tmp/myrecording.jfr
---
jcmd 7060 JFR.dump name=MyRecording filename=/tmp/myrecording.jfr
===
jcmd <pid> GC.heap_dump filename=Myheapdump
===
jcmd <pid> GC.class_histogram filename=Myheaphistogram
===
jcmd <process id/main class> Thread.print
===
JFR.stop should be done after dumping

java 8 (reading file):
    List lines = Files.readAllLines(myFile)
    int count = lines.stream().map( l -> l.toLowerCase() ).filter( l -> l.contains
    (“secret”)).count();

#regular expression
Pattern r = Pattern.compile("([A-Z0-9]+)-([A-Z0-9]+)-([A-Z0-9]+)-([NSEW])");
Matcher m = r.matcher(string);
if (m.find()) { // found something }

Nested classes are divided into two categories: static and non-static. Nested classes that are
declared static are called static nested classes. Non-static nested classes are called inner
classes.
a static nested class is associated with its outer class
And like static class methods, a static nested class cannot refer directly to instance variables or
methods defined in its enclosing class: it can use them only through an object reference.
====
an inner class is associated with an instance of its enclosing class and has direct access to that
object's methods and fields. Also, because an inner class is associated with an instance, it cannot
define any static members itself.

TimeUnit.MILLISECONDS.toNanos()
TimeUnit.NANOSECONDS.toMicros()

lambda expression: parameters -> expression
example:
(String first, String second) -> Integer.compare(first.length(), second.length())
(String first, String second) -> { ... ; return something }
() -> { ...; }
words.filter(w -> w.length() > 12)
words.map(String::toLowerCase())
values.reduce((x,y) -> x+y) OR values.reduce(Integer::sum)
stream.iterator()
stream.toArray() -> return Object[]
stream.toArray(String[]::new)
stream.collect(Collectors.toList())
stream.collect(Collectors.toSet())
stream.collect(Collectors.toMap(Person::getId,Person::getName))
stream.collect(Collectors.toMap(Person::getId,Function.identity())
stream.collect(Collectors.joining(","))
stream.collect(Collectors.groupingBy())
stream.collect(Collectors.partitionBy())
stream.forEach(System.out::println)
====
stream operations: intermediate (return another stream) or terminal
intermediate: filter, map, flatMap, peek, distinct, sorted, limit, skip
terminal: forEach, toArray, reduce, collect, min, max, count, anyMatch, allMatch, noneMatch, findFirst, findAny
intermediate operations are lazy. only a terminal operation will start the processing of stream elements.
at that point, all the elements are consumed in one pass. stateful operations may require a second pass.
====
stream operation:
stateful: impose some new property on the stream. eg. sorting
short-circuiting: allows processing to stop without examining all the elements

functional interface : an interface with a single abstract method
you can supply a lambda expression whenever an object of a functional interface is expected.
example:
old: Arrays.sort(strings, new SomeComparator())
new: Arrays.sort(strings, (String first, String second) -> Integer.compare(first.length(), second.length()))
optional annotation : @FunctionalInterface
example: Supplier<T>, Consumer<T>
functional interfaces:
Function<T,R> : take T as input, return R as output
Predict<T>: take T as input and return a boolean as output
Consumer<T>: take T as input, perform some action and don't return anything
Supplier<T>: return T with nothing as input

method reference:
System.out::println is equivalent to x -> System.out.println(x)
Math::pow is equivalent to (x,y) -> Math.pow(x,y)

HashMap: no order
TreeMap: iterate according to the natural ordering of the keys
LinkedHashMap: iterate in the order in which the entries were put into the map

jjs : Nashorn JavaScript engine in Java 8

Java 8:
TemporalAdjuster
DateTimeFormatter
String.joined()
Objects.requireNonNull()
ProcessBuilder -> execute an external command
Files.copy()
Files.move()
Files.readAllBytes()
Paths

the Java memory model defines when changes made by one thread become visible
to another thread.

=== condition variable ===
lock = new ReentrantLock();
condition = lock.newCondition();
lock.lock();
try {
  while (condition is false)
    condition.await(); // when await() returns, it means the condition might be true
                       // that's why we need to check again. this is to handle spurious wakeup
  <<use shared resource>>
} finally { lock.unlock() }
=== condition variable ===

spurious wakeup: Even after a condition variable appears to have been signaled from a waiting
thread's point of view, the condition that was awaited may still be false.
?? If a Linux process is signaled its waiting threads will each enjoy a nice, hot spurious wakeup.
===
spurious wakeup: due to the fact that there is no guarantee around when a thread that has been
awakened will become scheduled. Condition variables are not fair. It's possible - and even likely -
that another thread will acquire the associated lock and make the condition false again before the
awakened thread has a chance to reacquire the lock and return to the critical region.

fair ReentrantLock: under contention, fair locks favor granting access to the longest-waiting thread.

The ReentrantLock constructor offers a choice of two fairness options: create a non-fair lock or a
fair lock. With fair locking, threads can acquire locks only in the order in which they were
requested, whereas an unfair lock allows a lock to acquire it out of its turn. This is called
barging (breaking the queue and acquiring the lock when it became available).

Fair locking has a significant performance cost because of the overhead of suspending and resuming
threads. There could be cases where there is a significant delay between when a suspended thread is
resumed and when it actually runs. Let's see a situation:

A -> holds a lock.
B -> has requested and is in a suspended state waiting for A to release the lock.
C -> requests the lock at the same time that A releases the lock, and has not yet gone to a suspended state.

As C has not yet gone to a suspended state, there is a chance that it can acquire the lock released
by A, use it, and release it before B even finishes waking up. So, in this context, unfair lock has
a significant performance advantage.

Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are
slower; often much slower) than those using the default setting, but have smaller variances in times
to obtain locks and guarantee lack of starvation.

A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for
writing. The read lock may be held simultaneously by multiple reader threads, so long as there are
no writers. The write lock is exclusive.

BlockingQueue:
A Queue that additionally supports operations that wait for the queue to become non-empty when
retrieving an element, and wait for space to become available in the queue when storing an element.
trying to read from an empty queue will block until the queue is non-empty.
trying to put into a full queue will block until the queue has available space.

Runtime.getRuntime().availableProcessors()
Executors.newFixedThreadPool(size)

CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of
operations being performed in other threads completes.

CyclicBarrier: A synchronization aid that allows a set of threads to all wait for each other to
reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of
threads that must occasionally wait for each other. The barrier is called cyclic because it can be
re-used after the waiting threads are released.
===
major difference: CountDownLatch-->NumberOfCalls, CyclicBarrier-->NumberOfThreads

Instant instant = Instant.ofEpochSecond(epochsecond);
ZonedDateTime.ofInstant(instant, ZoneId.of("GMT"));

A Java agent is a Java program that executes just prior to the start of another Java application
(the “target” application), affording that agent the opportunity to modify the target application,
or the environment in which it runs
===
1. Implement a static premain (as an analogy to main) method, like this:
import java.lang.instrument.Instrumentation;

class Example {
    public static void premain(String args, Instrumentation inst) {
        ...
    }
}
2. Create a manifest file (say, manifest.txt) marking this class for pre-main execution. Its contents are:
Premain-Class: Example
3. Compile the class and package this class into a JAR archive:
javac Example.java
jar cmf manifest.txt yourAwesomeAgent.jar *.class
4. Execute your JVM whith -javaagent parameter, like this:
java -javaagent:yourAwesomeAgent.jar -jar yourApp.jar
=====
