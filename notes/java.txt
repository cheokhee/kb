Regex:
aString.matches("regex") -> has to match entire string

remove an element while iterating:
Iterator.remove()
java 8: coll.removeIf(i -> i.intValue() == 5);

HashMap is not thread-safe but Hashtable is thread-safe
HashMap allows one null key and null values but Hashtable doesn't allow null key or values.

jstack: show stack trace of each thread
e.g. jstack <process id of java process>

--format string
System.out.format("my name is %s, age is %03d", "cheok", 42);

double brace initialization:
original:
ArrayList<String> list = new ArrayList<String>();
list.add("A");
list.add("B");
list.add("C");
alternative:
ArrayList<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
    add("C");
}};

Arrays.asList("one", "two", "three")


    public static <T> List<T> asList(T... a) {
    return new ArrayList<T>(a);
    }

deal with keys and values of map:
for (Map.Entry<K, V> entries: hashmap.entrySet()) { }

anonymous java array: inline array
void method(String[] a)
how you call: method(new String[] {"123", "456"})
alternative:
void method(String... strs) // strs is seen as an array inside the method
how you call: method(new String[] {"123", "456"}) or method("123", "456")

#print various flags about JVM
java -XX:+PrintFlagsFinal -version
OR
java -XX:+PrintFlagsFinal -version | grep -iE 'HeapSize|PermSize|ThreadStackSize'

#measure elapsed time in code
long nanos = System.nanoTime();
nanos = System.nanoTime() - nanos;
logger.logDebug("elpased time: " + nanos / 1000000 + " ms");

check jdk version used to compile a class:
jar: look at manifest
class file:
javap -verbose <class file>
 java 1.2 uses major version 46
 Java 1.3 uses major version 47
 Java 1.4 uses major version 48
 Java 5 uses major version 49
 Java 6 uses major version 50
 Java 7 uses major version 51
 Java 8 uses major version 52
OR use the file command:
file <class file>

reflection
Class<?> clz = object.getClass();
try {
  Field field = clz.getDeclaredField("numberOfWantedPaths");
  field.setAccessible(true); // for private field
  field.getInt(object)); // for integer field

=======================
class.getName() vs class.getCanonicalName()
java.lang.String vs java.lang.String
java.util.AbstractMap$SimpleEntry vs java.util.AbstractMap.SimpleEntry // inner class
ClassnameTest$1 vs null // anonymous inner class
[Ljava.lang.Integer; vs java.lang.Integer[] // object array

name is the name that you'd use to dynamically load the class with, for example, a call to
Class.forName with the default classloader.

canonical name is the name that would be used in an import statement and uniquely identifies the
class. Might be useful during toString or logging operations

====================
JMX

To manage any resource through JMX, we need to create Managed Beans (MBeans) and then register it to
the MBean Server. MBean server works as a management agent for all the MBeans registered.

We use JMX Connectors to connect to MBean server and to manage the registered resources. For
example, JDK comes with JConsole through which you can connect to any local or remote MBean server.

the platform MBean server is also called the JMX agent

=============
Runnable vs Callable
Runnable does not return a result and cannot throw a checked exception.
Cannot returns a result and can throw a checked exception.

Implementing Runnable vs Extending Thread
by extending Thread, each of your threads has a unique object associated with it, whereas
implementing Runnable, many threads can share the same object instance.
====
A class that implements Runnable is not a thread and just a class. For a Runnable to become a
Thread, You need to create an instance of Thread and passing itself in as the target

========
Synchronized blocks in Java are reentrant. This means, that if a Java thread enters a
synchronized block of code, and thereby take the lock on the monitor object the block is
synchronized on, the thread can enter other Java code blocks synchronized on the same monitor
object. Here is an example:
example:
public class Reentrant{

  public synchronized outer(){
    inner();
  }

  public synchronized inner(){
    //do something
  }
}

Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a
synchronized(this) block. If a thread calls outer() there is no problem calling inner() from inside
outer(), since both methods (or blocks) are synchronized on the same monitor object ("this"). If a
thread already holds the lock on a monitor object, it has access to all blocks synchronized on the
same monitor object. This is called reentrance. The thread can reenter any block of code for which
it already holds the lock.

The set of active objects retained by the application at any point in time is known as the Live Set.

jcmd: send command requests to a JVM.
jcmd <pid> help
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
GC.rotate_log
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.run_finalization
GC.run
VM.uptime
VM.flags
VM.system_properties
VM.command_line
VM.version
====
jcmd <pid> help VM.version
====
jcmd <pid> VM.version
=== can use name ===
jcmd CommunityBootstrapper JFR.check
===
to start a jfr recording
jcmd 7060 JFR.start name=MyRecording settings=profile delay=20s duration=2m filename=/tmp/myrecording.jfr
---
jcmd 7060 JFR.dump name=MyRecording filename=/tmp/myrecording.jfr
===
jcmd <pid> GC.heap_dump filename=Myheapdump
===
jcmd <pid> GC.class_histogram filename=Myheaphistogram
===
jcmd <process id/main class> Thread.print
===
JFR.stop should be done after dumping

java 8 (reading file):
    List lines = Files.readAllLines(myFile)
    int count = lines.stream().map( l -> l.toLowerCase() ).filter( l -> l.contains
    (“secret”)).count();

#regular expression
Pattern r = Pattern.compile("([A-Z0-9]+)-([A-Z0-9]+)-([A-Z0-9]+)-([NSEW])");
Matcher m = r.matcher(string);
if (m.find()) { // found something }

Nested classes are divided into two categories: static and non-static. Nested classes that are
declared static are called static nested classes. Non-static nested classes are called inner
classes.
a static nested class is associated with its outer class
And like static class methods, a static nested class cannot refer directly to instance variables or
methods defined in its enclosing class: it can use them only through an object reference.
====
an inner class is associated with an instance of its enclosing class and has direct access to that
object's methods and fields. Also, because an inner class is associated with an instance, it cannot
define any static members itself.
