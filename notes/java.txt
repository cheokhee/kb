Regex:
aString.matches("regex") -> has to match entire string

remove an element while iterating:
Iterator.remove()
java 8: coll.removeIf(i -> i.intValue() == 5);

HashMap is not thread-safe but Hashtable is thread-safe
HashMap allows one null key and null values but Hashtable doesn't allow null key or values.

jstack: show stack trace of each thread
e.g. jstack <process id of java process>

--format string
System.out.format("my name is %s, age is %03d", "cheok", 42);

double brace initialization:
original:
ArrayList<String> list = new ArrayList<String>();
list.add("A");
list.add("B");
list.add("C");
alternative:
ArrayList<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
    add("C");
}};

Arrays.asList("one", "two", "three")


    public static <T> List<T> asList(T... a) {
    return new ArrayList<T>(a);
    }

deal with keys and values of map:
for (Map.Entry<K, V> entries: hashmap.entrySet()) { }

anonymous java array: inline array
void method(String[] a)
how you call: method(new String[] {"123", "456"})
alternative:
void method(String... strs) // strs is seen as an array inside the method
how you call: method(new String[] {"123", "456"}) or method("123", "456")

#print various flags about JVM
java -XX:+PrintFlagsFinal -version
OR
java -XX:+PrintFlagsFinal -version | grep -iE 'HeapSize|PermSize|ThreadStackSize'

#measure elapsed time in code
long nanos = System.nanoTime();
nanos = System.nanoTime() - nanos;
logger.logDebug("elpased time: " + nanos / 1000000 + " ms");

check jdk version used to compile a class:
jar: look at manifest
class file:
javap -verbose <class file>
 java 1.2 uses major version 46
 Java 1.3 uses major version 47
 Java 1.4 uses major version 48
 Java 5 uses major version 49
 Java 6 uses major version 50
 Java 7 uses major version 51
 Java 8 uses major version 52
OR use the file command:
file <class file>

reflection
Class<?> clz = object.getClass();
try {
  Field field = clz.getDeclaredField("numberOfWantedPaths");
  field.setAccessible(true); // for private field
  field.getInt(object)); // for integer field

=======================
class.getName() vs class.getCanonicalName()
java.lang.String vs java.lang.String
java.util.AbstractMap$SimpleEntry vs java.util.AbstractMap.SimpleEntry // inner class
ClassnameTest$1 vs null // anonymous inner class
[Ljava.lang.Integer; vs java.lang.Integer[] // object array

name is the name that you'd use to dynamically load the class with, for example, a call to
Class.forName with the default classloader.

canonical name is the name that would be used in an import statement and uniquely identifies the
class. Might be useful during toString or logging operations

====================
JMX

To manage any resource through JMX, we need to create Managed Beans (MBeans) and then register it to
the MBean Server. MBean server works as a management agent for all the MBeans registered.

We use JMX Connectors to connect to MBean server and to manage the registered resources. For
example, JDK comes with JConsole through which you can connect to any local or remote MBean server.

the platform MBean server is also called the JMX agent
