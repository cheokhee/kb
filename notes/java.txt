Regex:
aString.matches("regex") -> has to match entire string

remove an element while iterating:
Iterator.remove()
java 8: coll.removeIf(i -> i.intValue() == 5);

HashMap is not thread-safe but Hashtable is thread-safe
HashMap allows one null key and null values but Hashtable doesn't allow null key or values.

jstack: show stack trace of each thread
e.g. jstack <process id of java process>

--format string
System.out.format("my name is %s, age is %03d", "cheok", 42);
String.format("%s %s", code, proformaId);

double brace initialization:
original:
ArrayList<String> list = new ArrayList<String>();
list.add("A");
list.add("B");
list.add("C");
alternative:
ArrayList<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
    add("C");
}};

Arrays.asList("one", "two", "three")
Arrays.asList() returns a private static class inside Arrays.
its size is fixed. cannot add to the result ArrayList.

    public static <T> List<T> asList(T... a) {
    return new ArrayList<T>(a);
    }

deal with keys and values of map:
for (Map.Entry<K, V> entries: hashmap.entrySet()) { }

anonymous java array: inline array
void method(String[] a)
how you call: method(new String[] {"123", "456"})
alternative:
void method(String... strs) // strs is seen as an array inside the method
how you call: method(new String[] {"123", "456"}) or method("123", "456")

#print various flags about JVM
java -XX:+PrintFlagsFinal -version
#print even more JVM flags
java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version
---
OR
java -XX:+PrintFlagsFinal -version | grep -iE 'HeapSize|PermSize|ThreadStackSize'

#measure elapsed time in code
long nanos = System.nanoTime();
nanos = System.nanoTime() - nanos;
logger.logDebug("elpased time: " + nanos / 1000000 + " ms");

check jdk version used to compile a class:
jar: look at manifest
class file:
javap -verbose <class file>
 java 1.2 uses major version 46
 Java 1.3 uses major version 47
 Java 1.4 uses major version 48
 Java 5 uses major version 49
 Java 6 uses major version 50
 Java 7 uses major version 51
 Java 8 uses major version 52
OR use the file command:
file <class file>

reflection
Class<?> clz = object.getClass();
try {
  Field field = clz.getDeclaredField("numberOfWantedPaths");
  field.setAccessible(true); // for private field
  field.getInt(object)); // for integer field

=======================
class.getName() vs class.getCanonicalName()
java.lang.String vs java.lang.String
java.util.AbstractMap$SimpleEntry vs java.util.AbstractMap.SimpleEntry // inner class
ClassnameTest$1 vs null // anonymous inner class
[Ljava.lang.Integer; vs java.lang.Integer[] // object array

name is the name that you'd use to dynamically load the class with, for example, a call to
Class.forName with the default classloader.

canonical name is the name that would be used in an import statement and uniquely identifies the
class. Might be useful during toString or logging operations

====================
JMX

To manage any resource through JMX, we need to create Managed Beans (MBeans) and then register it to
the MBean Server. MBean server works as a management agent for all the MBeans registered.

We use JMX Connectors to connect to MBean server and to manage the registered resources. For
example, JDK comes with JConsole through which you can connect to any local or remote MBean server.

the platform MBean server is also called the JMX agent

A Java Management Extensions (JMX) agent is a management entity that runs in a Java Virtual Machine
(Java VM) and acts as the liaison between the MBeans and the management application.
components of JMX agent:
#1. MBean server
The MBean server is the core component of a JMX agent. It is a registry for objects that are exposed
to management operations in an agent. Any object registered with the MBean server becomes visible to
management applications. However, the MBean server only exposes the management interface of an
MBean, never its direct object reference.  Any resource that you want to manage from outside the
agent’s Java VM must be registered as an MBean in the server.
==
#2. Agent Services
Agent services are objects that can perform management operations on the MBeans registered in the
MBean server. By including management intelligence into the agent, JMX helps you build more powerful
management solutions.
==
#3. Protocol Adaptors and Connectors
Protocol adaptors and connectors make the agent accessible from remote management applications.
The Java SE platform includes the standard RMI connecto

=============
Runnable vs Callable
Runnable does not return a result and cannot throw a checked exception.
Callable returns a result and can throw a checked exception.

Implementing Runnable vs Extending Thread
by extending Thread, each of your threads has a unique object associated with it, whereas
implementing Runnable, many threads can share the same object instance.
====
A class that implements Runnable is not a thread and just a class. For a Runnable to become a
Thread, You need to create an instance of Thread and passing itself in as the target

========
Synchronized blocks in Java are reentrant. This means, that if a Java thread enters a
synchronized block of code, and thereby take the lock on the monitor object the block is
synchronized on, the thread can enter other Java code blocks synchronized on the same monitor
object. Here is an example:
example:
public class Reentrant{

  public synchronized outer(){
    inner();
  }

  public synchronized inner(){
    //do something
  }
}

Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a
synchronized(this) block. If a thread calls outer() there is no problem calling inner() from inside
outer(), since both methods (or blocks) are synchronized on the same monitor object ("this"). If a
thread already holds the lock on a monitor object, it has access to all blocks synchronized on the
same monitor object. This is called reentrance. The thread can reenter any block of code for which
it already holds the lock.

The set of active objects retained by the application at any point in time is known as the Live Set.

jcmd: send command requests to a JVM.
jcmd <pid> help
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
GC.rotate_log
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.run_finalization
GC.run
VM.uptime
VM.flags
VM.system_properties
VM.command_line
VM.version
====
jcmd <pid> help VM.version
====
jcmd <pid> VM.version
=== can use name ===
jcmd CommunityBootstrapper JFR.check
===
to start a jfr recording
jcmd 7060 JFR.start name=MyRecording settings=profile delay=20s duration=2m filename=/tmp/myrecording.jfr
---
jcmd 7060 JFR.dump name=MyRecording filename=/tmp/myrecording.jfr
===
jcmd <pid> GC.heap_dump filename=Myheapdump
===
jcmd <pid> GC.class_histogram filename=Myheaphistogram
===
jcmd <process id/main class> Thread.print
===
JFR.stop should be done after dumping

java 8 (reading file):
    List lines = Files.readAllLines(myFile)
    int count = lines.stream().map( l -> l.toLowerCase() ).filter( l -> l.contains
    (“secret”)).count();
OR
try (Stream<String> lines = Files.lines(path)){
... }

read file into a string: new String(Files.readAllBytes(Paths.get("/home/file.txt")))

#regular expression
Pattern r = Pattern.compile("([A-Z0-9]+)-([A-Z0-9]+)-([A-Z0-9]+)-([NSEW])");
Matcher m = r.matcher(string);
if (m.find()) { // found something
matcher.group() // contains matched string
}

Nested classes are divided into two categories: static and non-static. Nested classes that are
declared static are called static nested classes. Non-static nested classes are called inner
classes.
a static nested class is associated with its outer class
And like static class methods, a static nested class cannot refer directly to instance variables or
methods defined in its enclosing class: it can use them only through an object reference.
====
an inner class is associated with an instance of its enclosing class and has direct access to that
object's methods and fields. Also, because an inner class is associated with an instance, it cannot
define any static members itself.
--
nested classes: allow logical groupings of related classes, provide increased encapsulation.

TimeUnit.MILLISECONDS.toNanos()
TimeUnit.NANOSECONDS.toMicros()

lambda expression: parameters -> expression
example:
(String first, String second) -> Integer.compare(first.length(), second.length())
(String first, String second) -> { ... ; return something }
() -> { ...; }
words.filter(w -> w.length() > 12)
words.map(String::toLowerCase())
values.reduce((x,y) -> x+y) OR values.reduce(Integer::sum)
stream.iterator()
stream.toArray() -> return Object[]
stream.toArray(String[]::new)
stream.collect(Collectors.toList())
stream.collect(Collectors.toSet())
stream.collect(Collectors.toMap(Person::getId,Person::getName))
stream.collect(Collectors.toMap(Person::getId,Function.identity())
stream.collect(Collectors.joining(","))
stream.collect(Collectors.groupingBy())
stream.collect(Collectors.partitionBy())
stream.forEach(System.out::println)
stream.forEach(x -> {System.out.println("string: " + x);});
====
stream operations: intermediate (return another stream) or terminal
intermediate: filter, map, flatMap, peek, distinct, sorted, limit, skip
terminal: forEach, toArray, reduce, collect, min, max, count, anyMatch, allMatch, noneMatch, findFirst, findAny
intermediate operations are lazy. only a terminal operation will start the processing of stream elements.
at that point, all the elements are consumed in one pass. stateful operations may require a second pass.
====
stream operation:
stateful: impose some new property on the stream. eg. sorting
short-circuiting: allows processing to stop without examining all the elements
--
java.util.stream.StreamSupport
Stream.of(anArray)
Arrays.stream()
IntStream.range(int, int)
Stream.iterate(Object, UnaryOperator);
The lines of a file can be obtained from BufferedReader.lines();
Streams of file paths can be obtained from methods in Files;
Streams of random numbers can be obtained from Random.ints();
Numerous other stream-bearing methods in the JDK, including BitSet.stream(),
Pattern.splitAsStream(java.lang.CharSequence), and JarFile.stream().
---
zip combines the elements of the source stream with the elements of a supplied stream, using a
pairwise zip transformation mapping that you can supply in the form of a lambda.

--
peek is a method in the Java 8 Stream API that allows you to use but not consume the data of an stream.
--
BiConsumer: Represents an operation that accepts two input arguments and returns no result.

functional interface : an interface with a single abstract method
--
If an interface declares an abstract method overriding one of the public methods of
java.lang.Object, that also does not count toward the interface's abstract method count since any
implementation of the interface will have an implementation from java.lang.Object or elsewhere.
--
instances of functional interfaces can be created with lambda expressions, method references, or
constructor references.
--
you can supply a lambda expression whenever an object of a functional interface is expected.
example:
old: Arrays.sort(strings, new SomeComparator())
new: Arrays.sort(strings, (String first, String second) -> Integer.compare(first.length(), second.length()))
optional annotation : @FunctionalInterface
example: Supplier<T>, Consumer<T>
functional interfaces:
Function<T,R> : take T as input, return R as output
Predict<T>: take T as input and return a boolean as output
Consumer<T>: take T as input, perform some action and don't return anything
Supplier<T>: return T with nothing as input
---

mutable reduction: accumulates input elements into a mutable result container.

reduce(identity, accumulator):
identity: the initial value of the reduction and the default result if there are no elements in the stream.
accumulator: take a partial result and the next element.

In its more general form, a reduce operation on elements of type <T> yielding a result of type <U>
requires three parameters:
 <U> U reduce(U identity,
              BiFunction<U, ? super T, U> accumulator,
              BinaryOperator<U> combiner);

example: collect():
<R> R collect(Supplier<R> supplier,
               BiConsumer<R, ? super T> accumulator,
               BiConsumer<R, R> combiner);
example (with loop):
ArrayList<String> strings = new ArrayList<>();
     for (T element : stream) {
         strings.add(element.toString());
     }
convert to:
#1.
ArrayList<String> strings = stream.collect(() -> new ArrayList<>(),
                                                (c, e) -> c.add(e.toString()),
                                                (c1, c2) -> c1.addAll(c2));
#2.
List<String> strings = stream.map(Object::toString)
                                  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
#3.
List<String> strings = stream.map(Object::toString)
                                  .collect(Collectors.toList());

method reference:
System.out::println is equivalent to x -> System.out.println(x)
Math::pow is equivalent to (x,y) -> Math.pow(x,y)
Comparator<Integer> normal = Integer::compare

HashMap: no order
TreeMap: iterate according to the natural ordering of the keys
LinkedHashMap: iterate in the order in which the entries were put into the map

jjs : Nashorn JavaScript engine in Java 8

Java 8:
TemporalAdjuster
DateTimeFormatter
String.joined()
Objects.requireNonNull()
ProcessBuilder -> execute an external command
Files.copy()
Files.move()
Files.readAllBytes()
Paths

=== condition variable ===
lock = new ReentrantLock();
condition = lock.newCondition();
lock.lock();
try {
  while (condition is false)
    condition.await(); // when await() returns, it means the condition might be true
                       // that's why we need to check again. this is to handle spurious wakeup
  <<use shared resource>>
} finally { lock.unlock() }
=== condition variable ===

spurious wakeup: Even after a condition variable appears to have been signaled from a waiting
thread's point of view, the condition that was awaited may still be false.
?? If a Linux process is signaled its waiting threads will each enjoy a nice, hot spurious wakeup.
===
spurious wakeup: due to the fact that there is no guarantee around when a thread that has been
awakened will become scheduled. Condition variables are not fair. It's possible - and even likely -
that another thread will acquire the associated lock and make the condition false again before the
awakened thread has a chance to reacquire the lock and return to the critical region.
===
spurious wakeup: a situation where a thread appears to be woken up by a condition variable whose
value is false.

fair ReentrantLock: under contention, fair locks favor granting access to the longest-waiting thread.

The ReentrantLock constructor offers a choice of two fairness options: create a non-fair lock or a
fair lock. With fair locking, threads can acquire locks only in the order in which they were
requested, whereas an unfair lock allows a lock to acquire it out of its turn. This is called
barging (breaking the queue and acquiring the lock when it became available).

Fair locking has a significant performance cost because of the overhead of suspending and resuming
threads. There could be cases where there is a significant delay between when a suspended thread is
resumed and when it actually runs. Let's see a situation:

A -> holds a lock.
B -> has requested and is in a suspended state waiting for A to release the lock.
C -> requests the lock at the same time that A releases the lock, and has not yet gone to a suspended state.

As C has not yet gone to a suspended state, there is a chance that it can acquire the lock released
by A, use it, and release it before B even finishes waking up. So, in this context, unfair lock has
a significant performance advantage.

Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are
slower; often much slower) than those using the default setting, but have smaller variances in times
to obtain locks and guarantee lack of starvation.

A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for
writing. The read lock may be held simultaneously by multiple reader threads, so long as there are
no writers. The write lock is exclusive.

BlockingQueue:
A Queue that additionally supports operations that wait for the queue to become non-empty when
retrieving an element, and wait for space to become available in the queue when storing an element.
trying to read from an empty queue will block until the queue is non-empty.
trying to put into a full queue will block until the queue has available space.

Runtime.getRuntime().availableProcessors()
Executors.newFixedThreadPool(size)

CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of
operations being performed in other threads completes.
===
CountDownLatch: a concurrency construct that allows one or more threads to wait for a given set of operations to
complete.

CyclicBarrier: A synchronization aid that allows a set of threads to all wait for each other to
reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of
threads that must occasionally wait for each other. The barrier is called cyclic because it can be
re-used after the waiting threads are released.
CyclicBarrier: like a reusable CountDownLatch
===
major difference: CountDownLatch-->NumberOfCalls, CyclicBarrier-->NumberOfThreads
===
Phaser: like a CyclicBarrier with multiple phases

Instant instant = Instant.ofEpochSecond(epochsecond);
ZonedDateTime.ofInstant(instant, ZoneId.of("GMT"));

A Java agent is a Java program that executes just prior to the start of another Java application
(the “target” application), affording that agent the opportunity to modify the target application,
or the environment in which it runs.
java agent is a program for instrumentating a java application.
The instrumentation API enables Java agents to transform the bytecode of existing classes.
===
1. Implement a static premain (as an analogy to main) method, like this:
import java.lang.instrument.Instrumentation;

class Example {
    public static void premain(String args, Instrumentation inst) {
        ...
    }
}
2. Create a manifest file (say, manifest.txt) marking this class for pre-main execution. Its contents are:
Premain-Class: Example
3. Compile the class and package this class into a JAR archive:
javac Example.java
jar cmf manifest.txt yourAwesomeAgent.jar *.class
4. Execute your JVM whith -javaagent parameter, like this:
java -javaagent:yourAwesomeAgent.jar -jar yourApp.jar
=====

bytecode manipulation:
java -cp <ASMstuff> org.objectweb.asm.util.TraceClassVisitor Helloworld.class

The JavaBeans spec defines a java property as a pair of getFoo/setFoo methods.

try with resources : resource is automatically closed
try (OutputStream s = new OutputStream(); ....) {
}
try with resource: class must implement AutoCloseable interface
try with resource: variables are closed in the reverse order from which they were initialized

java.nio : Path, Paths, FileSystem, Files, WatchService,
java.nio: asynchronous I/O
java.nio.file.Path -> register(aWatchService) : detect changes in a directory
java.nio.file.Files
java.nio.file.Paths
get a WatchService from java.nio.file.FileSystem.newWatchService()

Guice: the reference implementation for dependency injection in Java

classloaders: bootstrap, extension, application, custom classloader

==an alternative to reflection (java 7)
MethodHandle: in java.lang.invoke: a new way for invoking methods indirectly.
MethodType: an object that represents the type signature of a method.
MethodType.methodType(return-type.class, arg0-type.class, arg1-type.class, ...)
===
MethodType mtToString = MethodType.methodType(String.class);
MethodHandles.Lookup lk = MethodHandles.lookup();
try {
	mt = lk.findVirtual(MethodHandleTest.class, "toString", mtToString);
} catch (NoSuchMethodException | IllegalAccessException e) {
	e.printStackTrace();
}
try {
	String ret = (String) mt.invokeExact(new MethodHandleTest());
	System.out.println("cheok: " + ret);
} catch (Throwable e) {
	e.printStackTrace();
}
=====

java timing: most systems have several clocks
millisecond timings are safe and reliable
higher-precision timing need careful handling to avoid drift

JVM internal names for types:
[Ljava.lang.String : [ means array of, L<type name> : reference type
B: byte
C: char
D: double
F: float
I: int
J: long
S: short
Z: boolean

JVM switch:
-X: non-standard, eg. -Xms100m
-XX: extended, eg. -XX:hashCode=5, -XX:+UseG1GC, -XX:-OmitStackTraceInFastThrow, boolean switch: +/- to turn on/off

GC flags:
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCApplicationConcurrentTime
-XX:+DisableExplicitGC
-XX:+PrintGCTimeStamps #prepend relative timestamp since application starts
-XX:+PrintGCDetails
-XX:+PrintTenuringDistribution
-Xloggc:[path/to/gc.log]
-verbose:gc
-XX:+UseConcMarkSweepGC
-XX:CMSInitiatingOccupancyFraction=80
-XX:GCTimeLimit : sets an upper limit on the amount of time that GCs can spend in percent of the total time.
   Its default value is 98%. Decreasing this value reduces the amount of time
   allowed that can be spent in the garbage collections.
-XX:GCHeapFreeLimit
sets a lower limit on the amount of space that should be free after the garbage collections,
represented as percent of the maximum heap. It’s default value is 2%. Increasing this value means
that more heap space should get reclaimed by the GCs. An OutOfMemoryError is thrown after a Full GC
if the previous 5 consecutive GCs (could be minor or full) were not able to keep the GC cost below
GCTimeLimit and were not able to free up GCHeapFreeLimit space.

For example, setting GCHeapFreeLimit to 8 percent can help the garbage collector not get stuck in a
loop of invoking back-to-back Full GCs when it is not able to reclaim at least 8% of the heap and is
exceeding GCTimeLimit for 5 consecutive GCs.

== JVM diagnostic flags ==
get them from HotSpotDiagnostic MBean, attribute: DiagnosticOptions

jvisualvm: visualizing memory usage

G1 garbage collector: has a pause goal.

is List<String> a subtype of List<Object>? in java, the answer is no.
how to make it covariant and contravariant:
===
		// covariance: can read, but cannot write
		List<? extends Number> myNums = new ArrayList<Integer>();
		Number number = myNums.get(0);
		myNums.add(45); // compiler error
        // myNums is a collection of anything that is assignment-compatible with Number
        // i.e., anything that extends Number (including Number)
        // at runtime, we don't know the actual type of a generic structure (type erasure)
        // i.e., we don't know that we have a list of integers at runtime.
        // so we stop it at compile-time

		// contravariance: can write, but cannot read
		List<? super Number> myNums2 = new ArrayList<Object>();
		Number n2 = myNums2.get(0); // compiler error
		myNums2.add(45);
===
summary: use covariance when we only intend to take generic values out of a structure. use contravariance
when we only intend to put generic values into a structure
List<Number> and List<Integer> are not assignment-compatible:

        Number n1 = new Integer(1) // ok
        List<Number> a = new ArrayList<Integer>(); // compile error
        List<? extends Number> a = new ArrayList<Integer>(); // ok, covariance

        Number a = new Object() // compile error
        List<Number> a = new ArrayList<Object>() // compile error
        List<? super Number> a = new ArrayList<Object>() // ok

		List<Number> n1 = null;
		List<Integer> n2 = null;
		n1 = n2; // compiler error

		List<? extends Number> n1 = null;
		List<Integer> n2 = null;
		n1 = n2; // okay

        Object a = new String()
        String b = (String) new Object()

List<Dog> is not a valid substitute for a List<Animal>
there's something you can do with List<Animal> that isn't properly supported by List<Dog>.
That operation is the addition of an Animal: List<Dog> cannot contain an Animal or Cat.
You want to iterate over List<Dog> and safely extracting things from it while knowing
they are assignment-compatible with Animal, meaning they extends Animal

List<? extends Animal> : a collection of things that is assignment-compatible with Animal

if X is assignment-compatible with Y, X must be further down the inheritance hierarchy than Y: X
extends Y

if X is assignment-compatible with Y, it means you can assign an instance of type X to a variable of type Y
e.g. Integer is assignment-compatible with Number, can assign an instance of Integer to a variable of Number
Derived class is assignment-compatible with Base class: Base b = new Derived()
=======

is Array<String> a subtype of Array<Object>? in java, the answer is yes, because arrays are covariant

reifiable type:
a reifiable type is one whose runtime representation contains the same information as its compile-time representation
a non-reifiable type is one whose runtime representation contains less information than its compile-time representation
=====
Arrays are reifiable as arrays remains as it is at runtime While generic information attached with List is erased at runtime by erasures
in other words:
String[] str = new String[2]
will remain the same at runtime
=====
List is non-reifiable:
So List<String> list=new ArrayList<String>
at runtime will be
List list=new ArrayList();
===
all generic information is erased. This is done to support the legacy code that is written without using generics.
===
A reifiable type is a type whose type information is fully available at runtime. This includes
primitives, non-generic types, raw types, and invocations of unbound wildcards.
===
Non-reifiable types are types where information has been removed at compile-time by type erasure —
invocations of generic types that are not defined as unbounded wildcards. A non-reifiable type does
not have all of its information available at runtime. Examples of non-reifiable types are
List<String> and List<Number>; the JVM cannot tell the difference between these types at runtime.

Heap pollution occurs when a variable of a parameterized type refers to an object that is not of
that parameterized type. This situation occurs if the program performed some operation that gives
rise to an unchecked warning at compile-time.

artifact manager: allow you to share artifact with your team, but not the outside world. used with maven

glob patterns used NIO.2 in java 7:
* : zero or more characters
** : matches zero or more characters across directories
? : matches exactly one character

#create new instance from class object
		Class[] type = { HashMap.class, RelationshipType[].class, RelationshipType[].class,
				RelationshipType[].class, RelationshipType[].class, RelationshipType[].class,
				RelationshipType[].class };
        try {
			Constructor<T> constructor = Blah.class.getConstructor(type);
			return constructor.newInstance(input, connectedRelTypes, transhipmentRelTypes,
					transferRelTypes, connectedFeederRelTypes, transhipmentFeederRelTypes,
					transferFeederRelTypes);
====

The result of adding Java chars, shorts, or bytes is an int:

generic class: You can't use super in class declaration
generic method wildcards:
==
The wildcard can be used in a variety of situations: as the type of a parameter, field, or local
variable; sometimes as a return type (though it is better programming practice to be more
specific). The wildcard is never used as a type argument for a generic method invocation, a generic
class instance creation, or a supertype.
==
When to use extends and super:
If you get something from a parametrized container, use extends
int totalFuel(List<? extends Vehicle> list) {
    int total = 0;
    for(Vehicle v : list) {
        total += v.getFuel();
    }
    return total;
}
===
If you put objects into a parametrized container, use super.
int totalValue(Valuer<? super Vehicle> valuer) {
    int total = 0;
    for(Vehicle v : vehicles) {
        total += valuer.evaluate(v);
    }
    return total;
}

// extends vs super explanation //
List<? extends Number> foo3 = new ArrayList<Integer>();

Given any of the above, you can only read a Number object

You can't add any object to List<? extends T> because you can't guarantee what kind of List it is
really pointing to, so you can't guarantee that the object is allowed in that List. The only
"guarantee" is that you can only read from it and you'll get a T or subclass of T.

-------------
List<? super Integer> foo3 = new ArrayList<Object>();

Given the above, you can only read Object object.
You aren't guaranteed an Integer because foo3 could be pointing at a List<Number> or List<Object>.
You aren't guaranteed a Number because foo3 could be pointing at a List<Object>.
You can add an integer
You can add an instance of a subclass of Integer because an instance of a subclass of Integer is
allowed in any of the above lists.

variance: refers to how subtyping between more complex types relates to subtyping between their components.
covariance: means that if S is a subtype of T, the C<S> is a subtype of C<T>, where C is a generic type
  implications: u can use a more specific type than originally specified, u can pass C<S> to a method
                that accepts C<T>,
                the generic structure is read-only
                use extends
contravariance: means that if T is a subtype of S, the C<S> is a subtype of C<T>, where C is a generic type
  implications: u can use a less specific type than originally specified, u can pass C<T> to a method
                that accepts C<S>
                the generic structure is write-only
                use super
mnemonic: producer extends, consumer super (read from producer, write to consumer)

definition-site (declaration-site) variance: Scala,C#,Kotlin
use-site variance: Java (where wildcards in the type usages make the types covariant/contravariant)

// extends vs super explanation //

generic class: bounded type parameters
example: public class Garage<X extends Vehicle> { }

ExecutorService: allows you to submit jobs, represented either as Runnable
or Callable objects, to a pool of worker threads.
===
ExecutorService es = Executors.newFixedThreadPool(3);
Future<String> handle = es.submit(new MyJob());
handle.get();
===

HashMap:
store both key and value as an object of Entry class
hashing: put data in buckets determined by hash of key object
equals: compare key objects for equality
collision: more than one key having the same hash value
--
Bucket term used here is actually an index of array, that array is called table in HashMap
implementation. Thus table[0] is referred as bucket0, table[1] as bucket1 and so on.
--
within each bucket, a linked list is used to key-value pair (all keys have the same hash value)
--
given a key, get its hash value, which is an index into an array (get the bucket).
this array entry points to a linked list of key-value pair (Entry objects)
--
if key is null, map to bucket zero.
--
In Java 8 hash elements use balanced trees instead of linked lists after a certain threshold is
reached while storing values. This improves the worst case performance from O(n) to O(log n).

G1 GC log:
[Eden: 12.0M(12.0M)->0.0B(14.0M) Survivors: 0.0B->2048.0K Heap: 12.6M(252.0M)->7848.3K(252.0M)]
===
Eden: 12.0M(12.0M)->0.0B(14.0M) – indicates that Eden generation’s capacity was 12mb and all of the
12mb was occupied. After this GC event, young generation occupied size came down to 0. Target
Capacity of Eden generation has been increased to 14mb, but not yet committed.  Additional regions
are added to Eden generation, as demands are made.
--
Survivors: 0.0B->2048.0K – indicates that Survivor space was 0 bytes before this GC event. But after
the even Survivor size increased to 2048kb. It indicates that objects are promoted from Young
Generation to Survivor space.
--
Heap: 12.6M(252.0M)->7848.3K(252.0M) – indicates that capacity of heap size was 252mb, in that
12.6mb was utilized. After this GC event, heap utilization dropped to 7848.3kb (i.e. 5mb
(i.e. 12.6mb – 7848.3kb) of objects has been garbage collected in this event). And heap capacity
remained at 252mb.
====
Full GC (Allocation Failure) – indicates that this is a Full GC event, triggered because of
allocation failure. When the heap is fragmented, direct allocations in the Old generation may fail
even when there is a lot of free space, this will typically cause Allocation Failure.

HotSpot Serviceability Agent
provides a low-level view of a Java process from a VM perspective. It knows every- thing about Java
HotSpot VM internal structures, including the heap layout, the system dictionaries, the compiled
code, the threads, and the stacks.
--
{JAVA_HOME} /lib/sa-jdi.jar

Thread.join():
The join method allows one thread to wait for the completion of another. If t is a Thread object
whose thread is currently executing, t.join(); causes the current thread to pause execution until
t's thread terminates.

create and run a new thread:
new Thread(){
            public void run(){
                try{
                    Thread.sleep(1000);
                    t1.setStop(true);
                }catch(Exception e){}
            }}.start();

finally block:
finally block is executed if you return from a try/catch block
finally block is NOT executed if you call System.exit() from a try/catch block

Arrays.asList(anArray)
aList.toArray(new TypeName[0])

executable jar: In manifest: Main-Class:

java built-in thread pool:
java.util.concurrent.ExecutorService interface represents an asynchronous execution mechanism which
is capable of executing tasks in the background.
===
create an ExecutorService:
		ExecutorService executorService = Executors.newFixedThreadPool(10);
or: Executors.newSingleThreadExecutor();
===
executorService.execute(Runnable): cannot obtain result of Runnable
executorService.submit(Runnable): returns a Future object. This Future object can be used to check
if the Runnable as finished executing.
executorService.submit(Callable):
--
executorService.shutdown();
executorService.shutdownNow();
executorService.awaitTermination();
Executors.newCachedThreadPool() -> create threads on demand (better performance)

in J2EE application, modules are packaged as EAR, JAR and WAR based on their functionality
JAR: EJB modules which contain enterprise java beans (class files) and EJB deployment descriptor are
packed as JAR files with .jar extenstion
WAR: Web modules which contain Servlet class files, JSP Files, supporting files, GIF and HTML files
are packaged as JAR file with .war (web archive) extension
EAR: All above files (.jar and .war) are packaged as JAR file with .ear (enterprise archive)
extension and deployed into Application Server.
--
WAR (Web Archive) is a module that goes into web container of Java EE application server. A JavaEE
application server has two containers (runtime environments) - one is a web container and the other
is a EJB container.
--
Web container requires the web module to be packaged in WAR file that is a special JAR file with a
web.xml file in the WEB-INF folder.
--
Jetty and Tomcat: web server and servlet container. not full-fledged application server (no EJB):
   only servlet and JSP specs.
Jetty and Tomcat: do not support EAR files. only WAR files
Glassfish and JBoss: full-fledged Java EE servers.
JBoss Application Server comes with Tomcat as the default web container.
--
In application servers - EAR file contains configuration such as application security role mapping,
EJB reference mapping and context root url mapping of web modules.
Apart from Web modules and EJB modules EAR files can also contain connector modules packaged as RAR files and Client modules packaged as JAR files.

XSLT processing: javax.xml.transform.Transformer

StringReader class enables you to turn an ordinary String into a Reader
Java.io.Reader class is a abstract class for reading character streams

reader vs input stream: character-oriented vs byte-oriented

The context path is the prefix of a URL path that is used to select the web application to which an
incoming request is routed. Typically a URL in a Java servlet server is of the format
http://hostname.com/contextPath/servletPath/pathInfo, where each of the path elements may be zero or
more / separated elements. If there is no context path, the context is referred to as the root
context.

Sessions are a concept within the Servlet api which allow requests to store and retrieve information
across the time a user spends in an application.
--
Session Provides a way to identify a user across more than one page request or visit to a Web site and to
store information about that user.
---
ways to maintain sessions:
1. cookies
2. hidden form fields
3. URL rewriting
---
A web session is a sequence of network HTTP request and response transactions associated to the same
user.

getClass().getResource() vs getClass().getClassLoader().getResource()

PushbackInputStream: allow you to look ahead to see what the next char is.

Serializable: uses the default runtime mechanism to serialize the object
Externalizable: the class must handle its own serialization.

Enumerations: a fixed set of constants

RetentionPolicy.SOURCE: visible to compiler, not visible in .class file
RetentionPolicy.CLASS: visible in .class file
RetentionPolicy.RUNTIME: available to the runtime in the VM.

Objects.requireNonNull(object)

String formatting:
System.out.println(String.format("name is %s, age is %d", "cheok", 44));
System.out.println(java.text.MessageFormat.format("my name is {0}, my age is {1}", "hee", 49));

java.util.Scanner
			Scanner scanner = new Scanner(stream);
			while (scanner.hasNextLine()) {
				System.out.println("line: " + scanner.nextLine());
			}
			scanner.close();

--
Scanner sc = new Scanner(System.in);
int i = sc.nextInt();
--
System.out.println("Enter your username: ");
Scanner scanner = new Scanner(System.in);
String username = scanner.nextLine();
System.out.println("Your username is " + username);

Collections.synchronizedCollection()

The Spliterator can ‘split’ the Collection, partitioning off some of its elements as another
Spliterator. This does allow parallel processing of different parts of a Collection but note that
the Spliterator itself does not provide the parallel processing behaviour. Instead, the Spliterator
is there to support parallel traversal of the suitably partitioned parts of a Collection. This
solves the problem of dividing the data, as held in a Collection such as an ArrayList, into suitably
sized sub-units that can be processed in parallel.
--
Spliterator can be used to split given element set into multiple sets so that we can perform some
kind of operations/calculations on each set in different threads independently, possibly taking
advantage of parallelism. It is designed as parallel analogue of Iterator.

String.join(", ", list-of-strings);

ChronoUnit.DAYS.between()

#convert an integer to hex
Integer.toHexString(32)

convert ascii string to hex string:
Convert String to char array
Cast it to Integer
Use Integer.toHexString() to convert it to Hex
---
convert hex to ascii:
Cut the Hex value in 2 chars groups
Convert it to base 16 Integer using Integer.parseInt(hex, 16) and cast to char
Append all chars in StringBuilder

char is a 16-bit unsigned value and int is a 32-bit signed value. You can assign a char to an int.

results.sort(Comparator.comparing(Schedule::getOceanHours));
---
results.sort(COMPARATOR);
Comparator<HashMap> COMPARATOR = (first, second) -> Double.compare(first,second);

SimpleDateFormat: not thread-safe
use java.time.format.DateTimeFormatter instead
===
ZonedDateTime dt = ZonedDateTime.of(2017, 4, 10, 13, 40, 57, 0, ZoneId.of("UTC"));
		System.out.println("basic: " + DateTimeFormatter.BASIC_ISO_DATE.format(dt));
		System.out.println("iso date: " + DateTimeFormatter.ISO_DATE.format(dt));
		System.out.println("iso datetime: " + DateTimeFormatter.ISO_DATE_TIME.format(dt));
		System.out.println("iso local date: " + DateTimeFormatter.ISO_LOCAL_DATE.format(dt));
		System.out.println("iso local datetime: " + DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(dt));
output:
basic: 20170410Z
iso date: 2017-04-10Z
iso datetime: 2017-04-10T13:40:57Z[UTC]
iso local date: 2017-04-10
iso local datetime: 2017-04-10T13:40:57

all parallel streams use the common fork-join thread pool

== do calculation in my own for join pool
ForkJoinPool forkJoinPool = new ForkJoinPool(2);

forkJoinPool.submit(() ->
    range(1, 1_000_000).parallel().filter(PrimesPrint::isPrime)
        .collect(toList())
).get();

Runtime.getRuntime().availableProcessors()

Apache Lucene is a high-performance, full-featured text search engine library written entirely in
Java.
Elasticsearch is a search engine based on Lucene. is a distributed, RESTful search and analytics
engine

IntStream is a stream of primitive int values.
IntStream.range(1, 3);
// > 1, 2
IntStream.rangeClosed(1, 3);
// > 1, 2, 3
IntStream.iterate(0, i -> i + 2).limit(3); // the first element is 0
// > 0, 2, 4
IntStream.generate(() -> ThreadLocalRandom.current().nextInt(10)).limit(3);
// > 4, 1, 7
IntStream.range(1, 5).map(i -> i * i);
// > 1, 4, 9, 16
Stream<Color> stream = IntStream.range(1, 5).mapToObj(i -> getColor(i));
===
IntStream.rangeClosed(0, 2).boxed().map(x -> String.valueOf(x)).collect(Collectors.joining(","));
SAME AS
IntStream.rangeClosed(0, 2).mapToObj(x -> String.valueOf(x)).collect(Collectors.joining(","));

Arrays.toString

-- rounding a number:
DecimalFormat df = new DecimalFormat("#.##");
df.setRoundingMode(RoundingMode.HALF_UP);
df.format(number)
---
BigDecimal bd = new BigDecimal(Double.toString(d));
bd = bd.setScale(decimalPlace, BigDecimal.ROUND_HALF_UP);
return bd.doubleValue();
---
Math.round(xx)

private static ThreadLocal<SimpleDateFormat> DATETIME_DOM_FORMATER = new ThreadLocal<SimpleDateFormat>() {
  @Override
  protected SimpleDateFormat initialValue() {
    return new SimpleDateFormat("yyyyMMddHHmmss.SSS");
  }
};
--
java 8:
private static ThreadLocal<NumberFormat> numberFormatter =
   ThreadLocal.withInitial(() -> new DecimalFormat("00000"));

# the following two lines are the same
System.out.printf("my name is: %s%n", "joe"); // %n -> new line
System.out.format("my name is: %s%n", "joe"); // %n -> new line

format specifiers: %s, %f, etc

when to use parallel stream:
1. number of elements multiplied by cost per element should be large (the time required to
   execute a sequential version exceeds a minimum threshold)
2. source collection must be efficiently splittable. e.g. ArrayList, HashMap, arrays
3. per-element function is independent
4. have more than 1 cpu

factors to consider: cache locality, GC rates, JIT compilation, memory contention, data layout,
OS scheduling policies can have impact.

parallel stream: use ConcurrentHashMap rather than HashMap as the target, reduce overhead.

Java 8 has new concept called "Effectively final" variable. It means that a non-final local variable
whose value never changes after initialization is called "Effectively Final"

final variable: the reference to the object is final, not the value

assignment compatibility:
  • Every type is assignment-compatible with itself.

  • The boolean type is not assignment-compatible with any other type.

  • A value of any integer type can be assigned to a variable of any other
    integer type if the variable is of a type that allows it to contain the
    value without any loss of information.

  • A value of any integer type can be assigned to a variable of any
    floating-point type, but a value of any floating-point type cannot be
    assigned to a variable of any integer type.

  • A float value can be assigned to a double variable, but a double value
    cannot be assigned to a float variable.

  • With a type cast, a value of any arithmetic type can be assigned to a
    variable of any other arithmetic type.

  • Any reference can be assigned to a variable that is declared of type
    Object.

  • A reference to an object can be assigned to a class-type reference
    variable if the class of the variable is the same class or a superclass of
    the class of the object.

  • A reference to an object can be assigned to an interface-type reference
    variable if the class of the object implements the interface.

  • A reference to an array can be assigned to an array variable if either of
    the following conditions is true:

      -> Both array types contain elements of the same type.

      -> Both array types contain object references and the type of reference
        contained in the elements of the array reference can be assigned to
        the type of reference contained in the elements of the variable.

flatten example (flatmap):
final List<CoreResult> list = new LinkedList<>(SOME_DATA);
1.
final List<Double> A = list.stream()
      .map(CoreResult::getField)
      .collect(ArrayList::new, ArrayList::addAll, ArrayList::addAll);
2.
final List<Double> B = list.stream()
      .map(CoreResult::getField)
      .flatMap(Collection::stream)
      .collect(Collectors.toList());
3.
final List<Double> C = list.stream()
      .flatMap(x -> x.getField().stream())
      .collect(Collectors.toList());

Note: 2 and 3 are essentially the same

List<Double> list = doubleList.stream()
             .flatMap(List::stream)
             .collect(Collectors.toList());

flatmap example:
List<Schedule> results;
#1.
		Stream<List<ScheduleLeg>> map1 = results.stream().map(Schedule::getLegs);
		Stream<ScheduleLeg> flatmap = map1.flatMap(List::stream);
		flatmap.collect(Collectors.toList());
#2.
		Stream<ScheduleLeg> flatMap2 = results.stream().flatMap(x -> x.getLegs().stream());
		flatMap2.collect(Collectors.toList());

Note: #1 and #2 are equivalent

flatmap:
map is used to apply a function to each element. the function could return a new sequence,
in which case we go from one to many sequences. flatmap merges/flattens those sequences into one. (map + merge)

java enum API:
name() : Returns the name of this enum constant, exactly as declared in its enum declaration.
ordinal(): Returns the ordinal of this enumeration constant (its position in its enum declaration,
where the initial constant is assigned an ordinal of zero).
valueOf() :

The Java compiler automatically inserts a call to super() at the first line in the constructor.
The first statement of every constructor must be a call to either this() (an overloaded constructor) or super()
if there is no constructor, the compiler inserts a default no-argument constructor.

use iterator if you want to delete elements inside a loop.
must call iter.next() before calling iter.remove()

generics:
upper-bounded wildcards: restricts the unknown type to be a specific type or a subtype of that type
example: ? extends Number
---
lower-bounded wildcards: restricts the unknown type to be a specific type or a super type of that type.
example: ? super A
--- this method works on anything that can hold integer values
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}

convert Iterable to List
List<T> rels = Lists.newArrayList(anIterable);

In the Java programming language, a method signature is the method name and the number and type of
its parameters. Return types and thrown exceptions are not considered to be a part of the method
signature.

Collections.max(aCollection)

java assertion: an be activated at run-time by way of the -ea option on the java command, but are
not turned on by default.

synchronized method acquires a lock on the whole object. This means no other thread can use any
synchronized method in the whole object while the method is being run by one thread. synchronized
blocks acquires a lock on the object between parentheses after the synchronized keyword.  At run
time every class has an instance of a Class object. That is the object that is locked on by static
synchronized methods.

#array assignment does not make a copy
String[] array1 = {"hi", "cheok"};
String[] array2 = array1; // array2 and array1 are pointing to the same array in memory

The builder pattern is a good choice when designing classes whose constructors or static factories
would have more than a handful of parameters.

Telescoping Constructor Pattern:
Pizza(int size) { ... }
Pizza(int size, boolean cheese) { ... }
Pizza(int size, boolean cheese, boolean pepperoni) { ... }
Pizza(int size, boolean cheese, boolean pepperoni, boolean bacon) { ... }
--
alternative: JavaBean Pattern:
Pizza pizza = new Pizza(12);
pizza.setCheese(true);
pizza.setPepperoni(true);
pizza.setBacon(true);
--
The problem here is that because the object is created over several calls it may be in an
inconsistent state partway through its construction. This also requires a lot of extra effort to
ensure thread safety.

object histogram: a listing of how much memory is used by different types of objects.

memory analysis tool:
jps, jvisualvm (can do heap dump, jmap (object histogram and heap dump)
--
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/file
===
heap dump analyzer: eclipse MAT http://eclipse.org/mat
   (get the heap dump from jvisualvm: e.g. heapdump-1498767598154.hprof)
memory profiler: jvisualvm, java mission control (more accurate)
---
objects with increasing generational counts are leak candidates.

A heap dump is a snapshot of all the objects in the Java Virtual Machine (JVM) heap at a certain point in time.

-XX:MaxDirectMemorySize=1g

off heap memory: java.nio.ByteBuffer
sun.misc.Unsafe.allocateMemory()
sun.misc.Unsafe.freeMemory()

TLAB: thread local allocation buffers

BufferedReader.lines().skip(n)

classpath hell:
My application uses libraries "B" and "C", both of which use library "D".
But "B" and "C" require different versions of "D".
There's no version of "D" I can put on the CLASSPATH that will satisfy both "B" and "C".

Class loader priority: Parent First vs Parent Last
Some class loaders delegate requests immediately to the parent class loader, without searching first
in their own known set of directories for the class file. A class loader operating on this mode is
said to be in Parent First mode.
==
If a class loader first looks for a class locally before querying the parent, then that class loader
is said to be working in Parent Last mode.
--
tool: jHades: classpath trouble-shooting tool

A class is identified in the JVM not only by its fully qualified class name, but also by its class
loader.

The serialVersionUID have to match during the serialization and deserialization process.

hashcode: an integer returned by an object that is used by certain data structures (hashmap) when storing the object.

LinkedHashMap: extends HashMap and maintains a linked list of the entries in the map, in the order
in which they were inserted. This allows insertion-order iteration over the map. That is, when
iterating a LinkedHashMap, the elements will be returned in the order in which they were inserted.

variable declaration penetrates inside nested blocks:
{ int x = 100;
{int x = 20;} // compilation error
}

standard threads persist until run() exits (exception: daemon threads)

Thread.currentThread()
Thread: must call start(), not run()
Thread.sleep()
Thread.setDaemon()
Thread.join(): wait for the thread to die
java.util.concurrent.TimeUnit
deprecated: Thread. yield/stop/suspend/resume

program will not exit until all non-daemon threads exit.

$JAVA_HOME/jre/lib/logging.properties

junit Rules are used to add extra functionality that can applied to all test methods in a test
class. Rules can be used as an alternative to @Before/@After and @BeforeClass/@AfterClass.  Rules
provide a possibility to intercept test method calls similar as an AOP framework would do.
---
for how it works: JUnit wraps your test method in a Statement object so statement.Execute()
runs your test. Then instead of calling statement.Execute() directly to run your test, JUnit passes
the Statement to a TestRule with the @Rule annotation.
---
interface TestRule (annotation type Rule):
TestRules can do everything that could be done previously with methods annotated with Before, After,
BeforeClass, or AfterClass, but they are more powerful, and more easily shared between projects and
classes
--
The Statement passed to the TestRule will run any Before methods, then the Test method, and finally any After methods,
--
If there are multiple annotated Rules on a class, they will be applied in order of fields first,
then methods

java memory model defines how threads in the java language interact through memory.
==
The Java memory model specifies how and when different threads can see values written to shared
variables by other threads, and how to synchronize access to shared variables when necessary.
==
the Java memory model defines when changes made by one thread become visible to another thread.

volatile: threads will see the latest value

compiler/JVM can reorder code

final applied to array/collection: make the reference final, not the contents

long/double not thread-safe (unless volatile): maybe split into 2 32-bit operations
use AtomicLong, Long/Double wrapper

install memory fences to limit reordering
java: no word tearing?

Some processors do not provide the ability to write to a single byte. It would be illegal to
implement byte array updates on such a processor by simply reading an entire word, updating the
appropriate byte, and then writing the entire word back to memory. This problem is sometimes known
as word tearing,
--
If a variable crosses the boundary between memory units, which can happen if the machine supports
unaligned memory access, the computer may have to send the data in two bus transactions. An
unaligned 32-bit value, for example, may be sent by writing the two adjacent 32-bit memory units. If
either memory unit involved in the transaction is simultaneously written from another processor,
half of the value may be lost. This is called word tearing.
==
a single write to a non-volatile long or double value is treated as two separate writes: one to each
32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value
from one write, and the second 32 bits from another write.
===
word tearing: if accessing a variable/primitive data type requires two bus transactions (#1, unaligned memory access,
#2, long/double is split into two 32-bit writes), a thread may see the first 32 bits from one write
and the second 32-bits from another write.

====
		int i = 1;
		for (int i = 0;i<10;i++) { // compile error
		}
===
		for (int i = 0;i<10;i++) {
		}
        // the previous i goes out of scope here
		int i = 1; // compile ok

CopyOnWriteArrayList:
use it when many threads need concurrent read access. it is rare to modify the data.
CopyOnWriteArraySet is a thread-safe variant of HashSet which uses a underlying CopyOnWriteArrayList for all of its operations.

AtomicBoolean: for test-and-set. method: compareAndSet()

scheduled tasks:
ScheduledExecutorService and ScheduledFuture (new, use relative time)
  scheduleAtFixedRate
  scheduleWithFixedDelay: the given delay between the termination of one execution and the commencement of the next.
Timer and TimerTask (old, use absolute time)
example:
		final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
            ...
			}
		};
		cacheRefreshSchedule = scheduler.scheduleWithFixedDelay(runnable, cache.autoRefreshInterval,
				cache.autoRefreshInterval, TimeUnit.MINUTES);
---
can also use ScheduledThreadPoolExecutor

=====
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
            ...
			}
		};
		Thread t1 = new Thread(runnable);
		t1.start();
=====

Runnable is a functional interface
Runnable task = () -> System.out.println("hello");
Thread thread = new Thread(task);

Threads that want a signal call wait(), sleep until another thread calls notify()/notifyAll()
wait() : release the monitor. when it wakes up, reacquires the monitor
can wake up without notify() being called? spurious wakeup
need to synchronize before calling wait()/notify()
lost notification problem: interruption at the same time as notification. notify() is sent
before wait()

thread pool: ThreadPoolExecutor

Helper helper = new Helper();
the assignment to the helper variable can happen before the Helper() constructor is called/finished.
this is done by compiler.

nested classes are not loaded until they are referenced

atomic operations:
all assignments of primitive types except for long and double
all assignments of references
all assignments of volatile variables
all operations of java.concurrent.Atomic* classes

Initialization-on-demand holder idiom
In all versions of Java, the idiom enables a safe, highly concurrent lazy initialization with good performance.
===
public class Something {
    private Something() {}

    private static class LazyHolder {
        static final Something INSTANCE = new Something();
    }

    public static Something getInstance() {
        return LazyHolder.INSTANCE;
    }
}
---
When the class Something is loaded by the JVM, the class goes through initialization. Since the
class does not have any static variables to initialize, the initialization completes trivially. The
static class definition LazyHolder within it is not initialized until the JVM determines that
LazyHolder must be executed. The static class LazyHolder is only executed when the static method
getInstance is invoked on the class Something, and the first time this happens the JVM will load and
initialize the LazyHolder class. The initialization of the LazyHolder class results in static
variable INSTANCE being initialized by executing the (private) constructor for the outer class
Something. Since the class initialization phase is guaranteed by the JLS to be serial, i.e.,
non-concurrent, no further synchronization is required in the static getInstance method during
loading and initialization. And since the initialization phase writes the static variable INSTANCE
in a serial operation, all subsequent concurrent invocations of the getInstance will return the same
correctly initialized INSTANCE without incurring any additional synchronization overhead.

JMX:
MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
memoryMXBean.getHeapMemoryUsage().getMax();

Condition notFull = aReentrantLock.newCondition()
a condition object is used to park and awake threads
notFull.await() : blocking, can be interrupted
notFull.signal()

semaphore: has a number of permits, can be acquired and released

use explicit locking because of interruptbility, fairness, and time outs.

CyclicBarrier: to have several tasks wait for each other.
to synchronize several threads and let them continue when they reach a common point.
closes again once opened, allowing for cyclic computation (can be reused), can also be reset.
the barrier is closed at the beginning. it opens when all threads reach a common point.
example: split a task among multiple threads, then merge the result.
call barrier.await(), wait for the barrier to open
useful for parallel computation
like a reusable CountDownLatch
===
CountDownLatch: to count down operations and let a task start. once opened, cannot be closed
useful for starting an application upon completion of different initializations.

org.apache.commons.lang3.SerializationUtils class
Assists with the serialization process and performs additional functionality based on serialization.
==
Deep clone using serialization
Serialize managing finally and IOException
Deserialize managing finally and IOException

LongAdder, LongAccumulator
AtomicReference: reference assignment is atomic. use this class for compareAndSet(), getAndSet()

Deque: double-end queue
A linear collection that supports element insertion and removal at both ends.
can be both a queue and stack

HashMap: built on an array
given a key, calculate its hashcode, use it as an index into the backing array.
each cell in the array is called a bucket.

ConcurrentHashMap: built on a set of subarrays
default concurrency level: 16

ConcurrentSkipListMap: can be used to implement a linked list and a map

this.compareTo(other):
if this < other, return -1
if this == other, return 0
if this > other, return 1

Collectinos.unmodifiableList()

Java 9:
1. Factory methods for collections:
List<Point> list = List.of(new Point(1, 1), new Point(2, 2));
Set<String> set = Set.of("Hello", "World", "from", "Java");
Map<String, Integer> nameToAge = Map.of("Richard", 49, "Raoul", 47);
===

anonymous class: a class without a name.
example:
return new java.util.Enumeration() {
    Linkable current; = head;
    { current = head; }  // Replace constructor with an instance initializer
    public boolean hasMoreElements() {  return (current != null); }
    public Object nextElement() {
      if (current == null) throw new java.util.NoSuchElementException();
      Object value = current;
      current = current.getNext();
      return value;
    }
  };  // Note the required semicolon: it terminates the return statement


== RxJava ==
RxJava 1 is a Java VM implementation of ReactiveX (Reactive Extensions): a API for composing
asynchronous and event-based programs by using observable streams.
RxJava 2 implements Reactive Streams
--> you can decouple your services from one another.
reactive: event-driven, scalable, resilient (graceful error handling, manage failure), responsive
event-driven: react to events
scalable: react to load
resilient: react to failure, Resilience is about responsiveness under failure
responsive: react to user
elastic: responsiveness under load
meaning that the throughput of a system scales up or down (as well as in or out) automatically to
meet varying demand as resources are proportionally added or removed.

RxJava : single-threaded by default: your subscribe calls and all observer
event calls will be executed on the same thread that calls the subscribe method.
Observable, observer pattern, Observers subscribe to Observable
Observable: data stream
Observer: consume the data streams emitted by the Observable.
 -> Observers subscribe to the observable using subscribeOn() method to receive the data emitted by the observable.
--
Whenever the observable emits the data all the registered observer receives the data in onNext()
callback. If there is an error thrown from observable, the observer will receive it in onError().
--
Scheduler
Observer: onNext(), onCompleted(), onError()
Observable: non-blocking, blocking
Observable: subscribeOn(Scheduler): the scheduler determines
the thread your code will run on when you call the subscribe method.
==
Scheduler: allow you to specify what thread your code will execute on
BehaviorSubject: an Observable
marble diagrams: provide an interactive canvas for visualizing reactive constructs.
connectable observable: events are not emitted until connect() is called
Subject interface: a subscriber and an observable: PublishSubject, BehaviorSubject, AsyncSubject
==
Schedulers are the component in Rx that tells observable and observers, on which thread they should
run. You can use observeOn() method to tell observers, on which thread you should observe. Also, you
can use subscribeOn() to tell the observable, on which thread you should run.
you call observeOn() and subscribeOn() on the Observable
scheduler: thread management
Schedulers.newThread()
Schedulers.io()
==
use RxJava2
<dependency>
    <groupId>io.reactivex.rxjava2</groupId>
    <artifactId>rxjava</artifactId>
    <version>1.1.6</version>
</dependency>
===
example:
database.subscribeOn(Schedulers.newThread())          //Observable runs on new background thread.
        .observeOn(AndroidSchedulers.mainThread())    //Observer will run on main UI thread.
        .subscribe(observer);                         //Subscribe the observer
====
subscriber can establish 'reactive pull" backpressure
by calling Subscriber.request(n) in the Subscriber’s onStart() method
https://github.com/ReactiveX/RxJava/wiki/Backpressure
--
cold Observables : they only pump when there is a subscriber, and all subscribers receive the exact
set of historical data, regardless when they subscribe.
Hot Observables: pump regardless of the number of subscribers and generally pump just the latest data
to all subscribers (unless some caching strategy is applied).
--
Flowable class: implements flow control

VertX is a server framework for asynchronous servers while RxJava is a framework for asynchronous
computations.

#to trigger a Full thread dump
kill -QUIT <pid>

heap dump:
jcmd <process id/main class> GC.heap_dump filename=heapdump.dmp #put in home directory
jmap -dump:format=b,file=snapshot.jmap pid
-XX:+HeapDumpOnOutOfMemoryError

heap histogram:
-XX:+PrintClassHistogram and Control+Break
jcmd <process id/main class> GC.class_histogram filename=Myheaphistogram
jmap -histo pid
--
example:
jcmd <pid> GC.class_histogram | grep "java.lang.String$"
same as
jmap -histo <pid> | grep "java.lang.String$"

you must create a happens-before relationship between the write in one thread and the read
in another thread.

lambda expression stuff:
1. If a lambda expression references a local variable, it must be final or effectively final.
2. lambda expression can reference a non-final static variable.

An object's member variables are stored on the heap along with the object itself.
Static class variables are also stored on the heap along with the class definition.
A local variable may be of a primitive type, in which case it is totally kept on the thread stack.
==
A local variable may also be a reference to an object. In that case the reference (the local
variable) is stored on the thread stack, but the object itself is stored on the heap.
==
An object may contain methods and these methods may contain local variables. These local variables
are also stored on the thread stack, even if the object the method belongs to is stored on the heap.
==
Objects on the heap can be accessed by all threads that have a reference to the object. When a
thread has access to an object, it can also get access to that object's member variables. If two
threads call a method on the same object at the same time, they will both have access to the
object's member variables, but each thread will have its own copy of the local variables.

arrays are objects and are allocated on the heap

Java 7: final rethrow

java.nio.channels.AsynchronousFileChannel
1. use Future paradigm if you want your main thread to initiate I/O and then poll the results of
that I/O. AsynchronousFileChannel is associated with a thread pool.
===
AsynchronousFileChannel channel = AsynchronousFileChannel.open(aPath)
ByteBuffer buffer = ByteBuffer.allocate(...)
Future<Integer> result = channel.read(buffer, 0)
while (!result.isDone()) { // do stuff }
Integer bytesRead = result.get()

signature: <R> Stream<R> map(Function<? super T, ? extends R> mapper)
T is the input, R is the result
Function interface has: R apply(T t);
java.util.function.Function<String, Integer> f = (String x) -> x.length();

A Technology Compatibility Kit (TCK) is a suite of tests that at least nominally checks a particular
alleged implementation of a Java Specification Request (JSR) for compliance.

java -verbose:class

Thread.currentThread().getContextClassLoader()

== jinfo ==
jinfo <pid>

if error: Can't attach to the process: ptrace(PTRACE_ATTACH, ..)
solution: echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
== jinfo ==

initial heap size : -Xms256m
  1/64 of physical memory up to 1 GB
max heap size: -Xmx1024m
  1/4 of physical memory up to 1 GB

https://github.com/chewiebug/GCViewer
usage:
java -jar gcviewer.jar log/gc.log.0.current summary.csv
java -jar gcviewer.jar log/gc.log.0.current summary.csv chart.png
# default: SUMMARY
java -jar gcviewer.jar gc.log.0;gc.log.1;gc.log.2;gc.log.current summary.csv [chart.png] [-t PLAIN|CSV|CSV_TS|SIMPLE|SUMMARY]

java 9:
Reactive Streams API (in the form of the java.util.concurrent.Flow class).
Process API has been updated, greatly improving Java’s ability to interact with the OS.
Java Platform Module System, which modularizes the JDK, allowing administrators to only deploy the
  necessary features of the JDK for the applications that are being run.
Compact strings, where internally strings are stored as a byte array and an encoding, instead of a
  char array of 2-byte Unicode characters.
The Stack Walking API, allowing quick filtering and lazy traversal of a stack trace, via the
java.lang.Stackwalker class.
Unicode 8.0 support.

Java 8 has 4 garbage collectors: Serial, Parallel (default), CMS, G1
Java 8 garbage collector:
Serial: do not use it
---
Parallel collector. This is the JVM’s default collector. its biggest advantage is that is uses
multiple threads to scan through and compact the heap. The downside to the parallel collector is
that it will stop application threads when performing either a minor or full GC collection. The
parallel collector is best suited for apps that can tolerate application pauses and are trying to
optimize for lower CPU overhead caused by the collector.
  tuning: -XX:MaxGCPauseMillis=<N> in ms, it means pause time of N or less is desired
  -XX:GCTimeRatio=<N>, which sets the ratio of garbage collection time to application time to 1 / (1 + <N>).
==
CMS collector (“concurrent-mark-sweep”). This algorithm uses multiple threads (“concurrent”) to scan
through the heap (“mark”) for unused objects that can be recycled (“sweep”).
This collector is for applications that prefer shorter garbage collection pauses and can afford to
share processor resources with the garbage collection.
===
Garbage first collector (G1) introduced in JDK 7 update 4 was designed to better support heaps
larger than 4GB. The G1 collector utilizes multiple background threads to scan through the heap that
it divides into regions, spanning from 1MB to 32MB (depending on the size of your heap). G1
collector is geared towards scanning those regions that contain the most garbage objects first,
giving it its name (Garbage first). This collector is turned on using the -XX:+UseG1GC flag.
  -XX:MaxGCPauseMillis
---
  -XX:+UseStringDeduplication : requires the G1 Garbage Collector and is turned off by default.
  comes with Java 8 update 20. there is overhead.
  -XX:+PrintStringDeduplicationStatistics
  -XX:GCPauseIntervalMillis
====
G1 collector is for multiprocessor machines with large memories. It meets garbage collection pause
time goals with high probability while achieving high throughput.
===
CMS and G1 collectors will cause less frequent GC pauses. But when a pause do comes, its duration
will most likely be longer than the one caused by the Parallel collector. On the other hand, the
Parallel collector usually achieves higher throughput for the same size of heap.
==
CMS and G1 are mostly concurrent collector: perform its work concurrently while the app is still
running to keep GC pauses short
===
If response time is more important than overall throughput and garbage collection pauses must be
kept shorter than approximately 1 second, then select the concurrent collector with
-XX:+UseConcMarkSweepGC or -XX:+UseG1GC.
===

profiler:
#1. standard: connect directly to JVM: VisualVM, JProfiler, YourKit and Java Mission Control.
#2. lightweight transaction profiler: XRebel and Stackify Prefix.
a. Aspect Profilers use aspect-oriented programming (AOP) to inject code into the start and end of
specified methods. The injected code can start a timer and then report the elapsed time when the
method finishes.
b. Java Agent profilers use the Java Instrumentation API to inject code into your application. This
method has greater access to your application since the code is being rewritten at the bytecode
level. This allows for any code running in your application to be instrumented
#3. profiling in production (APM)
New Relic, AppDynamics, Stackify Retrace, Dynatrace.
use the Java Agent profiler method but with different instrumentation rules to allow them to run
without affecting production performance.

Neo4j VM flags:
-XX:+DisableExplicitGC -XX:+FlightRecorder -XX:InitialHeapSize=8589934592 -XX:+ManagementServer
-XX:MaxHeapSize=8589934592 -XX:-OmitStackTraceInFastThrow -XX:+PreserveFramePointer -XX:+PrintGC
-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
-XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution -XX:+UnlockCommercialFeatures
-XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:hashCode=5

--serial
Map<Person.Sex, List<Person>> byGender =
    roster
        .stream()
        .collect(Collectors.groupingBy(Person::getGender));

--parellel
ConcurrentMap<Person.Sex, List<Person>> byGender =
    roster
        .parallelStream()
        .collect(Collectors.groupingByConcurrent(Person::getGender));

java -XshowSettings
java -XX:+PrintCommandLineFlags 2>/dev/null

synchronized: why this keyword?
the memory representation of the locked object in different threads is what is being synchronized.
after the synchronized block is completed, all changes made to the locked object are flushed
to main memory before the lock is released.
when a synchronized block is entered, all changes to the locked object are read from main memory
before the synchronized block is executed.
===
synchronized: means that it will synchronize its view of an object with main memory.

Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime,
without knowing the names of the classes, methods etc. at compile time. It is also possible to
instantiate new objects, invoke methods and get/set field values using reflection.

type descriptors:
B: byte
C: char
D: double
F: float
I: int
J: long
L<typename> : eg Ljava/lang/String, reference type
S: short
Z: boolean
[: array of

how to GC log:
[collector-name: <occupancy at start>-><occupancy at end>(<total size>)] \
<full heap occupancy at start>-><full heap occupancy at end>(<total heap size>) \
pause time

-XX:+PrintGCApplicationStoppedTime:
show how long threads were stopped during an operation that was started at a safepoint. not just
GC, there are other safepoint operations, such as biased lock operations

G1 collector: the central idea is to control the pause goal.
G1: divide the heap into equal-sized regions that aren't distinguished between young and old regions.

-XX:+PrintCompilation

CompletableFuture:
==
Combine several asynchronous operation
Wait for task completion
Listen to Future completion and react to it success or error completion
Chaining results of dependent futures
default: use the common thread pool
==
It can be explicitly completed by calling the complete() method without any synchronous wait. It
allows values of any type to be available in the future with default return values, even if the
computation didn’t complete, using default / intermediate results.
==
CompletableFuture.runAsync()
CompletableFuture.supplyAsync()
---
CompletableFuture: allow you to express the flow of information from different tasks using
a callback-driven style.

java 9:
jhsdb
jmod describe jmods/java.base.jmod
jmod list jmods/java.base.jmod

java 9:
List<String> list = List.of("cheok","is","here")
Set<String> set = Set.of("cheok","is","here")
Map<String,Integer> nameToAge = Map.of("cheok",49,"hee",48)
Map<String,Integer> nameToAge = Map.ofEntries(Map.entry("cheok",49),Map.entry("hee",48))

Stream.ofNullable
--
Stream.takeWhile() : stop as soon as it finds an element that fails the test
Stream.of("cheok","is","here").takeWhile(x -> x.length() > 3).collect(Collectors.toList())
==> [cheok]
--
Stream.dropWhile() : drop element while the predicate is true, as soon as it finds one that
                     is false, return the remaining.
Stream.of("cheok","is","here").dropWhile(x -> x.length() > 3).collect(Collectors.toList())
==> [is, here]

java 9: reactive streams: java.util.concurrent.Flow
==
Flow.Processor<T,R> A component that acts as both a Subscriber and Publisher.
Flow.Publisher<T>   A producer of items (and related control messages) received by Subscribers.
Flow.Subscriber<T>	A receiver of messages.
Flow.Subscription	Message control linking a Flow.Publisher and Flow.Subscriber.

All arithmetic is performed using at least int-sized values and, therefore, the result of the add
operation is an int- sized value

use Iterator.remove() to remove elements while iterating over it.

==
List<String> list = Arrays.asList("foo", "bar", "baz");
String joined = String.join(" and ", list); // "foo and bar and baz"
--
String joinedFirstNames = list.stream()
  .map(Person::getFirstName)
  .collect(Collectors.joining(", ")); // "John, Anna, Paul"

Spring has the concept of proiles. Proiles are essentially labels, or tags, for Spring beans. Beans
in a given proile don’t exist unless that proile is activated. The easiest way to activate a proile
is to use a command-line argument when you run the java command. For example, if you want to
activate all the beans under the profile1 and profile2 proiles, you’d use a command line like this:
java -Dspring.profiles.active=profile1,profile2 -jar ...

gradle commands: help, projects, properties

CollectionUtils.addIgnoreNull(aColl, anObj)

Function.identity() same as x -> x

method references:
static: Integer::parseInt
bound: Instant.now()::isAfter
unbound: String::toLowerCase
class constructor: String::new
Array constructor: int[]:new

activities.stream().map(x -> x.getLocalDate()).min(String::compareTo).get();
vs
routePoints.sort(Comparator.comparing(RoutePoint::getEarliestLocalEventDate));

Java 10: type inference
Map<User, List<String>> userChannels = new HashMap<>();
becomes: var userChannels = new HashMap<User, List<String>>();

java has several nondenotable types—that is, types that can exist within your program, but for which
there’s no way to explicitly write out the name for the types. A good example of a nonde- notable
type is an anonymous class—you can add fields and methods to it, but you won’t be able to write the
name of the anonymous class in your Java code.

var productInfo = new Object() {
String name = "Apple";
int total = 30;
};
System.out.println(
"name = " + productInfo.name + ", total = " + productInfo.total);

There’s a better approach that you can take with var : using an anonymous class as a store for
intermediate values.

Function interface:
    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }

marker interface: an empty interface (no field or methods). Examples of marker interface are
Serializable, Clonnable and Remote interface. All these interfaces are empty interfaces.
