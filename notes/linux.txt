ldd : print shared library dependencies

=====
boot-up:

run scripts at startup : put in /etc/rc.local
others:
/etc/init.d/rcS
run scripts in /etc/rc2.d, which links to /etc/init.d

create init-style startup script:
update-rc.d <name> defaults

read /etc/rc2.d/README

default runlevel in /etc/init/rc-sysinit.conf

#start service at boot-up:
update-rc.d SERVICENAME defaults

#remove service from start at boot-up
update-rc.d -f service_name remove

===================================
#ways to manage upstart/init job

upstart jobs are in /etc/init
initctl list : list upstart job

#1:
#start/stop upstart job
start/stop/status docker #as root

#2:
#service
service --status-all
service docker stop/start/restart

#3:
/etc/init.d/docker start/stop/status

#4:
invoke-rc.d docker status

==================================

/etc/init/ttyN.conf : start a getty process for ttyN
stop tty6 : stop tty6

/etc/init/control-alt-delete.conf; define behavior for ctrl-alt-del

/var/log : lots of logs
/var/lib
/var/spool
/usr/share

/var/log/syslog
/var/log/auth.log #sudo log
/var/log/Xorg.0.log
/var/log/apport.log
/var/log/kern.log
/var/log/wtmp
/var/log/pm-powersave.log
/var/log/gpu-manager.log
/var/log/boot.log
/var/log/dmesg
/var/log/udev
/var/log/dpkg.log
/var/log/alternatives.log
/var/log/upstart/
/var/log/lightdm/

dig: DNS lookup utility

file copy tool: rsync

lsmod: list kernel module
modinfo: display module info
modules are in /lib/modules/
rmmod: remove modules
modprobe: add or remove modules

--cron change
move popularity-contest from /etc/cron.daily to ~root/cron
move bsdmainutils from /etc/cron.daily to ~root/cron
move mlocate from /etc/cron.daily to /etc/cron.monthly
move locate from /etc/cron.daily to /etc/cron.monthly

--cron change 2015-01-16
change /etc/cron.daily/locate:
 add "/C /D /Data" to PRUNEPATHS
 add vboxsf to PRUNEFS

/etc/updatedb.conf:
   add /C to prunepaths
   add vboxsf to prunefs
DB: /var/lib/mlocate/mlocate.db

consider disabling mlocate cron job

anacron: for desktops and laptops that are not running 24/7
/var/spool/anacron
/etc/anacrontab

run-parts --report /etc/cron.daily

ufw - program for managing a netfilter firewall
ufw allow 22

sudo visudo #change /etc/sudoers file:
#allow user cheok to run docker without being prompted for the password
#sudo only ask for password per xterm session
added this line:
cheok ALL=(ALL) NOPASSWD: /usr/bin/docker

#swappiness
#the smaller the number, the less aggressive linux will swap
cat /proc/sys/vm/swappiness

/etc/sysctl.conf

iftop : display bandwidth usage on an interface by host
whois : client for the whois directory service

font cache commands:
fc-cache
fc-cat
fc-list
fc-match
fc-pattern
fc-query
fc-scan
fc-validate

fc : shell builtin that display and edits command
help fc : help is a shell builtin

#show distro info : LSB: linux standard base
--> lsb_release -a
output:
Distributor ID: Ubuntu
Description:    Ubuntu 14.10
Release:        14.10
Codename:       utopic

/etc/os-release

partprobe: inform the OS of partition table changes

commands:
lsattr
lsblk
lsb_release
lscpu
lsdiff
lshw
lsinitramfs
lslocks
lsmod
lsnrctl
lsof
lspci
lspcmcia
lspgpot
lsusb

initramfs: initial RAM-based filesystem: allow the kernel to execute programs before the root filesystem is mounted.
initrd: initial RAM disk: serves as a temporary root file system in RAM and allows the kernel to boot without
having to mount any physical disk.

GRUB config:
make a copy of /etc/default/grub and /boot/grub/grub.cfg
1. change /etc/default/grub
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
GRUB_GFXMODE=640x480
#supported resolution?: 640×480, 800×600, 1024×768, 1280×1024, 1600×1200
2. run update-grub , this will change /boot/grub/grub.cfg
output of update-grub:
Found linux image: /boot/vmlinuz-3.16.0-30-generic
Found initrd image: /boot/initrd.img-3.16.0-30-generic
Found linux image: /boot/vmlinuz-3.16.0-23-generic
Found initrd image: /boot/initrd.img-3.16.0-23-generic
Found memtest86+ image: /boot/memtest86+.elf
Found memtest86+ image: /boot/memtest86+.bin
Found Windows 7 (loader) on /dev/sda2
===================================================
gfxmode:

If this variable is set, it sets the resolution used on the ‘gfxterm’ graphical terminal. Note that
you can only use modes which your graphics card supports via VESA BIOS Extensions (VBE), The default
is ‘auto’, which selects a platform-specific default that should look reasonable.
====
The resolution may be specified as a sequence of one or more modes, separated by commas (‘,’) or
semicolons (‘;’); each will be tried in turn until one is found. Each mode should be either ‘auto’,
‘widthxheight’, or ‘widthxheightxdepth’.

gfxpayload:

If this variable is set, it controls the video mode in which the Linux kernel starts up, replacing
the ‘vga=’ boot option. It may be set to ‘text’ to force the Linux kernel to boot in normal text
mode, ‘keep’ to preserve the graphics mode set using ‘gfxmode’, or any of the permitted values for
‘gfxmode’ to set a particular graphics mode (see gfxmode).

----------------------------------------------

uninstall a kernel image: apt-get remove linux-image-4.2.0-30-generic

/tmp cleanup, happen on reboot:
/etc/init/mounted-tmp.conf , which uses /etc/default/rcS , use TMPTIME var

#printf builtin (in bash):
$ printf "%d" "'a"
97
$ printf "%x" "'a"
61
'a -> convert a to its ascii code

need cifs-utils to access windows server, then do: sudo mount -t cifs -o username=heech //snt2/isdc ~/j

#add shared library path
option 1:
LD_LIBRARY_PATH is an environment variable you set to give the run-time shared library loader (ld.so) an extra set of directories to look for when searching for shared libraries
example: LD_LIBRARY_PATH=~/instantclient_11_2 python3
option 2:
 create a file under /etc/ld.so.conf.d/, then run ldconfig

##print shared libraries dependencies: ldd command

need instantclient-basic-linux.x64-11.2.0.3.0.zip instantclient-sdk-linux.x64-11.2.0.3.0.zip

add include and library path gcc:
C_INCLUDE_PATH=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 pip3 install --user cx_Oracle

special case (for npm oracledb only):
OCI_INC_DIR=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 npm install oracledb

#stop this message (when running evince): Couldn't connect to accessibility bus: Failed to connect to socket /tmp/dbus-sCAvokkUFt: Connection refused
export NO_AT_BRIDGE=1

rsync -avP userid@host:/path/to/file .
also: -z for compress
-P : preserve partially copied files, you can pick up where you left off
gotchas:
#1 Copy entire directory to remote parent directory:
rsync /path/without/slash host:/path/to/parent/with/slash/
------
#1a. dest does not exist
eg. rsync -av max tmp # same as rsync -av max tmp/
result: tmp is created and max is under tmp: tmp/max
diff -r max tmp/max #identical
#1b. dest exists
eg. rsync -av max tmp # same as rsync -av max tmp/
result: max is under tmp: tmp/max
diff -r max tmp/max #identical
---
#2 Copy contents of one directory to another:
rsync -r /path/to/directory/* host:/path/to/directory/
----
#2a. dest does not or does exist (dest dir is created if necessary)
eg rsync -av max/* tmp/ # same as rsync -av max/* tmp
diff -r max tmp #identical
----------
#3 Copy a directory into a new directory on another host:
rsync /path/without/slash host:/path/to/new/directory
#4 rsync file dirname #copy file to dirname/file
#5 rsync file dirname/filename #copy file to dirname/filename
#6 rsync file dirname/ #copy file to dirname/file, creating dirname if necessary

#cp
#1: dest is a directory -> make a copy with the same name in directory
#2: dest is not a directory -> make a copy with the specified path name.

#fast way to delete large number of files
mkdir empty && rsync -r --delete empty/ some-dir && rmdir empty

#remove leading/trailing spaces from a file (in place)
sed -i -e 's/^[ \t]*//' -e 's/[ \t]*$//' <file>

Replace text on commented lines
sed -n '/^\s*#/s/test/wow/p' blah.txt
Replace text, except on commented lines
sed -n '/^\s*#/!s/test/wow/p' blah.txt

#insert a file after a pattern
sed '/INCLUDE/ r foo.h' # insert foo.h after 'INCLUDE'

ls options:
--time-style=
full-iso
long-iso
iso
locale
+%H:%M:%S:%D

ls --format=across
# ls --format=comma
# ls --format=horizontal
# ls --format=long
# ls --format=single-column
# ls --format=verbose
# ls --format=vertical

ls --sort=extension
# ls --sort=size
# ls --sort=time
# ls --sort=version
# ls --sort=none

ip addr
route -n
/etc/network/interfaces
route add default gw 146.222.122.137

ls /sys/class/net/ to see network interfaces.

redirecting stdout and stderr:
&>word
>&word
the first one is preferred.
this is equivalent to >word 2>&1

#last reboot:
last reboot
#last shutdown entries:
last -x
last -x shutdown reboot

who -a or -b #show system boot info

ubuntu-drivers

#list file descriptors in kernel memory
sysctl fs.file-nr
#same as cat /proc/sys/fs/file-nr

#list max number of file descriptors
sysctl fs.file-max
#same as cat /proc/sys/fs/file-max

sysctl -a #show all values

#motd for ssh login
/var/run/motd.dynamic

because of the 3-way handshake, the kernel has two backlog queues for socket waiting for a connection:
listen syscall backlog parameter: the limit for the accept queue of incoming connections.
There are two queues: SYN queue and accept queue.
#1. when the server receives a SYN, the connection is in SYN-RECEIVED state, and it goes to the SYN queue.
#2. when the server receives a ACK, the connection is in ESTABLISHED state, and it goes to the accept queue.
#3. the application then has to call accept syscall to remove the connection from the accept queue.

net.core.somaxconn = 128
net.ipv4.tcp_max_syn_backlog = 512
somaxconn
1. Limit of socket listen() backlog,
2. limit for the accept queue
=================
tcp_max_syn_backlog
the limit for the SYN queue

#number of incoming connections backlog
net.core.netdev_max_backlog

netstat -ant | grep -c SYN_REC

tcp 3-way handshake
1. client send SYN to server (client in SYN-SENT state and server in SYN-RECEIVED state)
2. server send SYN-ACK to client
3. client send ACK to server (client and server in ESTABLISHED state)

calendar:
cal -y 2014
cal -3 #show prev, current, next months
cal -d 2014-07

envsubst: substitute environment variables
e.g:
echo "this is $HOME, wow" | envsubst
this is /home/heech, wow
"this is ${HOME}, wow" | envsubst
this is /home/heech, wow

#prevent ssh from asking you to add a host to known_hosts
#1: ssh-keyscan -H host >> ~/.ssh/known_hosts
#2: ssh -o StrictHostKeyChecking=no user@host  #ask for password
#3: change /etc/ssh/ssh_config:
Host *
   StrictHostKeyChecking no

nmcli dev
DEVICE  TYPE      STATE        CONNECTION
wlan0   wifi      connected    SCC_GUEST
eth1    ethernet  unavailable  --

nmcli dev show
GENERAL.DEVICE:                         wlan0
GENERAL.TYPE:                           wifi
GENERAL.HWADDR:                         00:26:C7:3A:5F:9C
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     SCC_GUEST
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/0
IP4.ADDRESS[1]:                         ip = 192.168.92.214/23, gw = 192.168.93.253
IP4.DNS[1]:                             209.244.0.3
IP4.DNS[2]:                             209.244.0.4
IP6.ADDRESS[1]:                         ip = fe80::226:c7ff:fe3a:5f9c/64, gw = ::

find out my screen resolution:
#1: xdpyinfo | grep dimensions
#2: xrandr

#change screen resolution
type xrandr to show available name for output and resolution:
++++++++++++++++++++
Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192
DIN disconnected (normal left inverted right x axis y axis)
DVI-0 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
   1920x1080      60.0*+
   1280x1024      75.0     60.0
   1152x864       75.0
   1024x768       75.1     60.0
   800x600        75.0     60.3
   640x480        75.0     60.0
   720x400        70.1
DVI-1 disconnected (normal left inverted right x axis y axis)
++++++++++++++++++++
change resolution:
xrandr --output DVI-0 --mode 1920x1080

#terminate the shell if no activity for 30 seconds
export TMOUT=30

#check if my machine is being pinged
tcpdump -ni eth2 icmp
#capture 2 packets and display packets n hex and ascii, write to a file, -tttt: print a timestamp
tcpdump -ni eth2 -c 2 -XX -w filename -tttt
# -n : do not resolve IP address, -X: display hex and ascii content, -S: show absolute sequence number
# -nn: do not resolve IP address or port number
# -XX: -X plus ethernet header
# -A : print in ascii only
tcpdump -nXS
# -D: show available interfaces
# -c : get x number of packets
# -s : show x bytes: -s 0 to show everything (default: 65535)
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v icmp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v tcp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v udp
#
tcpdump -nn -XX -i eth2 -v host <ip>
tcpdump -nn -XX -i eth2 -v src <ip>
tcpdump -nn -XX -i eth2 -v dst <ip>
tcpdump -nn -XX -i eth2 -v net 1.2.3.0/24
tcpdump -nn -XX -i eth2 -v port 3389
tcpdump -nn -XX -i eth2 -v src port 3389
tcpdump -nn -XX -i eth2 -v dst port 3389
tcpdump src port 1025 and tcp
tcpdump portrange 21-23
#only see packets below or above a certain size (in bytes)
tcpdump less 32
tcpdump greater 128
===
tcpdump -nnvvS src 10.5.2.3 and dst port 3389
===
tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'
=== common use
tcpdump -nnXv -i eth2 host 146.222.121.69
tcpdump -nnAv -i eth2 host 146.222.121.69
=====
tcpdump -nnvvvA -i eth2 -w file.pcap host <ip>
=======
tcpdump broadcast/tcp/udp/icmp

#related to ulimit
/etc/security/limits.conf

useful shortcuts for top command:
1 : show individual cpu
z : highlight running processes
c : show absolute path of process

run with an empty environment: env -i

port scanning:
nmap -sT -p- -Pn <hostname or IP>

=== systemd ====
systemctl list-unit-files --type=service #equivalent to ls /etc/systemd/system/*.service and /lib/systemd/system/*.service
systemctl start/stop/enable/disable/restart/status virtualbox
#systemctl enable/disable: Enables/disable a service to be started on bootup:
systemctl mask foo  #Prevent a service from starting dynamically or even manually unless unmasked:
systemctl is-enabled foo
=============
Run level 3 is emulated by multi-user.target. Run level 5 is emulated by
graphical.target. runlevel3.target is a symbolic link to multi-user.target and runlevel5.target is a
symbolic link to graphical.target.
#You can switch to 'runlevel 5' by running
systemctl isolate graphical.target
systemctl set-default <name of target>.target
systemctl get-default
systemctl status
systemctl --failed
systemctl list-units
==============
/etc/systemd , /etc/systemd/system
/lib/systemd , /lib/systemd/system
==============
journalctl: query the contents of systemd journal
example:
journalctl _COMM=crond --since "10:00" --until "11:00"
journalctl -u lpd.service
journalctl -k #like dmesg
timedatectl

xxd: make a hex dump

manipulate or dump object files: objcopy and objdump
objdump : display info from object file
nm: list symbols from object file

readlink: follow symbolic link
readlink -e `which google-chrome`
/opt/google/chrome/google-chrome

== virtual console
tty1 through 6 : there is a getty process
To access virtual console from X11: Ctrl-Alt-F1 thru F6
Once in virtual console, can use Alt-F1 throu 6 to switch. can also use alt-lefarrow and alt-rightarrow to cycle

X11 is running on tty7

do it from a command line: chvt 1
== virtual console

keyboard related programs:
loadkeys
showkey

download a full website:
wget --random-wait -r -p -e robots=off -U mozilla www.example.com

pmap: show memory map of a process
/proc/[pid]/statm:
  field #1: size, mapped to VIRT
  field #2: resident, mapped to RES
  field #3: share, mapped to SHR
  field #4: text, mapped to CODE
  field #5: lib , always 0
  field #6: data, mapped to DATA
  field #7: dt, always 0
/proc/[pid]/maps -> similar to output of pmap
/proc/[pid]/smaps
/proc/[pid]/status
/proc/[pid]/task/[threadid] #tgid is process id, pid is thread id
/proc/[pid]/comm : show program name
/proc/meminfo
smem program

#add new repo
#1: add key: apt-key add <key>
#2: add a file to /etc/apt/sources.list.d, call it something like docker.list

ps f : show process hierarchy
ps a : show processes owned by others
ps x : those without tty
ps u : user-friendly format
ps -L : show threads (LWP (lightweight process column))
ps -fHU <username> : show processes of username in hierarchical form
ps -L -o tid,pid,ppid,state,euid,egid,sid,pgid,tpgid,command <pid>

#show top processes sorted by memory usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem
#show top processes sorted by cpu usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu

7z a -mhe=on -ppassword important.7z important.txt for-honey.txt

check battery:
upower -i /org/freedesktop/UPower/devices/battery_BAT0 # deprecated supposedly
OR
cat /sys/class/power_supply/BAT0/uevent

#take every 10th line from the file
awk '!(NR % 10)' test.txt

#find working directory of a running process
#1. pwdx <pid1> <pid2>
#2. lsof -p <pid> | grep cwd
#3. readlink -e /proc/<pid>/cwd

pv program: show progress of task

pkg-config: manage compile and link flags for libraries (intended to work with automake and autoconf.)
provide the necessary details for compiling and linking a program to a library.

#convert doc to various format
$ pandoc -t plain README.md
-f : specify input format
-t : specify output format
-o : write to a file

#write a tab literal in Bash command line
$'\t'

#bash: create a string literal
$'..' : create a string with backslash-escaped characters.
example: $'\n\t'

$ ls -d .*
all files/directories that start with ., include . and ..
$ ls -d .[^.]*
all files/directories that start with ., exclude . and ..

---
autotools:
autogen.sh -> generate configure script
configure -> create a makefile

printer stuff:
system-config-printer
lpstat -d
======
#don't do remote admin
cupsctl --remote-admin # update /etc/cups/cupsd.conf
===========
localhost:631 #cups admin
===========
check printing error:
/var/log/cups/error_log


UML: user mode linux
#1: create a .config file
1a. this is better
make ARCH=um defconfig
1b. may not work
make ARCH=um allnoconfig KCONFIG_ALLCONFIG=mini.config
#2: build it
make ARCH=um
#3: run it
./kernel ubda=Slamd64-12.1-root_fs mem=512m
#show config
./kernel --showconfig
====
linux kernel:
#takes current config (.config) and update it based on new kernel release
make oldconfig/silentoldconfig

verifying linux kernel signature:
$ xzcat linux-4.4.tar.xz | gpg --verify linux-4.4.tar.sign -
gpg: Signature made Sun 10 Jan 2016 03:09:18 PM PST using RSA key ID 00411886
gpg: Can't check signature: public key not found
$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 00411886
gpg: requesting key 00411886 from hkp server keys.gnupg.net
gpg: keyserver timed out
gpg: keyserver receive failed: keyserver error

passing an environment to a process (one-off):
$ VAR=value ./test.sh
#note cannot do ./test.sh VAR=HI

#scan a port
nmap -p6000 localhost
#version scan
nmap -p7474 -sV localhost
#check web server in use
nmap -p80 -sV www.google.com
#TCP SYN scan
nmap -p7474 -sS localhost
#
nmap -oA #output in 3 major formats
#OS detection
nmap -O <host>
#output scan in normal
nmap -oN <file>
#output scan in XML format
nmap -oX scandata.xml rigel

#make your script more robust
set -euo pipefail

#check dirty pages in page cache
$ cat /proc/meminfo | grep Dirty
Dirty:               204 kB
#flush system buffers
$ sync


As of 2.4 kernel, these two caches (page and buffer caches) have been combined. Today, there is only
one cache, the Page Cache
---
Buffers are in-memory block I/O buffers. They are relatively short-lived. Prior to Linux
kernel version 2.4, Linux had separate page and buffer caches. Since 2.4, the page and
buffer cache are unified and Buffers is raw disk blocks not represented in the page
cache—i.e., not file data. The Buffers metric is thus of minimal importance.


#I/O scheduler
cat /sys/block/sda/queue/scheduler
--> noop [deadline] cfq
CFQ : Completely Fair Queuing

#ulimit:
/etc/security/limits.conf

#run stress test
siege --log=siege.log -t5M -c 4 -i -b -f url.txt

tmux: from 2 horizontal panes to 2 vertical panes (and vice versa)
Prefix <SPC> : cycle through available layouts (bound to next-layout)
Prefix Alt-1 : even horizontal
Prefix Alt-2 : even vertical

ssh X11 forwarding
want to display on my-machine (where X server is running)
remote (where client will be run)

On my-machine: ssh -X user@remote

#check for CRLF ending:
$ file /a/tapasjo/copy-paste.txt
/a/tapasjo/copy-paste.txt: ASCII text, with CRLF line terminators
---
$ grep -c  $'\r' /a/tapasjo/copy-paste.txt
27

braces:
trimming with variable substition:
$ var=foo.pdf
$ echo ${var%.pdf} #trim suffix
foo
$ echo ${var#foo} #trim prefix
.pdf
====
#parameter substitution:
IP=1.2.3.4
echo ${IP/./ }
1 2.3.4
echo ${IP//./ }
1 2 3 4
#an extra / means global substitution
====
$ echo {00..8..2}
00 02 04 06 08
$ echo {00..8}
00 01 02 03 04 05 06 07 08
$ echo {D..T..4}
D H L P T

single bracket vs double bracket
single: POSIX
double: non-POSIX, only in bash, zsh, ksh
[ is a shell builtin and a program (/usr/bin/[
[[ is a keyword

profiling java program with perf:
#1. profiling: generate a file called perf.data
sudo perf record -F 99 -a -g sleep 30
OR
sudo perf record -F 99 -a -g -p PID sleep 30
#2. create method mappings : create a file called /tmp/perf-pid.map
    this file is used to translate memory address into function and variable names (used by perf report/script)
/home/heech/gitrepo/perf-map-agent/bin/create-java-perf-map.sh <pid>
#3. generate flame graph (need perf.data in current directory)
sudo perf script | ~/gitrepo/FlameGraph/stackcollapse-perf.pl | ~/gitrepo/FlameGraph/flamegraph.pl --color=java --hash > flamegraph.svg
# text report
sudo perf report --stdio
#ncurses window
sudo perf report
#list raw event
sudo script
===
#cpu counter stats
perf stat -a sleep 10

Ctrl-x, Ctrl-e : will bring up an $EDITOR containing whatever is currently entered into the prompt.
  "\C-x\C-e": edit-and-execute-command
Ctrl-Alt-e to expand any placeholders/variables in the current line.
  "\e\C-e": shell-expand-line

echo ~- # echo previous directory

#capture output of command into clipboard
"do stuff" | xsel -ib

kernel version numbering
example: 4.2.0-34
4: kernel version
2: major revision of the kernel version
0: minor revision of the kernel. It is only changed when new features or new drivers are added.
34: The fourth number represents corrections, such as security patches and bug (i.e., error) fixes

#show kernel drivers handling each device and also kernel modules capable of handling it.
lspci -kv
#check graphic driver
lspci -k |grep -iA2 vga

if the system hangs:
Hold down the ‘alt’ and ‘sysrq’ keys on your keyboard and whilst they are held down type the following slowly:
REISUB

#get SATA/IDE device info
hdparm /dev/sda

badblocks : search a device for bad blocks
readelf: display info about ELF files

procfs: originally intended to expose process info, then became a big mess
sysfs: expose kernel info

kernel diff and patch:
#1 generate patch
diff -Naur -X linux-2.6.19/Documentation/dontdiff linux-2.6.19/ linux-2.6.19-dirty/ > my_patch
#2 apply patch
cd linux-2.6.19; patch -p1 < ../patch-2.6.20
# -p1 tells the patch command to skip 1 leading slashes from the filenames present in the patch file.

===========================
creating and applying patches:
diff -u hello.c hello_new.c > hello.patch
patch < hello.patch
patch -b < hello.patch #take a backup before applying patches
patch --dry-run < hello.patch #dry run
patch -R < hello.patch #reverse a patch

kernel entry point:
arch/x86/boot/header.S -> calll main

loop device is a pseudo ("fake") device (actually just a file) that acts as a block-based device. a file that contains a filesystem
loop device is a pseudo device that makes a file look like a block device. (command: losetup /dev/loop0 <filename>)

========= loop device =========
dd if=/dev/zero of=file.img bs=1k count=10000
losetup /dev/loop0 file.img
mkfs.ext4 -c /dev/loop0 10000
mount -t ext4 /dev/loop0 /mnt/point1
========= loop device =========

#system-wide limit on open file descriptors
cat /proc/sys/fs/file-max
#change limit:
/etc/security/limits.conf
/etc/sysctl.conf

from setrlimit (ulimit is a wrapper around setrlimit):
===
The soft limit is the value that the kernel enforces for the corresponding resource.  The hard limit
acts as a ceiling for the soft limit: an unprivileged process may set only its soft limit to a value
in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A privileged
process (under Linux: one with the CAP_SYS_RESOURCE capability) may make arbitrary changes to either
limit value.

#time zone: display time
$ TZ="America/New_York" date
Tue Apr 19 10:51:17 EDT 2016
#time zone files: /usr/share/zoneinfo/

cat /etc/os-release

linux kernel startup:
#kernel entry point:
arch/x86/boot/header.S
#next
arch/x86/boot/main.c
#next
arch/x86/boot/pm.c
#next
arch/x86/boot/pmjump.S
#next entry point:
arch/x86/kernel/head_64.S
#next
arch/x86/kernel/head64.c -> x86_64_start_kernel() ->
#next
init/main.c -> start_kernel() -> rest_init() -> kernel_init()
                                             -> kernel/sched/idle.c: cpu_startup_entry() -> cpu_idle_loop()
kernel init:

#dump info file system and look at superblock
dumpe2fs /dev/sda6 | grep -i superblock

superblock is essentially file system metadata and defines the file system type, size, status, and
information about other metadata structures (metadata of metadata).
metadata about filesystem.
====
An inode exists in, or on, a file system and represents metadata about a file.
====
dentry (directory entry)
what the Linux kernel uses to keep track of the hierarchy of files in directories. Each dentry maps
an inode number to a file name and a parent directory.

#documentation in linux source: Documentation/sysctl/vm.txt
To free pagecache:
echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
echo 3 > /proc/sys/vm/drop_caches

#manipulate the real-time attributes of a process : chrt
#set or retrieve a process's CPU affinity : taskset

hardware interrupts:
/proc/interrupts:
first column: interrupt #
second column: how many times the CPU core has been interrupted
#from /proc/interrupts : i8042 is the keyboard controller
i8042 controller controls PS/2 keyboards and mice in PCs
smaller IRQ number means higher priority
=====
software interrupts: /proc/softirqs

/proc/stat : show interrupt count

/sys/devices/system/cpu

system performance tools:
mpstat
sar
iostat
pidstat
sadf
cifsiostat

interrupt CPU affinity value:
/proc/irq/<irq#>/smp_affinity  #this is a mask
/proc/irq/<irq#>/smp_affinity_list #this is the cpu number

showkey #show linux key code
xev #show X11 key code

block device: data move in blocks. support buffering and random access. accessed randomly
sector: smallest addressable unit on a block device. a physical property of the device,
  the smallest unit of transfer for the device.
block: smallest addressable unit in a filesystem, smallest unit of transfer for a block device driver.
block size must be a power of two and cannot be larger than a page frame. must be a multiple
of the sector size.
each block requires its own buffer, which is a region of RAM used by the kernel to store
the block's content.
============
character device: data is streamed character by character. accessed as a stream of data.

linux has two disk caches: buffer cache and page cache
buffer cache and page cache have been combined.

/proc/filesystems

software interrupt (SoftIRQ)
processes: ksoftirqd/0 , etc
software interrupts are kernel routines that are scheduled to run at a time when other
tasks will not be interrupted.

When a NIC receives incoming data, it copies the data into kernel buffers using DMA.
The NIC notifies the kernel by means of a hardware interrupt. These interrupts do minimal
work as they have already interruptted another task and cannot be interruptted themselves.
Software interrupts then drain the network adapter receive ring buffers.
protocol handlers then process the data. finally, data is delivered to a socket
buffer where an application can call the receive function.

networking info:
/proc/net/dev
/proc/net/tcp
/proc/net/unix
/proc/net/snmp

networking tools:
dropwatch
ip
ethtool

load: # of processes using or waiting for the CPU.
load average: the load averaged over 1,5,15 minutes
/proc/loadavg

parted /dev/sda print

net: Tool for administration of Samba and remote CIFS servers.
mtr: a network diagnostic tool
iptables: firewall
mrtg - multi router traffic grapher

load balancing tool: pen, pound, balance

snort - flexible Network Intrusion Detection System

============
monitor SMART disk: smartctl and smartd
smartctl -i /dev/sda #info
smartctl -a /dev/sda #all info
smartctl -x /dev/sda #even more info
smartctl -H /dev/sda #health info
smartctl -l selftest /dev/sda

#available test: offline, short, long, conveyance
smartctl -a:
Pre-fail: if the VALUE column is below the THRESH column, be concerned

#run test
smartctl -t short /dev/sda
smartctl -t long /dev/sda

#abort test
smartctl -X

#show capability:
smartctl -c /dev/sda
===================

rootkit: a software package that enables an unauthorized user to obtain
root privileges

#find processes using files/sockets
fuser -v -m <filesystem> #filesystem can be specified as directory name or /dev/sda1
OR:
lsof /dev/sdc1

gpart: guess partition table. used for recovery

gddrescue: clone bad disk
partimage: clone disks, does not support ext4, don't use
fsarchiver: support ext4, use this instead of partimage

lost+found: store files whose actual locations cannot be determined
during a filesystem consistency check.
details:
fsck might find data that looks like a complete file but doesn't have a name on the system — an
inode with no corresponding file name. This data is still using up space, but it isn't accessible by
any normal means.

recover deleted files:
unmount the partition (go to single user mode if necessary)
need to know what you're looking for, do a grep on the device:
grep -a -B10 -A100 -i <pattern> /dev/sda2 > file.out
#-a: treat the device as a series of ascii char

shred: overwrite a file with random data, can be used on devices too:
shred -n 3 -vz /dev/sda

autopsy - graphical interface to SleuthKit
sleuthkit - tools for forensics analysis on volume and filesystem data

#burn cd/dvd
growisofs (preferred?)
example: growisofs -dvd-compat -Z /dev/sr0=isoimage.iso
wodim

#mounting an ISO image
mount -t iso9660 -o ro,loop /path/to/file.iso /mount-point

isosize : show the size of an iso9660 filesystem

mountpoint: check whether a directory is a mount point

extended attributes are name/value pairs associated with a file. a form of metadata
need to configure kernel: FS_XATTR
need to configure fstab
applications: attr, getfattr, setfattr

/etc/default/console-setup
#change console font:
dpkg-reconfigure console-setup #this will change /etc/default/console-setup
then run setupcon in virtual console
the fonts are in: /usr/share/consolefonts/
setfont Uni2-TerminusBold24x12
in /etc/default/console-setup:
FONTFACE="TerminusBold"
FONTSIZE="12x24"
=============
The font size is specified by 2 numbers in pixels represented as HEIGHT x WIDTH. If the width is 8
pixels, then only the height is specified. For comparison purposes, the default console font size is
16 (that is, 16 x 8).

tune2fs : adjust filesystem parameters
#list content of superblock, etc
tune2fs -l /dev/sda6
#set label
tune2fs -L <label> /dev/sda6
#similar to
dumpe2fs -h /dev/sda6
=====
tune2fs:  -m reserved-blocks-percentage (defaul: 5)
#reduces the reserved area to 2% of the filesystem, which may be more
tune2fs -m 2 /dev/sda1
#sets the filesystem to have no reserved blocks,
tune2fs -r 0 /dev/sda1

partprobe - inform the OS of partition table changes

DRM (direct rendering manager): a subsystem of the kernel responsible for
interfacing with GPU of video cards.
each GPU is a DRM device: /dev/dri/card0
DRM interface with GPU and graphics RAM
KMS interface with display controller, which interface with monitor screen

linux framebuffer: fbdev , /dev/fb0
allow access to graphics hardware through an API
The Linux framebuffer (fbdev) is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console.

Text mode is a computer display mode in which content is internally represented on a computer screen
in terms of characters rather than individual pixels.

restart X server:
#1: crude: kill -USR2 <pid of x server>
#2: better: systemctl restart lightdm

#length of command line

The limit for the length of a command line is not imposed by the shell, but by the operating
system. POSIX denotes this limit ARG_MAX and on POSIX conformant systems you can query it with
$ getconf ARG_MAX
====
According to POSIX: http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
Maximum length of argument to the exec functions. This means: Without calling exec, there is no
ARG_MAX limitation. So it would explain why shell builtins are not restricted by ARG_MAX.

===== curl post with file =====
curl -F "data=@post.data"
the string looks like this:
--------------------------73e6530ff229c469
Content-Disposition: form-data; name="data"; filename="post.data"
Content-Type: application/octet-stream

{"rels": [{"from_vsid": "KTX1-OBU-099-South-HKG01-1", "to_vsid": "PHKG-7JY-057-North-GUX02-1", "rel_type": "TERMINALTRANSFERLEG_HOT"}]}

--------------------------73e6530ff229c469--
===========================

kvm daemon: libvirt-bin, libvirt-guests
== need to do this:
sudo systemctl start libvirt-bin
kvm-ok #sanity check
virsh -c qemu:///system list
OR
virsh -c qemu:///system list --all
OR
virsh list
===
location of kvm images: /var/lib/libvirt/images

bind mount: remount part of a file hierarchy elsewhere: mount --bind olddir newdir
after this, the same contents are available in two places.
===
if there are mount points under olddir, their contents are not visible under newdir unless use --rbind
use mount --rbind olddir newdir #replicate mount points under olddir
=== BEST:
A bind mount is an alternate view of a directory tree.
bind mount provides a view of a directory tree at a different location.
====
Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead
takes an existing directory tree and replicates it under a different point. The directories and
files in the bind mount are the same as the original. Any modification on one side is immediately
reflected on the other side, since the two views show the same data.
=========
The alternative (classic) way to create a read-only bind mount is to use remount operation, for example:
mount --bind olddir newdir
mount -o remount,ro,bind olddir newdir
========================
when you mount a filesystem on a directory, this hides what is behind the directory. The files
in the directory become inaccessible until the directory is unmounted.
========
filesystem: a collection of files and directories in a hierarchy.
mounting: adding a filesystem to the global namespace of files and directories

Filesystem in Userspace (FUSE) is a software interface for Unix-like computer operating systems that
lets non-privileged users create their own file systems without editing kernel code. This is
achieved by running file system code in user space while the FUSE module provides only a "bridge" to
the actual kernel interfaces.

espeak : software speech synthesizer

segments of a program:
text segment: contain the executable code and read-only data
initialized data segment: contain initialized data
uninitialized data segment (bss): contain uninitialized data
stack segment

connect android to usb port: use MTP
mount point: /run/user/<userid>/gvfs

demand load executables: only those parts of a program required for execution are loaded into memory.
when a new process is created using fork(), memory is not requested, but instead the memory
for the parent process is used jointly by both processes. if the new process accesses part of the
memory in write mode, this section is copied before being modified: copy-on-write

/dev/mem is a character device file that is an image of the main memory of the computer.

blockdev --getss #sector size
blockdev --getbsz #block size

TZ=UTC date # get a date in UTC
#convert epoch second to a date in UTC
TZ=UTC date --date=@1452832200
#convert epoch second to a date in UTC (ISO format)
TZ=UTC date --date=@1452832200 +%Y-%m-%dT%H:%M:%S.000Z
output: 2016-01-15T04:30:00.000Z
#convert date to epoch second
TZ=UTC date --date="2015-08-31 13:30:15" +%s

getconf PAGESIZE #get page size

pcmanfm --desktop-pref

setxkbmap: set keyboard using X extension

lxpanelctl : (menu/run/config/restart)

scrot -cu -d 5

gnome-system-monitor


There are three different kinds of buffering strategies:
Characters written to or read from an unbuffered stream are transmitted individually to or from the file as soon as possible.
Characters written to a line buffered stream are transmitted to the file in blocks when a newline character is encountered.
Characters written to or read from a fully buffered stream are transmitted to or from the file in blocks of arbitrary size.
===
Newly opened streams are normally fully buffered, with one exception: a stream connected to an
interactive device such as a terminal is initially line buffered.
===
The use of line buffering for interactive devices implies that output messages ending in a newline
will appear immediately—which is usually what you want. Output that doesn’t end in a newline might
or might not show up immediately, so if you want them to appear immediately, you should flush
buffered output explicitly with fflush.
===
stdin : always buffered
stderr: always unbuffered
stdout: if terminal, then line-buffered, else unbuffered

stdbuf: modify buffering operations for streams
example: tail -f file | cut -d ' ' -f1 | uniq
nothing because the output of cut is buffered

tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq
#use stdbuf -o0 if the data is not line-oriented
this will disable output buffering for the cut program

logical volume: a filesystem that appears to be a single physical volume,
but is actually assembled from space that has been allocated on multiple
physical partitions.

linux process and thread=======
process descriptor: struct task_struct
	pid_t pid; // this is the thread id
	pid_t tgid; // this is the process id

when a new process is created, it appears as a thread where both the PID and TGID are the same (new)
number.
When a thread starts another thread, that started thread gets its own PID (so the scheduler can
schedule it independently) but it inherits the TGID from the original thread.
====
getpid() returns tgid
gettid() returns pid
==========================

bash testing:
[ "$VAR" ] is equivalent to [ -n "$VAR" ] # true if not empty

power management tool: tlp, powertop

cpufrequtils (package): cpufreq-info command

core dump setting:
ulimit -c
cat /proc/sys/kernel/core_pattern

useful commands from moreutils:
combine, errno, ifdata, isutf8, sponge, ts, vidir, vipe, zrun

nice -n 19 <program>
renice -n 19 <pid>
ionice -c 3 cp bigfile.mp4 backup.mp4

take a screen shot of a video at 5:12 into the video
mplayer -vo png -ss 5:12 -frames 1 my-video.mp4

hide your processes from other users:
after this command, only my processes are under /proc
$ mount -o remount /proc -o hidepid=2

get location of IP address
curl ipinfo.io/216.58.192.4

mplayer -vo aa MovieName.avi #black and white
mplayer -vo caca MovieName.avi #color
====
exif image_name.jpg
====
mp3info music_file.mp3
====
convert original.jpg -resize 50% -quality 95 smaller.jpg #shrink by 50%
convert original.jpg -resize 200% -quality 95 bigger.jpg #enlarge
convert ships.jpg -rotate 30 tilt-ships.jpg #rotate
convert ships.jpg -background none -rotate 90 turn-ships.jpg #rotate
== make a banner
convert -background white -fill blue -font Courier -pointsize 32 label:'Happy Birthday' banner.jpg
== read text from a file
convert -background white -fill black -font Courier -pointsize 12 label:@message.txt banner.gif

record your desktop session (video)
# -s : resolution, alternative: -s 1024x768
ffmpeg -f x11grab -s wxga -r 25 -i :0.0 -sameq ~/my_video.mpg
## cut video
ffmpeg -i in.mp4 -ss [start] -t [duration] -c copy out.mp4
OR
ffmpeg -i in.mp4 -ss [start] -to [stop] -c copy out.mp4

# print sensors info
sensors

cgroups (control groups): allow you to set limits on resources for processes and their children.

mount namespace: make it look like you have the entire filesystem namespace
UTS (unix time sharing) namespace: make it look like you have your own hostname and domain name.
IPC namespace: you have your own message queues
PID namespace: you have your own process ID
network namespace: you have your own network devices
user namespace: you have your own user id

apparmor: kernel enhancement to confine programs to a limited set of resources
program: apparmor_status

#show networking info
networkctl list
network-admin

iwconfig : configure wireless network interface

chvt # change virtual console, has to run inside text-based virtual console

#capture screenshot
import -display :0.0 -window root sshot1.png

alias dos2unix='recode dos/CR-LF..l1'
alias unix2dos='recode l1..dos/CR-LF'
alias unix2win='recode l1..windows-1250'

#turn off ping replies
sysctl -w net.ipv4.icmp_echo_ignore_all=1
#slow down ping reply rate
sysctl -w net.ipv4.icmp_echoreply_rate=10

#lxterminal icons
/usr/share/icons/Lubuntu/apps/22/lxterminal.svg
/usr/share/icons/Lubuntu/apps/48/lxterminal.svg
/usr/share/icons/Lubuntu/apps/16/lxterminal.svg
/usr/share/icons/Lubuntu/apps/24/lxterminal.svg

#silence the beep
setterm -blength 0

By default, Linux uses the atime option on a disk mount, which means it writes a timestamp (e.g. a
write to the drive) every time it reads anything. So in this case, reads cause writes – and also
disk seeks, because a read from a file will then trigger having to write to the directory that
contains the file. This even occurs if a file is read from the file system’s page cache (reading
from the machine’s memory rather than the drive).
====
you can use the relatime option instead, which only writes a timestamp
when a file or directory is written to.
==
as of kernel 2.6.30, relatime is the default

#temporary filesystem
mkdir /ramdisk
mount none -t tmpfs -o size=256M /ramdisk
