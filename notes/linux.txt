ldd : print shared library dependencies

=====
boot-up:

run scripts at startup : put in /etc/rc.local
others:
/etc/init.d/rcS
run scripts in /etc/rc2.d, which links to /etc/init.d

create init-style startup script:
update-rc.d <name> defaults

read /etc/rc2.d/README

default runlevel in /etc/init/rc-sysinit.conf

#start service at boot-up:
update-rc.d SERVICENAME defaults

#remove service from start at boot-up
update-rc.d -f service_name remove

===================================
#ways to manage upstart/init job

upstart jobs are in /etc/init
initctl list : list upstart job

#1:
#start/stop upstart job
start/stop/status docker #as root

#2:
#service
service --status-all
service docker stop/start/restart

#3:
/etc/init.d/docker start/stop/status

#4:
invoke-rc.d docker status

==================================

/etc/init/ttyN.conf : start a getty process for ttyN
stop tty6 : stop tty6

/etc/init/control-alt-delete.conf; define behavior for ctrl-alt-del

/var/log : lots of logs
/var/lib
/var/spool
/usr/share

/var/log/syslog
/var/log/auth.log #sudo log
/var/log/Xorg.0.log
/var/log/apport.log
/var/log/kern.log
/var/log/wtmp
/var/log/pm-powersave.log
/var/log/gpu-manager.log
/var/log/boot.log
/var/log/dmesg
/var/log/udev
/var/log/dpkg.log
/var/log/alternatives.log
/var/log/upstart/
/var/log/lightdm/

dig: DNS lookup utility
#reverse lookup
dig +short -x <ip addr>
====
another DNS utility: drill
drill www.google.com
drill www.google.com @8.8.8.8

file copy tool: rsync

lsmod: list kernel module
modinfo: display module info
modules are in /lib/modules/
rmmod: remove modules
modprobe: add or remove modules
systool -v -m module_name #list options set for a loaded module
modprobe -c : show config
modprobe --show-depends module_name

--cron change
move popularity-contest from /etc/cron.daily to ~root/cron
move bsdmainutils from /etc/cron.daily to ~root/cron
move mlocate from /etc/cron.daily to /etc/cron.monthly
move locate from /etc/cron.daily to /etc/cron.monthly

--cron change 2015-01-16
change /etc/cron.daily/locate:
 add "/C /D /Data" to PRUNEPATHS
 add vboxsf to PRUNEFS

/etc/updatedb.conf:
   add /C to prunepaths
   add vboxsf to prunefs
DB: /var/lib/mlocate/mlocate.db

consider disabling mlocate cron job

anacron: for desktops and laptops that are not running 24/7
/var/spool/anacron
/etc/anacrontab

run-parts --report /etc/cron.daily

ufw - program for managing a netfilter firewall
ufw allow 22

sudo visudo #change /etc/sudoers file:
#allow user cheok to run docker without being prompted for the password
#sudo only ask for password per xterm session
added this line:
cheok ALL=(ALL) NOPASSWD: /usr/bin/docker

#swappiness
#the smaller the number, the less aggressive linux will swap
cat /proc/sys/vm/swappiness

/etc/sysctl.conf

iftop : display bandwidth usage on an interface by host
whois : client for the whois directory service

font cache commands:
fc-cache
fc-cat
fc-list
fc-match
fc-pattern
fc-query
fc-scan
fc-validate

fc : shell builtin that display and edits command
help fc : help is a shell builtin

#show distro info : LSB: linux standard base
--> lsb_release -a
output:
Distributor ID: Ubuntu
Description:    Ubuntu 14.10
Release:        14.10
Codename:       utopic

/etc/os-release

partprobe: inform the OS of partition table changes

commands:
lsattr
lsblk
lsb_release
lscpu
lsdiff
lshw
lsinitramfs
lslocks
lsmod
lsnrctl
lsof
lspci
lspcmcia
lspgpot
lsusb

initramfs: initial RAM-based filesystem: allow the kernel to execute programs before the root filesystem is mounted.
initrd: initial RAM disk: serves as a temporary root file system in RAM and allows the kernel to boot without
having to mount any physical disk.

GRUB config:
make a copy of /etc/default/grub and /boot/grub/grub.cfg
1. change /etc/default/grub
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
GRUB_GFXMODE=640x480
#supported resolution?: 640×480, 800×600, 1024×768, 1280×1024, 1600×1200
GRUB_CMDLINE_LINUX : Entries on this line are added to the end of the 'linux' command line (GRUB
legacy's "kernel" line) for both normal and recovery modes. It is used to pass options to the
kernel.
2. run update-grub , this will change /boot/grub/grub.cfg
output of update-grub:
Found linux image: /boot/vmlinuz-3.16.0-30-generic
Found initrd image: /boot/initrd.img-3.16.0-30-generic
Found linux image: /boot/vmlinuz-3.16.0-23-generic
Found initrd image: /boot/initrd.img-3.16.0-23-generic
Found memtest86+ image: /boot/memtest86+.elf
Found memtest86+ image: /boot/memtest86+.bin
Found Windows 7 (loader) on /dev/sda2
===================================================
grub images: /usr/lib/grub/i386-pc

gfxmode:

If this variable is set, it sets the resolution used on the ‘gfxterm’ graphical terminal. Note that
you can only use modes which your graphics card supports via VESA BIOS Extensions (VBE), The default
is ‘auto’, which selects a platform-specific default that should look reasonable.
====
The resolution may be specified as a sequence of one or more modes, separated by commas (‘,’) or
semicolons (‘;’); each will be tried in turn until one is found. Each mode should be either ‘auto’,
‘widthxheight’, or ‘widthxheightxdepth’.

gfxpayload:

If this variable is set, it controls the video mode in which the Linux kernel starts up, replacing
the ‘vga=’ boot option. It may be set to ‘text’ to force the Linux kernel to boot in normal text
mode, ‘keep’ to preserve the graphics mode set using ‘gfxmode’, or any of the permitted values for
‘gfxmode’ to set a particular graphics mode (see gfxmode).

----------------------------------------------

uninstall a kernel image: apt-get remove linux-image-4.2.0-30-generic

/tmp cleanup, happen on reboot:
/etc/init/mounted-tmp.conf , which uses /etc/default/rcS , use TMPTIME var

#printf builtin (in bash):
$ printf "%d" "'a"
97
$ printf "%x" "'a"
61
'a -> convert a to its ascii code

need cifs-utils to access windows server, then do: sudo mount -t cifs -o username=heech //snt2/isdc ~/j

#add shared library path
option 1:
LD_LIBRARY_PATH is an environment variable you set to give the run-time shared library loader (ld.so) an extra set of directories to look for when searching for shared libraries
example: LD_LIBRARY_PATH=~/instantclient_11_2 python3
option 2:
 create a file under /etc/ld.so.conf.d/, then run ldconfig

##print shared libraries dependencies: ldd command

need instantclient-basic-linux.x64-11.2.0.3.0.zip instantclient-sdk-linux.x64-11.2.0.3.0.zip

add include and library path gcc:
C_INCLUDE_PATH=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 pip3 install --user cx_Oracle

special case (for npm oracledb only):
OCI_INC_DIR=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 npm install oracledb

#stop this message (when running evince): Couldn't connect to accessibility bus: Failed to connect to socket /tmp/dbus-sCAvokkUFt: Connection refused
export NO_AT_BRIDGE=1

rsync -avP userid@host:/path/to/file .
also: -z for compress
-P : preserve partially copied files, you can pick up where you left off
gotchas:
#1 Copy entire directory to remote parent directory:
rsync /path/without/slash host:/path/to/parent/with/slash/
------
#1a. dest does not exist
eg. rsync -av max tmp # same as rsync -av max tmp/
result: tmp is created and max is under tmp: tmp/max
diff -r max tmp/max #identical
#1b. dest exists
eg. rsync -av max tmp # same as rsync -av max tmp/
result: max is under tmp: tmp/max
diff -r max tmp/max #identical
---
#2 Copy contents of one directory to another:
rsync -r /path/to/directory/* host:/path/to/directory/
----
#2a. dest does not or does exist (dest dir is created if necessary)
eg rsync -av max/* tmp/ # same as rsync -av max/* tmp
diff -r max tmp #identical
----------
#3 Copy a directory into a new directory on another host:
rsync /path/without/slash host:/path/to/new/directory
#4 rsync file dirname #copy file to dirname/file
#5 rsync file dirname/filename #copy file to dirname/filename
#6 rsync file dirname/ #copy file to dirname/file, creating dirname if necessary

#cp
#1: dest is a directory -> make a copy with the same name in directory
#2: dest is not a directory -> make a copy with the specified path name.

#fast way to delete large number of files
mkdir empty && rsync -r --delete empty/ some-dir && rmdir empty

#remove leading/trailing spaces from a file (in place)
sed -i -e 's/^[ \t]*//' -e 's/[ \t]*$//' <file>

Replace text on commented lines
sed -n '/^\s*#/s/test/wow/p' blah.txt
Replace text, except on commented lines
sed -n '/^\s*#/!s/test/wow/p' blah.txt

#insert a file after a pattern
sed '/INCLUDE/ r foo.h' # insert foo.h after 'INCLUDE'

ls options:
--time-style=
full-iso
long-iso
iso
locale
+%H:%M:%S:%D

ls --format=across
# ls --format=comma
# ls --format=horizontal
# ls --format=long
# ls --format=single-column
# ls --format=verbose
# ls --format=vertical

ls --sort=extension
# ls --sort=size
# ls --sort=time
# ls --sort=version
# ls --sort=none

ip addr
route -n
/etc/network/interfaces
route add default gw 146.222.122.137

ls /sys/class/net/ to see network interfaces.

redirecting stdout and stderr:
&>word
>&word
the first one is preferred.
this is equivalent to >word 2>&1

#last reboot:
last reboot
#last shutdown entries:
last -x
last -x shutdown reboot

who -a or -b #show system boot info

ubuntu-drivers

#list file descriptors in kernel memory
sysctl fs.file-nr
#same as cat /proc/sys/fs/file-nr

#list max number of file descriptors
sysctl fs.file-max
#same as cat /proc/sys/fs/file-max

sysctl -a #show all values

#motd for ssh login
/var/run/motd.dynamic

because of the 3-way handshake, the kernel has two backlog queues for socket waiting for a connection:
listen syscall backlog parameter: the limit for the accept queue of incoming connections.
There are two queues: SYN queue and accept queue.
#1. when the server receives a SYN, the connection is in SYN-RECEIVED state, and it goes to the SYN queue.
#2. when the server receives a ACK, the connection is in ESTABLISHED state, and it goes to the accept queue.
#3. the application then has to call accept syscall to remove the connection from the accept queue.

net.core.somaxconn = 128
net.ipv4.tcp_max_syn_backlog = 512
somaxconn
1. Limit of socket listen() backlog,
2. limit for the accept queue
=================
tcp_max_syn_backlog
the limit for the SYN queue

#number of incoming connections backlog
net.core.netdev_max_backlog

netstat -ant | grep -c SYN_REC

tcp 3-way handshake
1. client send SYN to server (client in SYN-SENT state and server in SYN-RECEIVED state)
2. server send SYN-ACK to client
3. client send ACK to server (client and server in ESTABLISHED state)

calendar:
cal -y 2014
cal -3 #show prev, current, next months
cal -d 2014-07

envsubst: substitute environment variables
e.g:
echo "this is $HOME, wow" | envsubst
this is /home/heech, wow
"this is ${HOME}, wow" | envsubst
this is /home/heech, wow

#prevent ssh from asking you to add a host to known_hosts
#1: ssh-keyscan -H host >> ~/.ssh/known_hosts
#2: ssh -o StrictHostKeyChecking=no user@host  #ask for password
#3: change /etc/ssh/ssh_config:
Host *
   StrictHostKeyChecking no

nmcli dev
DEVICE  TYPE      STATE        CONNECTION
wlan0   wifi      connected    SCC_GUEST
eth1    ethernet  unavailable  --

nmcli dev show
GENERAL.DEVICE:                         wlan0
GENERAL.TYPE:                           wifi
GENERAL.HWADDR:                         00:26:C7:3A:5F:9C
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     SCC_GUEST
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/0
IP4.ADDRESS[1]:                         ip = 192.168.92.214/23, gw = 192.168.93.253
IP4.DNS[1]:                             209.244.0.3
IP4.DNS[2]:                             209.244.0.4
IP6.ADDRESS[1]:                         ip = fe80::226:c7ff:fe3a:5f9c/64, gw = ::

nmcli -f all dev show eth2
nmcli -f all dev show # show all devices
nmcli -p dev show eth2 #show DNS info
nmcli -f all g
nmcli c ->
NAME                UUID                                  TYPE             DEVICE
Wired connection 1  c614de98-714f-3f7a-8632-c47e53590cac  802-3-ethernet   eth2

/etc/NetworkManager/system-connections/Ipoh

#edit existing connection
nmcli c edit c614de98-714f-3f7a-8632-c47e53590cac
nmcli c show --active
nmcli c modify id 'MyCafe' 802-11-wireless.mtu 1350

find out my screen resolution:
#1: xdpyinfo | grep dimensions
#2: xrandr

#change screen resolution
type xrandr to show available name for output and resolution:
++++++++++++++++++++
Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192
DIN disconnected (normal left inverted right x axis y axis)
DVI-0 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
   1920x1080      60.0*+
   1280x1024      75.0     60.0
   1152x864       75.0
   1024x768       75.1     60.0
   800x600        75.0     60.3
   640x480        75.0     60.0
   720x400        70.1
DVI-1 disconnected (normal left inverted right x axis y axis)
++++++++++++++++++++
change resolution:
xrandr --output DVI-0 --mode 1920x1080

#terminate the shell if no activity for 30 seconds
export TMOUT=30

#check if my machine is being pinged
tcpdump -ni eth2 icmp
#capture 2 packets and display packets n hex and ascii, write to a file, -tttt: print a timestamp
tcpdump -ni eth2 -c 2 -XX -w filename -tttt
# -n : do not resolve IP address, -X: display hex and ascii content, -S: show absolute sequence number
# -nn: do not resolve IP address or port number
# -XX: -X plus ethernet header
# -A : print in ascii only
tcpdump -nXS
# -D: show available interfaces
# -c : get x number of packets
# -s : show x bytes: -s 0 to show everything (default: 65535)
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v icmp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v tcp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v udp
#
tcpdump -nn -XX -i eth2 -v host <ip>
tcpdump -nn -XX -i eth2 -v src <ip>
tcpdump -nn -XX -i eth2 -v dst <ip>
tcpdump -nn -XX -i eth2 -v net 1.2.3.0/24
tcpdump -nn -XX -i eth2 -v port 3389
tcpdump -nn -XX -i eth2 -v src port 3389
tcpdump -nn -XX -i eth2 -v dst port 3389
tcpdump src port 1025 and tcp
tcpdump portrange 21-23
#only see packets below or above a certain size (in bytes)
tcpdump less 32
tcpdump greater 128
===
tcpdump -nnvvS src 10.5.2.3 and dst port 3389
===
tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'
=== common use
tcpdump -nnXv -i eth2 host 146.222.121.69
tcpdump -nnAv -i eth2 host 146.222.121.69
=====
tcpdump -nnvvvA -i eth2 -w file.pcap host <ip>
=======
tcpdump broadcast/tcp/udp/icmp

#related to ulimit
/etc/security/limits.conf

useful shortcuts for top command:
1 : show individual cpu
z : highlight running processes
c : show absolute path of process

run with an empty environment: env -i

port scanning:
nmap -sT -p- -Pn <hostname or IP>

=== systemd ====
systemctl list-unit-files --type=service #equivalent to ls /etc/systemd/system/*.service and /lib/systemd/system/*.service
systemctl start/stop/enable/disable/restart/status virtualbox
#systemctl enable/disable: Enables/disable a service to be started on bootup:
systemctl mask foo  #Prevent a service from starting dynamically or even manually unless unmasked:
systemctl is-enabled foo
=============
Run level 3 is emulated by multi-user.target. Run level 5 is emulated by
graphical.target. runlevel3.target is a symbolic link to multi-user.target and runlevel5.target is a
symbolic link to graphical.target.
#You can switch to 'runlevel 5' by running
systemctl isolate graphical.target
systemctl set-default <name of target>.target
systemctl get-default
systemctl status
systemctl --failed
systemctl list-units
==============
/etc/systemd , /etc/systemd/system
/lib/systemd , /lib/systemd/system
==============
journalctl: query the contents of systemd journal
example:
journalctl _COMM=crond --since "10:00" --until "11:00"
journalctl --since yesterday
journalctl -PID=<pid>
journalctl -p err #err log level: all log levels: emerg,alert,crit,err,warning,notice,info,debug
journalctl --no-pager
journalctl -o json #json format
journalctl --disk-usage
journalctl --vacuum-size=1G
journalctl --vacuum-time=1years
journalctl -u lpd.service
journalctl -k #like dmesg
journalctl --utc
journalctl -b #most recent boot
journalctl -b -1 #with boot it
journalctl --list-boots
timedatectl
timedatectl status

xxd: make a hex dump

manipulate or dump object files: objcopy and objdump
objdump : display info from object file
nm: list symbols from object file

readlink: follow symbolic link
readlink -e `which google-chrome`
/opt/google/chrome/google-chrome

== virtual console
tty1 through 6 : there is a getty process
To access virtual console from X11: Ctrl-Alt-F1 thru F6
Once in virtual console, can use Alt-F1 throu 6 to switch. can also use alt-lefarrow and alt-rightarrow to cycle

X11 is running on tty7

do it from a command line: chvt 1
== virtual console

keyboard related programs:
loadkeys
showkey

download a full website:
wget --random-wait -r -p -e robots=off -U mozilla www.example.com

pmap: show memory map of a process
/proc/[pid]/statm:
  field #1: size, mapped to VIRT
  field #2: resident, mapped to RES
  field #3: share, mapped to SHR
  field #4: text, mapped to CODE
  field #5: lib , always 0
  field #6: data, mapped to DATA
  field #7: dt, always 0
/proc/[pid]/maps -> similar to output of pmap
/proc/[pid]/smaps
/proc/[pid]/status
/proc/[pid]/task/[threadid] #tgid is process id, pid is thread id
/proc/[pid]/comm : show program name
/proc/meminfo
smem program

#add new repo
#1: add key: apt-key add <key>
#2: add a file to /etc/apt/sources.list.d, call it something like docker.list

ps f : show process hierarchy
ps a : show processes owned by others
ps x : those without tty
ps u : user-friendly format
ps -L : show threads (LWP (lightweight process column))
ps -fHU <username> : show processes of username in hierarchical form
ps -L -o tid,pid,ppid,state,euid,egid,sid,pgid,tpgid,command <pid>
ps -o nlwp <pid> #show number of lightweight processes

#show top processes sorted by memory usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem
#show top processes sorted by cpu usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu

7z a -mhe=on -ppassword important.7z important.txt for-honey.txt

check battery:
upower -i /org/freedesktop/UPower/devices/battery_BAT0 # deprecated supposedly
OR
cat /sys/class/power_supply/BAT0/uevent

#take every 10th line from the file
awk '!(NR % 10)' test.txt

#find working directory of a running process
#1. pwdx <pid1> <pid2>
#2. lsof -p <pid> | grep cwd
#3. readlink -e /proc/<pid>/cwd

pv program: show progress of task

pkg-config: manage compile and link flags for libraries (intended to work with automake and autoconf.)
provide the necessary details for compiling and linking a program to a library.

#convert doc to various format
$ pandoc -t plain README.md
-f : specify input format
-t : specify output format
-o : write to a file

#write a tab literal in Bash command line
$'\t'

#bash: create a string literal
$'..' : create a string with backslash-escaped characters.
example: $'\n\t'

$ ls -d .*
all files/directories that start with ., include . and ..
$ ls -d .[^.]*
all files/directories that start with ., exclude . and ..

---
autotools:
autogen.sh -> generate configure script
configure -> create a makefile

printer stuff:
system-config-printer
lpstat -d
======
#don't do remote admin
cupsctl --remote-admin # update /etc/cups/cupsd.conf
===========
localhost:631 #cups admin
===========
check printing error:
/var/log/cups/error_log


UML: user mode linux
#1: create a .config file
1a. this is better
make ARCH=um defconfig
1b. may not work
make ARCH=um allnoconfig KCONFIG_ALLCONFIG=mini.config
#2: build it
make ARCH=um
#3: run it
./kernel ubda=Slamd64-12.1-root_fs mem=512m
#show config
./kernel --showconfig
====
linux kernel:
#takes current config (.config) and update it based on new kernel release
make oldconfig/silentoldconfig

verifying linux kernel signature:
$ xzcat linux-4.4.tar.xz | gpg --verify linux-4.4.tar.sign -
gpg: Signature made Sun 10 Jan 2016 03:09:18 PM PST using RSA key ID 00411886
gpg: Can't check signature: public key not found
$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 00411886
gpg: requesting key 00411886 from hkp server keys.gnupg.net
gpg: keyserver timed out
gpg: keyserver receive failed: keyserver error

passing an environment to a process (one-off):
$ VAR=value ./test.sh
#note cannot do ./test.sh VAR=HI

#scan a port
nmap -p6000 localhost
#version scan
nmap -p7474 -sV localhost
#check web server in use
nmap -p80 -sV www.google.com
#TCP SYN scan
nmap -p7474 -sS localhost
#
nmap -oA #output in 3 major formats
#OS detection
nmap -O <host>
#output scan in normal
nmap -oN <file>
#output scan in XML format
nmap -oX scandata.xml rigel
#discover all hosts in a network
nmap -sn 146.222.122.128/25

#make your script more robust
set -euo pipefail

#check dirty pages in page cache
$ cat /proc/meminfo | grep Dirty
Dirty:               204 kB
#flush system buffers
$ sync


As of 2.4 kernel, these two caches (page and buffer caches) have been combined. Today, there is only
one cache, the Page Cache
---
Buffers are in-memory block I/O buffers. They are relatively short-lived. Prior to Linux
kernel version 2.4, Linux had separate page and buffer caches. Since 2.4, the page and
buffer cache are unified and Buffers is raw disk blocks not represented in the page
cache—i.e., not file data. The Buffers metric is thus of minimal importance.


#I/O scheduler
cat /sys/block/sda/queue/scheduler
--> noop [deadline] cfq
CFQ : Completely Fair Queuing

#ulimit:
/etc/security/limits.conf

#run stress test
siege --log=siege.log -t5M -c 4 -i -b -f url.txt

tmux: from 2 horizontal panes to 2 vertical panes (and vice versa)
Prefix <SPC> : cycle through available layouts (bound to next-layout)
Prefix Alt-1 : even horizontal
Prefix Alt-2 : even vertical

ssh X11 forwarding
want to display on my-machine (where X server is running)
remote (where client will be run)

On my-machine: ssh -X user@remote
OR ssh -Y user@remote

#check for CRLF ending:
$ file /a/tapasjo/copy-paste.txt
/a/tapasjo/copy-paste.txt: ASCII text, with CRLF line terminators
---
$ grep -c  $'\r' /a/tapasjo/copy-paste.txt
27

braces:
trimming with variable substition:
$ var=foo.pdf
$ echo ${var%.pdf} #trim suffix
foo
$ echo ${var#foo} #trim prefix
.pdf
====
#parameter substitution:
IP=1.2.3.4
echo ${IP/./ }
1 2.3.4
echo ${IP//./ }
1 2 3 4
#an extra / means global substitution
====
$ echo {00..8..2}
00 02 04 06 08
$ echo {00..8}
00 01 02 03 04 05 06 07 08
$ echo {D..T..4}
D H L P T

single bracket vs double bracket
single: POSIX
double: non-POSIX, only in bash, zsh, ksh
[ is a shell builtin and a program (/usr/bin/[
[[ is a keyword

profiling java program with perf:
#1. profiling: generate a file called perf.data
sudo perf record -F 99 -a -g sleep 30
OR
sudo perf record -F 99 -a -g -p PID sleep 30
#2. create method mappings : create a file called /tmp/perf-pid.map
    this file is used to translate memory address into function and variable names (used by perf report/script)
/home/heech/gitrepo/perf-map-agent/bin/create-java-perf-map.sh <pid>
#3. generate flame graph (need perf.data in current directory)
sudo perf script | ~/gitrepo/FlameGraph/stackcollapse-perf.pl | ~/gitrepo/FlameGraph/flamegraph.pl --color=java --hash > flamegraph.svg
# text report
sudo perf report --stdio
#ncurses window
sudo perf report
#list raw event
sudo script
===
#cpu counter stats
perf stat -a sleep 10

Ctrl-x, Ctrl-e : will bring up an $EDITOR containing whatever is currently entered into the prompt.
  "\C-x\C-e": edit-and-execute-command
Ctrl-Alt-e to expand any placeholders/variables in the current line.
  "\e\C-e": shell-expand-line

echo ~- # echo previous directory

#capture output of command into clipboard
"do stuff" | xsel -ib

kernel version numbering
example: 4.2.0-34
4: kernel version
2: major revision of the kernel version
0: minor revision of the kernel. It is only changed when new features or new drivers are added.
34: The fourth number represents corrections, such as security patches and bug (i.e., error) fixes

#show kernel drivers handling each device and also kernel modules capable of handling it.
lspci -kv
#check graphic driver
lspci -nnk |grep -iA2 vga

if the system hangs:
Hold down the ‘alt’ and ‘sysrq’ keys on your keyboard and whilst they are held down type the following slowly:
REISUB

#get SATA/IDE device info
hdparm /dev/sda
#show blocks occupied by a file
sudo hdparm --fibmap <filename>
example output:
file.txt:
 filesystem blocksize 4096, begins at LBA 1404430336; assuming 512 byte sectors.
 byte_offset  begin_LBA    end_LBA    sectors
           0 1869805696 1869805703          8


badblocks : search a device for bad blocks
readelf: display info about ELF files

procfs: originally intended to expose process info, then became a big mess
sysfs: expose kernel info

kernel diff and patch:
#1 generate patch
diff -Naur -X linux-2.6.19/Documentation/dontdiff linux-2.6.19/ linux-2.6.19-dirty/ > my_patch
#2 apply patch
cd linux-2.6.19; patch -p1 < ../patch-2.6.20
# -p1 tells the patch command to skip 1 leading slashes from the filenames present in the patch file.

===========================
creating and applying patches:
diff -u hello.c hello_new.c > hello.patch
patch < hello.patch
patch -b < hello.patch #take a backup before applying patches
patch --dry-run < hello.patch #dry run
patch -R < hello.patch #reverse a patch

kernel entry point:
arch/x86/boot/header.S -> calll main

loop device is a pseudo ("fake") device (actually just a file) that acts as a block-based device. a file that contains a filesystem
loop device is a pseudo device that makes a file look like a block device. (command: losetup /dev/loop0 <filename>)

========= loop device =========
dd if=/dev/zero of=file.img bs=1k count=10000
losetup /dev/loop0 file.img
mkfs.ext4 -c /dev/loop0 10000
mount -t ext4 /dev/loop0 /mnt/point1
========= loop device =========

#system-wide limit on open file descriptors
cat /proc/sys/fs/file-max
#change limit:
/etc/security/limits.conf
/etc/sysctl.conf

from setrlimit (ulimit is a wrapper around setrlimit):
===
The soft limit is the value that the kernel enforces for the corresponding resource.  The hard limit
acts as a ceiling for the soft limit: an unprivileged process may set only its soft limit to a value
in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A privileged
process (under Linux: one with the CAP_SYS_RESOURCE capability) may make arbitrary changes to either
limit value.

#time zone: display time
$ TZ="America/New_York" date
Tue Apr 19 10:51:17 EDT 2016
#time zone files: /usr/share/zoneinfo/

cat /etc/os-release

linux kernel startup:
#kernel entry point:
arch/x86/boot/header.S
#next
arch/x86/boot/main.c
#next
arch/x86/boot/pm.c
#next
arch/x86/boot/pmjump.S
#next entry point:
arch/x86/kernel/head_64.S
#next
arch/x86/kernel/head64.c -> x86_64_start_kernel() ->
#next
init/main.c -> start_kernel() -> rest_init() -> kernel_init()
                                             -> kernel/sched/idle.c: cpu_startup_entry() -> cpu_idle_loop()
kernel init:

#dump info file system and look at superblock
dumpe2fs /dev/sda6 | grep -i superblock

superblock is essentially file system metadata and defines the file system type, size, status, and
information about other metadata structures (metadata of metadata).
metadata about filesystem.
====
An inode exists in, or on, a file system and represents metadata about a file.
====
dentry (directory entry)
what the Linux kernel uses to keep track of the hierarchy of files in directories. Each dentry maps
an inode number to a file name and a parent directory.

#documentation in linux source: Documentation/sysctl/vm.txt
To free pagecache:
echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
echo 3 > /proc/sys/vm/drop_caches

#manipulate the real-time attributes of a process : chrt
#set or retrieve a process's CPU affinity : taskset

hardware interrupts:
/proc/interrupts:
first column: interrupt #
second column: how many times the CPU core has been interrupted
#from /proc/interrupts : i8042 is the keyboard controller
i8042 controller controls PS/2 keyboards and mice in PCs
smaller IRQ number means higher priority
=====
software interrupts: /proc/softirqs

/proc/stat : show interrupt count

/sys/devices/system/cpu

system performance tools:
mpstat
sar
iostat
pidstat
sadf
cifsiostat

interrupt CPU affinity value:
/proc/irq/<irq#>/smp_affinity  #this is a mask
/proc/irq/<irq#>/smp_affinity_list #this is the cpu number

showkey #show linux key code
xev #show X11 key code

block device: data move in blocks. support buffering and random access. accessed randomly
sector: smallest addressable unit on a block device. a physical property of the device,
  the smallest unit of transfer for the device.
block: smallest addressable unit in a filesystem, smallest unit of transfer for a block device driver.
block size must be a power of two and cannot be larger than a page frame. must be a multiple
of the sector size.
each block requires its own buffer, which is a region of RAM used by the kernel to store
the block's content.
============
character device: data is streamed character by character. accessed as a stream of data.

linux has two disk caches: buffer cache and page cache
buffer cache and page cache have been combined.

/proc/filesystems

software interrupt (SoftIRQ)
processes: ksoftirqd/0 , etc
software interrupts are kernel routines that are scheduled to run at a time when other
tasks will not be interrupted.

When a NIC receives incoming data, it copies the data into kernel buffers using DMA.
The NIC notifies the kernel by means of a hardware interrupt. These interrupts do minimal
work as they have already interruptted another task and cannot be interruptted themselves.
Software interrupts then drain the network adapter receive ring buffers.
protocol handlers then process the data. finally, data is delivered to a socket
buffer where an application can call the receive function.

networking info:
/proc/net/dev
/proc/net/tcp
/proc/net/unix
/proc/net/snmp

networking tools:
dropwatch
ip
ethtool

load: # of processes using or waiting for the CPU.
load average: the load averaged over 1,5,15 minutes
/proc/loadavg

parted /dev/sda print

net: Tool for administration of Samba and remote CIFS servers.
mtr: a network diagnostic tool
iptables: firewall
mrtg - multi router traffic grapher

load balancing tool: pen, pound, balance

snort - flexible Network Intrusion Detection System

============
monitor SMART disk: smartctl and smartd
smartctl -i /dev/sda #info
smartctl -a /dev/sda #all info
smartctl -x /dev/sda #even more info
smartctl -H /dev/sda #health info
smartctl -l selftest /dev/sda

#available test: offline, short, long, conveyance
smartctl -a:
Pre-fail: if the VALUE column is below the THRESH column, be concerned

#run test
smartctl -t short /dev/sda
smartctl -t long /dev/sda

#abort test
smartctl -X

#show capability:
smartctl -c /dev/sda
===================

rootkit: a software package that enables an unauthorized user to obtain
root privileges

#find processes using files/sockets
fuser -v -m <filesystem> #filesystem can be specified as directory name or /dev/sda1
OR:
lsof /dev/sdc1

gpart: guess partition table. used for recovery

gddrescue: clone bad disk
partimage: clone disks, does not support ext4, don't use
fsarchiver: support ext4, use this instead of partimage

lost+found: store files whose actual locations cannot be determined
during a filesystem consistency check.
details:
fsck might find data that looks like a complete file but doesn't have a name on the system — an
inode with no corresponding file name. This data is still using up space, but it isn't accessible by
any normal means.

recover deleted files:
unmount the partition (go to single user mode if necessary)
need to know what you're looking for, do a grep on the device:
grep -a -B10 -A100 -i <pattern> /dev/sda2 > file.out
#-a: treat the device as a series of ascii char

shred: overwrite a file with random data, can be used on devices too:
shred -n 3 -vz /dev/sda
shred -zvu tecmint.pdf
# -z: adds a final overwrite with zeros to hide shredding.
# -u: helps to truncate and remove file after overwriting.
# -v: verbose

autopsy - graphical interface to SleuthKit
sleuthkit - tools for forensics analysis on volume and filesystem data

#burn cd/dvd
growisofs (preferred?)
example: growisofs -dvd-compat -Z /dev/sr0=isoimage.iso
wodim

#mounting an ISO image
mount -t iso9660 -o ro,loop /path/to/file.iso /mount-point

isosize : show the size of an iso9660 filesystem

mountpoint: check whether a directory is a mount point

extended attributes are name/value pairs associated with a file. a form of metadata
need to configure kernel: FS_XATTR
need to configure fstab
applications: attr, getfattr, setfattr

/etc/default/console-setup
#change console font:
dpkg-reconfigure console-setup #this will change /etc/default/console-setup
then run setupcon in virtual console
the fonts are in: /usr/share/consolefonts/
setfont Uni2-TerminusBold24x12
in /etc/default/console-setup:
FONTFACE="TerminusBold"
FONTSIZE="12x24"
=============
The font size is specified by 2 numbers in pixels represented as HEIGHT x WIDTH. If the width is 8
pixels, then only the height is specified. For comparison purposes, the default console font size is
16 (that is, 16 x 8).

tune2fs : adjust filesystem parameters
#list content of superblock, etc
tune2fs -l /dev/sda6
#set label
tune2fs -L <label> /dev/sda6
#similar to
dumpe2fs -h /dev/sda6
=====
tune2fs:  -m reserved-blocks-percentage (defaul: 5)
#reduces the reserved area to 2% of the filesystem, which may be more
tune2fs -m 2 /dev/sda1
#sets the filesystem to have no reserved blocks,
tune2fs -r 0 /dev/sda1

partprobe - inform the OS of partition table changes

DRM (direct rendering manager): a subsystem of the kernel responsible for
interfacing with GPU of video cards.
each GPU is a DRM device: /dev/dri/card0
DRM interface with GPU and graphics RAM
KMS interface with display controller, which interface with monitor screen

linux framebuffer: fbdev , /dev/fb0
allow access to graphics hardware through an API
The Linux framebuffer (fbdev) is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console.

Text mode is a computer display mode in which content is internally represented on a computer screen
in terms of characters rather than individual pixels.

restart X server:
#1: crude: kill -USR2 <pid of x server>
#2: better: systemctl restart lightdm

#length of command line

The limit for the length of a command line is not imposed by the shell, but by the operating
system. POSIX denotes this limit ARG_MAX and on POSIX conformant systems you can query it with
$ getconf ARG_MAX
====
According to POSIX: http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
Maximum length of argument to the exec functions. This means: Without calling exec, there is no
ARG_MAX limitation. So it would explain why shell builtins are not restricted by ARG_MAX.

===== curl post with file =====
curl -F "data=@post.data"
the string looks like this:
--------------------------73e6530ff229c469
Content-Disposition: form-data; name="data"; filename="post.data"
Content-Type: application/octet-stream

{"rels": [{"from_vsid": "KTX1-OBU-099-South-HKG01-1", "to_vsid": "PHKG-7JY-057-North-GUX02-1", "rel_type": "TERMINALTRANSFERLEG_HOT"}]}

--------------------------73e6530ff229c469--
===========================

kvm daemon: libvirt-bin, libvirt-guests
== need to do this:
sudo systemctl start libvirtd virtlogd.service
kvm-ok #sanity check
virsh -c qemu:///system list
OR
virsh -c qemu:///system list --all
OR
virsh list --all
#the name column of virsh list is the domain name
===
default location of kvm images: /var/lib/libvirt/images
=== customize image location:
/etc/libvirt/storage/default.xml (use virsh pool-edit default)
--- storage pool
virsh pool-dumpxml default
virsh pool-edit default
virsh pool-list --all
virsh pool-info default
virsh pool-destroy domain
virsh pool-undefine domain
-----
change default location for images:
1. virsh pool-edit default
2. systemctl restart libvirtd
3. virsh pool-dumpxml default #to confirm
====
GUI : virt-manager
----
dump domain info: virsh dumpxml <domain-name>
----
virsh list --with-managed-save --all
virsh list --without-managed-save --all
virsh start foo --console
virsh reboot foo
virsh shutdown foo
virsh suspend foo
virsh resume foo
virsh console foo
virsh edit foo
virsh define foo
virsh snapshot-list foo
virsh ttyconsole foo
==== to delete VM
virsh destroy foo #domain needs to be running
virsh undefine foo
#delete the image manually (<domain-name>.qcow2)
----
for undefine: You can also specify --managed-save to delete any managed save images and --snapshots-metadata to
remove snapshots for the specified VM.
----
after move images:
virsh edit domainID
change: <source file='/mnt/raid/images/rh-5.5.qcow2'/>
===
arch linux: change KVM config:
video mode was qxl, change to virtio
===
virsh net-list --all
virsh net-dumpxml default

in /boot/grub/grub.cfg : add console=ttyS0 in guest VM
then you can "virsh console foo"

================================

bind mount: remount part of a file hierarchy elsewhere: mount --bind olddir newdir
after this, the same contents are available in two places.
===
if there are mount points under olddir, their contents are not visible under newdir unless use --rbind
use mount --rbind olddir newdir #replicate mount points under olddir
=== BEST:
A bind mount is an alternate view of a directory tree.
bind mount provides a view of a directory tree at a different location.
====
Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead
takes an existing directory tree and replicates it under a different point. The directories and
files in the bind mount are the same as the original. Any modification on one side is immediately
reflected on the other side, since the two views show the same data.
=========
The alternative (classic) way to create a read-only bind mount is to use remount operation, for example:
mount --bind olddir newdir
mount -o remount,ro,bind olddir newdir
========================
when you mount a filesystem on a directory, this hides what is behind the directory. The files
in the directory become inaccessible until the directory is unmounted.
========
filesystem: a collection of files and directories in a hierarchy.
mounting: adding a filesystem to the global namespace of files and directories

Filesystem in Userspace (FUSE) is a software interface for Unix-like computer operating systems that
lets non-privileged users create their own file systems without editing kernel code. This is
achieved by running file system code in user space while the FUSE module provides only a "bridge" to
the actual kernel interfaces.

espeak : software speech synthesizer

segments of a program:
text segment: contain the executable code and read-only data
initialized data segment: contain initialized data
uninitialized data segment (bss): contain uninitialized data
stack segment

connect android to usb port: use MTP
mount point: /run/user/<userid>/gvfs

demand load executables: only those parts of a program required for execution are loaded into memory.
when a new process is created using fork(), memory is not requested, but instead the memory
for the parent process is used jointly by both processes. if the new process accesses part of the
memory in write mode, this section is copied before being modified: copy-on-write

/dev/mem is a character device file that is an image of the main memory of the computer.

blockdev --getss #sector size
blockdev --getbsz #block size

TZ=UTC date # get a date in UTC or: date -u
#convert epoch second to a date in UTC
TZ=UTC date --date=@1452832200
#convert epoch second to a date in UTC (ISO format)
TZ=UTC date --date=@1452832200 +%Y-%m-%dT%H:%M:%S.000Z
output: 2016-01-15T04:30:00.000Z
#convert date to epoch second
TZ=UTC date --date="2015-08-31 13:30:15" +%s
#past date
date --date='2 days ago'
#future date
date --date='2 days'

getconf PAGESIZE #get page size

pcmanfm --desktop-pref

setxkbmap: set keyboard using X extension
setxkbmap -print -verbose 10

lxpanelctl : (menu/run/config/restart)

scrot -cu -d 5

gnome-system-monitor


There are three different kinds of buffering strategies:
Characters written to or read from an unbuffered stream are transmitted individually to or from the file as soon as possible.
Characters written to a line buffered stream are transmitted to the file in blocks when a newline character is encountered.
Characters written to or read from a fully buffered stream are transmitted to or from the file in blocks of arbitrary size.
===
Newly opened streams are normally fully buffered, with one exception: a stream connected to an
interactive device such as a terminal is initially line buffered.
===
The use of line buffering for interactive devices implies that output messages ending in a newline
will appear immediately—which is usually what you want. Output that doesn’t end in a newline might
or might not show up immediately, so if you want them to appear immediately, you should flush
buffered output explicitly with fflush.
===
stdin : always buffered
stderr: always unbuffered
stdout: if terminal, then line-buffered, else unbuffered

stdbuf: modify buffering operations for streams
example: tail -f file | cut -d ' ' -f1 | uniq
nothing because the output of cut is buffered

tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq
#use stdbuf -o0 if the data is not line-oriented
this will disable output buffering for the cut program

logical volume: a filesystem that appears to be a single physical volume,
but is actually assembled from space that has been allocated on multiple
physical partitions.

linux process and thread=======
process descriptor: struct task_struct
	pid_t pid; // this is the thread id
	pid_t tgid; // this is the process id

when a new process is created, it appears as a thread where both the PID and TGID are the same (new)
number.
When a thread starts another thread, that started thread gets its own PID (so the scheduler can
schedule it independently) but it inherits the TGID from the original thread.
====
getpid() returns tgid
gettid() returns pid
==========================

bash testing:
[ "$VAR" ] is equivalent to [ -n "$VAR" ] # true if not empty

power management tool: tlp, powertop

cpufrequtils (package): cpufreq-info command

core dump setting:
ulimit -c
cat /proc/sys/kernel/core_pattern

useful commands from moreutils:
combine, errno, ifdata, isutf8, sponge, ts, vidir, vipe, zrun
===
example: sort myfile.txt | sponge myfile.txt

nice -n 19 <program>
renice -n 19 <pid>
ionice -c 3 cp bigfile.mp4 backup.mp4

take a screen shot of a video at 5:12 into the video
mplayer -vo png -ss 5:12 -frames 1 my-video.mp4

hide your processes from other users:
after this command, only my processes are under /proc
$ mount -o remount /proc -o hidepid=2

get location of IP address
curl ipinfo.io/216.58.192.4

mplayer -vo aa MovieName.avi #black and white
mplayer -vo caca MovieName.avi #color
====
exif image_name.jpg
====
mp3info music_file.mp3
====
convert original.jpg -resize 50% -quality 95 smaller.jpg #shrink by 50%
convert original.jpg -resize 200% -quality 95 bigger.jpg #enlarge
convert ships.jpg -rotate 30 tilt-ships.jpg #rotate
convert ships.jpg -background none -rotate 90 turn-ships.jpg #rotate
== make a banner
convert -background white -fill blue -font Courier -pointsize 32 label:'Happy Birthday' banner.jpg
== read text from a file
convert -background white -fill black -font Courier -pointsize 12 label:@message.txt banner.gif
== save command output to an image
ifconfig | convert label:@- myipaddress.png
== save command output to an existing image and create a new image
convert -font -misc-fixed-*-*-*-*-*-*-*-*-*-*-*-* -fill black -draw "text 270,260 \" `ip addr` \"" Linux.jpg myipaddress.jpg

record your desktop session (video)
# -s : resolution, alternative: -s 1024x768
ffmpeg -f x11grab -s wxga -r 25 -i :0.0 -sameq ~/my_video.mpg
## cut video
ffmpeg -i in.mp4 -ss [start] -t [duration] -c copy out.mp4
OR
ffmpeg -i in.mp4 -ss [start] -to [stop] -c copy out.mp4

# print sensors info
sensors

cgroups (control groups): allow you to set limits on resources for processes and their children.

mount namespace: make it look like you have the entire filesystem namespace
UTS (unix time sharing) namespace: make it look like you have your own hostname and domain name.
IPC namespace: you have your own message queues
PID namespace: you have your own process ID
network namespace: you have your own network devices
user namespace: you have your own user id

apparmor: kernel enhancement to confine programs to a limited set of resources
program: apparmor_status

#show networking info
networkctl list
network-admin

iwconfig : configure wireless network interface

chvt # change virtual console, has to run inside text-based virtual console

#capture screenshot
import -display :0.0 -window root sshot1.png

alias dos2unix='recode dos/CR-LF..l1'
alias unix2dos='recode l1..dos/CR-LF'
alias unix2win='recode l1..windows-1250'

#turn off ping replies
sysctl -w net.ipv4.icmp_echo_ignore_all=1
#slow down ping reply rate
sysctl -w net.ipv4.icmp_echoreply_rate=10

#lxterminal icons
/usr/share/icons/Lubuntu/apps/22/lxterminal.svg
/usr/share/icons/Lubuntu/apps/48/lxterminal.svg
/usr/share/icons/Lubuntu/apps/16/lxterminal.svg
/usr/share/icons/Lubuntu/apps/24/lxterminal.svg

#silence the beep
setterm -blength 0

By default, Linux uses the atime option on a disk mount, which means it writes a timestamp (e.g. a
write to the drive) every time it reads anything. So in this case, reads cause writes – and also
disk seeks, because a read from a file will then trigger having to write to the directory that
contains the file. This even occurs if a file is read from the file system’s page cache (reading
from the machine’s memory rather than the drive).
====
you can use the relatime option instead, which only writes a timestamp
when a file or directory is written to.
==
as of kernel 2.6.30, relatime is the default

#temporary filesystem
mkdir /ramdisk
mount none -t tmpfs -o size=256M /ramdisk

ss : display socket info
arping: send ARP request to a neighbor: arping -I eth0 192.188.1.1
ethtool

/sys/class/leds/<name>/trigger

modinfo radeon | grep description

#get module parameters
/sys/module/<mod_name>/parameters

#sort the output while keeping the header at the top
df -hP | awk 'NR==1;NR>1{print|"sort -k5rn"}'

nsswitch.conf - Name Service Switch configuration file
determine the order in which various name resolution services will be tried
--
getent : get entries from the name service switch library
getent hosts

GConf: store configuration settings. similar to Windows registry. deprecated.
GConf: to be replaced by GSettings and dconf
===
dconf is a low-level configuration system. Its main purpose is to provide a backend to GSettings on
platforms that don't already have configuration storage systems.
---
Gsettings is a development library used to read and write to a configuration store backend. On
Linux, it uses Dconf, but on Windows, it uses the registry, and on OS X, it uses a native data
store.
-- bottom line: don't use dconf directly. use GSettings
gsettings list-schemas
gsettings list-recursively #list all the keys
#after you find the schema, org.gnome.GWeather is a schema name
gsettings list-keys org.gnome.GWeather
#compare to following
gsettings list-recursively  | grep org.gnome.GWeather
#get the value of a key
gsettings get org.gnome.GWeather default-location
---
GUI: dconf-editor

#list files that do not match a pattern
ls !(one)
ls !(one|two)

isoinfo -i <iso-file> -l #list content
isoinfo -i <iso-file> -x <file> #extract file

time zone:
ln -s /usr/share/zoneinfo/America/Los_Angeles /etc/localtime

hwclock --systohc #generate the /etc/adjtime file
-- when setting hwclock, need to indicate wheter --utc or --localtime
hwclock --debug #can show whether hw clock is in local time or UTC
3rd line of /etc/adjtime: indicate whether hw clock is in local time or UTC

edit locale info in /etc/locale.gen, then run command locale-gen

hostnamectl status
hostnamectl set-hostname myhostname

nroff and troff are UNIX commands (and the utilities that support them) for formatting text files
for printing. nroff is designed for formatting output for line printers and letter-quality
printers. troff is designed for formatting output for typesetters. troff contains some special
functions that apply only to typesetters; otherwise, the commands are identical and either can be
used.
===
Groff is the GNU replacement for the troff and nroff text formatters.

kbd_mode : report/set keyboard mode of console
kbdrate: set keyboard repeat and delay time
kbdinfo: obtain info about console
kbdinfo getmode: text/graphics
kbdinfo gkbmode: unicode
kbdinfo gkbled: scrolllock, numlock, capslock
unicode_start : put keyboard and console in unicode mode
---
keymap: the mapping between the key pressed and the characer used by the computer

console: console is in utf8 mode, so program output is utf8 (8-bit values)
a translation table maps 8-bit values to 16-bit unicode values. such translation table
is called unicode console map. the kernel then uses the 16-bit unicode value to choose
the right glyph from the font file and display it.
setfont -m : used to specify a unicode console map
===
font file also contains Unicode mapping table, which maps a Unicode value to each glyph
setfont -u : used to specify a unicode mapping table

localectl status
localectl list-keymaps
localectl list-locales

for virtual console: keyboard translation table commands: dumpkeys, loadkeys, showkey
--
dumpkeys > backup.kmap #save current keymap
loadkeys backup.kmap #restore keymap
showkey #check which key code is assigned

brctl show : show ethernet bridge

/etc/securetty

The configuration file for DNS resolvers is /etc/resolv.conf
The resolver is a set of routines in the C library that provide access to the Internet Domain Name
System (DNS).

A Linux system actually has two clocks: One is the battery powered "Real Time Clock" (also known as
the "RTC", "CMOS clock", or "Hardware clock") which keeps track of time when the system is turned
off but is not used when the system is running. The other is the "system clock" (sometimes called
the "kernel clock" or "software clock") which is a software counter based on the timer interrupt. It
does not exist when the system is not running, so it has to be initialized from the RTC (or some
other time source) at boot time. References to "the clock" in the ntpd documentation refer to the
system clock, not the RTC.

ntp -p : show NTP status
ntptime

network bridge: sw/hw that combines two or more network segments. it behaves like
a virtual netowkr switch.
bridge is a way to connect two Ethernet segments in a protocol-independent way. packets are
forwarded based on Ethernet address, rather than IP address.

/etc/default/rcS: UTC=no/yes #assume real-time clock in UTC or not
/etc/default/rcS: variables that affect the behavior of boot scripts

tzselect : select time zones interactively

hardware clock (aka real time clock, RTC)
by default, Windows think RTC is in local time.
This can be changed in the registry:
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
"RealTimeIsUniversal"=dword:00000001
== make following changes in home laptop:
1. check BIOS time
2. Windows: change registry
3. boot, set BIOS time to UTC
4. boot into Windows, verify time
5. reboot, check BIOS time
6. boot into Windows, verify time again
7. reboot, check BIOS time again
8. then reboot from USB/CD (linux)
9. mount /dev/sdaX, change /etc/default/rcS (UTC=yes) and /etc/adjtime (change LOCAL to UTC)
10. boot into Linux, verify time
11. reboot, check BIOS time, go to Linux, verify time again
=====
write UTC to RTC (hwclock --systohc --utc)
== window time service?
windows: sc config w32time start=disabled/demand ??

Linux : 11 minute mode: CONFIG_GENERIC_CMOS_UPDATE compiler option
the kernel copies the system time to the hardware clock every 11 minutes
this mode is useful when NTP is running

POSIX character classes
[:upper:]	[A-Z]	uppercase letters
[:lower:]	[a-z]	lowercase letters
[:alpha:]	[A-Za-z]	upper- and lowercase letters
[:digit:]	[0-9]	digits
[:xdigit:]	[0-9A-Fa-f]	hexadecimal digits
[:alnum:]	[A-Za-z0-9]	digits, upper- and lowercase letters
[:punct:]		punctuation (all graphic characters except letters and digits)
[:blank:]	[ \t]	space and TAB characters only
[:space:]	[ \t\n\r\f\v]	blank (whitespace) characters
[:cntrl:]		control characters
[:graph:]	[^ [:cntrl:]]	graphic characters (all characters which have graphic representation)
[:print:]	[[:graph] ]	graphic characters and space

os-prober
linux-boot-prober /dev/sda8

rmmod pcspkr #disable PC speaker

setterm : set terminal attribute

127.0.1.1: the purpose is to assign an IP to a host name in the absence of a network
connection. If the machine has a permanent IP address, use it instead of 127.0.1.1

resize partition:
checking: e2fsck -f /dev/sda1, dumpe2fs -h /dev/sda1
enlarge: extend partition, then resize file system
shrink:
resize filesystem: resize2fs /dev/sda1 1000s # 1000s specify 1000 sectors
afterwards, run e2fsck and dumpe2fs to check
shrink partion: use parted:
resizepart 1 10547s #1 is partition number and 10547s is the ending sector:
afterwards:
/dev/sdb1        2048 10547    8500  4.2M 83 Linux
==
afterwards, run blkid to check partition UUID

scrollback buffer: between video adapter and the display device
change scrollback buffer size: provide fbcon=scrollback:Nk where N is the buffer size
in kilobytes. default is 32k. (http://www.kernel.org/doc/Documentation/fb/fbcon.txt)

search with locate:
1. locate --basename '\pkg'
output: /usr/src/linux-headers-4.8.0-26-generic/include/config/x86/pkg
2. locate --basename 'pkg'
output: a lot, such as /var/log/dpkg.log
conclusion: 'pkg' means '*pkg*'
upshot: Where \ is a globbing character, it disables the implicit replacement of pkg by *pkg*.

import : saves any visible window on an X server and outputs it as an image file. You can capture a
       single window, the entire screen, or any rectangular portion of the screen.
example: import -window emacs5 test.jpg

restart frozen system (not tested):
Press ALT + PrntScrn and then, while holding those, type the following letters in order: REISUB.

/etc/rc.local : executed on reboot

top/htop process states:
R    running or runnable (on run queue)
S    interruptible sleep (waiting for an event to complete)
D    uninterruptible sleep (usually IO)
Z    defunct ("zombie") process, terminated but not reaped by its parent
T    stopped by job control signal
t    stopped by debugger during the tracing
X    dead (should never be seen)
===
memory usage:
VIRT/VSZ :
The total amount of virtual memory used by the task. It includes all code, data and shared libraries
plus pages that have been swapped out and pages that have been mapped but not used.
If an application requests 1 GB of memory but uses only 1 MB, then VIRT will report 1 GB. not very useful.
---
RES/RSS: is the portion of memory occupied by a process that is held in main memory (RAM).
non-swapped physical memory used by a process. does not include the swapped out memory.
some of the memory may be shared with other processes.
If a process uses 1 GB of memory and it calls fork(), the result of forking will be two processes
whose RES is both 1 GB but only 1 GB will actually be used since Linux uses copy-on-write.
---
SHR: The amount of shared memory used by a task.
---
MEM% : A task's currently used share of available physical memory.

line discipline: cat /proc/tty/ldiscs
cat /proc/tty/drivers

ldattach: attach a line discipline to a serial line

A line discipline (LDISC) is a layer in the terminal subsystem in some Unix-like systems. The
terminal subsystem consists of three layers: the upper layer to provide the character device
interface, the lower hardware driver to communicate with the hardware or pseudo terminal, and the
middle line discipline to specify a policy for the driver.
---
line discipline does input processing in the kernel (provide line editing)

tty: (stty -a)
canonical mode: icanon (input characters are assembled into lines)
icrnl (translate CR to newline)
-igncr : don't ignore CR
====
serial port terminal: /dev/ttySn
pseudo terminal: /dev/pty
controlling terminal: /dev/tty
console: /dev/ttyn, /dev/console

EDID: /sys/class/drm/*/edid
EDID program: sudo get-edid | parse-edid
sample output:
Section "Monitor"
        Identifier "DELL P2411H"
        ModelName "DELL P2411H"
        VendorName "DEL"
        # Monitor Manufactured week 22 of 2011
        # EDID version 1.3
        # Analog Display
        Option "SyncOnGreen" "true"
        DisplaySize 530 300
        Gamma 2.20
        Option "DPMS" "true"
        Horizsync 30-83
        VertRefresh 56-76
        # Maximum pixel clock is 170MHz
        #Not giving standard mode: 1152x864, 75Hz
        #Not giving standard mode: 1280x1024, 60Hz
        #Not giving standard mode: 1920x1080, 60Hz
        Modeline        "Mode 0" 148.50 1920 2008 2052 2200 1080 1084 1089 1125 +hsync +vsync
EndSection

sudo hwinfo --monitor will list the graphics modes supported by the monitor. also detailed info about monitor
sudo hwinfo --framebuffer will list the graphics modes supported by the computer.

a Snap app is self-contained package that includes all of the dependencies and libraries that an
application needs to run. These apps are sandboxed, install to their own directory, and can’t touch,
see or otherwise 'interface' with the rest of your system without your permission.

find broken symbolic links:
find . -type l -! -exec test -e {} \; -print

dump man pages:
man man | col -b  > file.txt # col -b: remove backspaces

blacklisting on kernel command line: modprobe.blacklist=modulename

change sudo timeout session:
#1. edit file: sudo visudo
#2. add this line:
Defaults        env_reset,timestamp_timeout=20 #20 minutes
#if 0, timeout right away, if -1, disable password prompt

kill: If sig is 0, then no signal is sent, but error checking is still performed.

#system info tool
inxi --recommends #check system
inxi #without argument
inxi -S #system
inxi -M #machine
inxi -C #cpu
inxi -G #graphics
inxi -A #audio
inxi -N #network
inxi -D #hard disk
inxi -b #summary
inxi -p #partition
inxi -F #full info

bash -n #check syntax without running

laptop battery checking: acpi

curl ifconfig.me #get your IP address from the viewpoint of others on the internet

getopts
example: ${OPTIND} is equal to 1 , ${!OPTIND} is equal to the value of the first argument
